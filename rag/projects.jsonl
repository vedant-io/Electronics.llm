{"title":"How to build a Wearable Air Quality Monitor Pendant using STM32 & SGP40 Sensor","content":"Indoor and outdoor air pollution significantly impacts human health, causing respiratory issues and reducing life expectancy. Personal air quality monitoring has become essential for protecting ourselves from harmful airborne contaminants like volatile organic compounds (VOCs), particulate matter, and toxic gases. This DIY wearable air quality monitor pendant continuously tracks Total Volatile Organic Compounds (TVOC) levels using the professional SGP40 sensor. The device features intuitive LED color coding and audio alerts, making air quality status immediately recognizable for users of all ages. When dangerous pollution levels are detected, the wearable air quality monitor provides instant warnings to help you move to safer environments.\n\nThis comprehensive tutorial covers everything needed to build your own wearable air quality monitoring system, including circuit design, PCB fabrication, 3D printing, and Arduino programming for the STM32 microcontroller. We have also built a lot of other electronics projects here at CircuitDigest, and many air quality monitoring projects if you are looking for something simple and beginner-friendly check out this arduino air quality monitoring system.\n\n# Air Quality Pendant Overview and Features\n\nHave you ever wondered about the air quality in your home or office? This wearable air quality pendant answers that question by monitoring TVOC levels throughout your day. Using the reliable SGP40 sensor, it gives you instant feedback through color-changing LEDs and gentle musical tones - no complicated readings to interpret. The best part? The smooth LED transitions and pleasant alert sounds make it feel more like a piece of smart jewelry than a technical device.\n\nWhat makes this air quality monitor special is how smartly it works behind the scenes. The STM32 microcontroller multitasks seamlessly like reading sensors, updating displays, and playing alerts without any lag. It's like having a tiny environmental scientist on your chest, constantly checking the air and letting you know when things change. Whether you're at home cooking dinner, working in an office, or visiting a new building, you'll always know what you're breathing.\n\n# Components Required for Air Quality Monitor\n\nBuilding a wearable air quality monitor requires carefully selected low-power components to ensure all-day battery operation. Each component in this TVOC monitoring system was chosen for optimal energy efficiency without compromising air quality detection accuracy. This project was made possible, thanks to our sponsor DigiKey, from whom we have purchased all the components used in this project. You can also check out the BOM, Circuit, Gerber, and Firmware Files for this projects.\n\nSTM32U083KCUx: An ultra-low-power microcontroller based on the high-performance Arm® Cortex®-M0+ 32-bit RISC core, operating at a frequency of up to 56 MHz. You can also check out our other STM32 Projects.\n\nSTM32U083KCUx: An ultra-low-power microcontroller based on the high-performance Arm® Cortex®-M0+ 32-bit RISC core, operating at a frequency of up to 56 MHz. You can also check out our other STM32 Projects.\n\nSGP40: A digital indoor air quality sensor for VOC measurements, offering long-term stability, a long lifetime, and very low power consumption.\n\nSGP40: A digital indoor air quality sensor for VOC measurements, offering long-term stability, a long lifetime, and very low power consumption.\n\nADPL44002: A CMOS low dropout (LDO) linear regulator that operates from 2.7V to 40V and provides up to 200mA of output current.\n\nADPL44002: A CMOS low dropout (LDO) linear regulator that operates from 2.7V to 40V and provides up to 200mA of output current.\n\nMCP73831/2: A highly advanced linear charge management controller for use in space-limited, cost-sensitive applications.\n\nMCP73831/2: A highly advanced linear charge management controller for use in space-limited, cost-sensitive applications.\n\nEAST1616RGBA1: A common cathode RGB LED used for indication purposes.\n\nEAST1616RGBA1: A common cathode RGB LED used for indication purposes.\n\nSS8550: A general-purpose PNP transistor for switching the buzzer.\n\nSS8550: A general-purpose PNP transistor for switching the buzzer.\n\nPKMCS0909E4000-R1: A piezoelectric SMD sounder.\n\nPKMCS0909E4000-R1: A piezoelectric SMD sounder.\n\nOther passive components\n\nOther passive components\n\nConnectors\n\nConnectors\n\nCustom PCB\n\nCustom PCB\n\n3D printed parts\n\n3D printed parts\n\nOther tools and consumables\n\nOther tools and consumables\n\n# Wearable Air Quality Pendant Circuit Diagram\n\nThe complete circuit diagram for the Wearable Air Quality Pendant is shown below. It can also be downloaded in PDF format from the GitHub repo linked at the end.\n\nThe schematic is fully customizable. You can tweak any part of the design to suit your specific needs. For instance, we made a few adjustments, such as changing the resistor value in the buzzer driver circuit and modifying the charging current programming resistor in the battery section. Depending on your requirements—such as buzzer loudness or battery capacity—you’re free to modify these values as needed.\n\n# Power Management Circuit\n\nFirst, let's discuss about power management Section. The power management section centers around the J1 USB connector, which provides 5V power input for both charging and operation. The MCP73832T (IC1) serves as a single-cell Li-Po battery charge controller, implementing a constant current/constant voltage charging algorithm with the PROG pin setting the charging current through an external resistor, while a status LED provides visual indication of the charging state. The ADPL6400ZAU12 (IC2) functions as a low-dropout voltage regulator that converts the variable battery voltage of approximately 3.7V to a stable +2.5V supply for the entire system, which is essential for consistent sensor operation and microcontroller stability.\n\n# SGP40 Air Quality Sensor Interface\n\nNext comes the The SGP40,Air Quality sensor responsible for measuring Total Volatile Organic Compounds in the surrounding air. This professional-grade sensor communicates with the microcontroller through I2C protocol using dedicated SCL (PA7) and SDA (PA6) lines. The sensor operates on the regulated +2.5V supply to ensure accurate and consistent measurements. Pull-up resistors R5 and R6, both valued at 4.7kΩ, are connected to the I2C lines to ensure proper signal levels and reliable communication between the sensor and microcontroller.\n\nThis digital I2C output eliminates the need for analog-to-digital conversion, reducing potential errors and simplifying the interface design. The sensor's low power consumption characteristics make it well-suited for battery-powered applications while maintaining the precision required for professional air quality monitoring.\n\n# STM32 Microcontroller Programming Interface\n\nAbove you can see The STM32L052UCx microcontroller, that serves as the main processing unit, handling sensor communication, data processing, and output control throughout the system. This particular microcontroller from the STM32L series is specifically chosen for its low power design characteristics, making it ideal for battery-powered applications while providing sufficient processing capability for air quality monitoring tasks.\n\nThe programming interface includes both UART (J3) for serial programming and debugging, as well as SWD interface pins (SWDIO and SWCLK) (J2) for in-circuit programming and development.\n\n# LED and Buzzer Feedback System\n\nAt last come the Visual and Audio Feed back system that is responsible for the Alerting the User based on the Air Quality.\n\nThe audio component centers around the SS8550 PNP transistor (Q1) which serves as a driver for the passive buzzer (BZ1). This configuration allows the microcontroller to generate RTTTL tones that correspond to different air quality levels, providing musical audio feedback that matches the urgency of each situation.\n\nThe visual feedback system employs four identical RGB LED driver circuits (D2-D5), each containing a complete LED_RGBK package with Red, Green, Blue, and Cathode connections. This arrangement enables precise color control and mixing to create the desired visual indicators. The system implements a sophisticated color coding scheme where green indicates good air quality (TVOC 0-200), yellow represents warning levels (TVOC 201-300), and red signals alarm conditions (TVOC 301-500).\n\nWith this, the Schematic part gets covered. Next comes the PCB Part.\n\n# PCB Design for Wearable Air Quality Pendant\n\nFor this project, we decided to create a custom PCB. This ensures that the final product is as compact as possible and easy to assemble and use.\n\nWe have previously built a lot of PCB projects, and if you are new to PCBs you can check out the basics of PCB tutorial on our website. The PCB here was designed using KiCad, and all the design files are available for download from the GitHub repository linked below this article. The PCB has a diameter of approximately 32.50 mm.\n\nOnce the PCB design was complete and fully verified, we sent the respective Gerber files to a PCB fabrication service for manufacturing.\n\n# PCB Assembly and Soldering Guide\n\nThe first step in assembling the PCB was to sort all the required components as listed in the BOM (Bill of Materials). After sorting, we placed the components on the PCB and soldered them one by one.\n\nTo simplify this process, you can use an SMD stencil to apply solder paste and then place the components before reflowing the PCB using either an SMD rework station or a reflow oven. However, you are not limited to these methods—manual soldering works just as well for small batches.\n\nAbove is the image of a fully assembled Wearable Air Quality Pendant PCB.\n\n# 3D-Printed Enclosure Design\n\nWe also designed a 3D-printed enclosure to house the PCB, complete with a hook to allow the device to be worn as a pendant. The STL files for this enclosure are available in the GitHub link below.\n\nThe enclosure requires minimal supports. If needed, you can use a brim to improve bed adhesion and reduce warping. You can learn more about 3D printing and how to get started by following the provided link.\n\n# Complete Assembly Instructions\n\nWith your custom PCB populated and 3D-printed enclosure ready, assembling this wearable air quality monitoring device is straightforward. The compact design ensures your personal TVOC detector fits comfortably as an everyday pendant while providing continuous air quality protection.\n\nAssembly is simple, as the number of components is minimal. After inserting the battery into the battery holder, place the PCB into the top enclosure, aligning it with the USB Type-C cutout. Then, use the bottom cover to snap the enclosure closed, ensuring a secure fit.\n\nAs shown above, these steps complete the physical assembly. Next, let's move on to the programming phase.\n\n# Arduino Code for Air Quality Monitoring\n\nProgramming this STM32-based air quality monitor differs from standard Arduino boards, requiring an ST-Link programmer for firmware upload. The Arduino IDE code for this wearable TVOC sensor combines real-time air quality monitoring with intelligent alert systems, making it perfect for continuous environmental sensing applications. For more Arduino programming examples, explore our Arduino Project Collection.\n\n# Library Setup and Pin Configuration\n\n```arduino\n#include <DFRobot_SGP40.h> \n#include <HardwareSerial.h>\n#include <Arduino.h>\n#include <PlayRtttl.hpp> \n#include <ptScheduler.h>\n```\n\n```arduino\n#include <DFRobot_SGP40.h> \n#include <HardwareSerial.h>\n#include <Arduino.h>\n#include <PlayRtttl.hpp> \n#include <ptScheduler.h>\n```\n\nThe code begins by including essential libraries for the air quality monitoring system. The DFRobot_SGP40 library provides a communication interface with the SGP40 TVOC sensor, while HardwareSerial enables UART communication for data logging. The PlayRtttl library handles musical tone generation from text-based RTTTL strings, and ptScheduler implements non-blocking task scheduling to manage multiple concurrent operations without freezing the system. All these libraries are available in the the Arduino Built in library manager.\n\n```arduino\n#define RED_PIN PB3\n#define GREEN_PIN PB4\n#define BUZZER_PIN PB0\nHardwareSerial MyLPUART1(PA3, PA2);\n```\n\n```arduino\n#define RED_PIN PB3\n#define GREEN_PIN PB4\n#define BUZZER_PIN PB0\nHardwareSerial MyLPUART1(PA3, PA2);\n```\n\nPin definitions establish the hardware connections with RED_PIN and GREEN_PIN controlling the visual indicators on PB3 and PB4 respectively, while BUZZER_PIN on PB0 drives the audio alerts. A custom LPUART serial interface is configured using PA3 for receive and PA2 for transmit, enabling communication with external devices or computers for data monitoring and debugging purposes.\n\n```arduino\nint tvoc = 0;\nint toneRequest = -1;\nint fadeStep = 0;\nunsigned long prevLedTime = 0;\nunsigned long prevToneTime = 0;\n```\n\n```arduino\nint tvoc = 0;\nint toneRequest = -1;\nint fadeStep = 0;\nunsigned long prevLedTime = 0;\nunsigned long prevToneTime = 0;\n```\n\nThe global variables manage the system state and timing operations. The tvoc variable stores the current Total Volatile Organic Compounds reading from the sensor, while toneRequest acts as a flag indicating which audio-visual alert should be activated. The fadeStep variable tracks the LED fading animation progress, and timing variables prevLedTime and prevToneTime implement non-blocking delays for periodic operations.\n\n```arduino\nconst char softTone[] = \"Soft:d=8,o=5,b=100:g\";\nconst char warnTone[] = \"Warn:d=4,o=5,b=120:c,e,g\";\nconst char alarmTone[] = \"Alarm:d=16,o=5,b=180:c6,c6,c6\";\nconst char startTone[] = \"Start:d=8,o=6,b=120:c,e,g\";\nconst char errorTone[] = \"Error:d=4,o=5,b=160:c,c,r,c\";\nenum ToneType {\n TONE_SOFT = 5000,\n TONE_WARN = 2000,\n TONE_ALARM = 500,\n TONE_START = 1000,\n TONE_ERROR = 200\n};\n```\n\n```arduino\nconst char softTone[] = \"Soft:d=8,o=5,b=100:g\";\nconst char warnTone[] = \"Warn:d=4,o=5,b=120:c,e,g\";\nconst char alarmTone[] = \"Alarm:d=16,o=5,b=180:c6,c6,c6\";\nconst char startTone[] = \"Start:d=8,o=6,b=120:c,e,g\";\nconst char errorTone[] = \"Error:d=4,o=5,b=160:c,c,r,c\";\nenum ToneType {\n TONE_SOFT = 5000,\n TONE_WARN = 2000,\n TONE_ALARM = 500,\n TONE_START = 1000,\n TONE_ERROR = 200\n};\n```\n\nFive RTTTL tone strings define the musical sequences for different system states. The softTone provides a gentle single G note for good air quality, warnTone plays an ascending C-E-G progression for warning conditions, and alarmTone generates rapid triple beeps for urgent situations. Additional tones include startTone for system initialization and errorTone for fault conditions. The ToneType enumeration cleverly associates each tone with its playback interval in milliseconds, creating a unified timing system where TONE_SOFT repeats every 5 seconds, TONE_WARN every 2 seconds, TONE_ALARM every 500 milliseconds, and TONE_ERROR every 200 milliseconds for maximum urgency.\n\n```arduino\nptScheduler readSensorTask(PT_TIME_1S);   // Sensor reading every 1 second\nptScheduler lightTask(PT_TIME_100MS);     // LED update task\nptScheduler soundTask(PT_TIME_100MS);     // Buzzer task\n```\n\n```arduino\nptScheduler readSensorTask(PT_TIME_1S);   // Sensor reading every 1 second\nptScheduler lightTask(PT_TIME_100MS);     // LED update task\nptScheduler soundTask(PT_TIME_100MS);     // Buzzer task\n```\n\nThree ptScheduler objects manage the timing of different system tasks without blocking program execution. The readSensorTask triggers sensor readings every second, lightTask updates LED effects every 100 milliseconds for smooth fading, and soundTask handles audio playback timing at 100-millisecond intervals.\n\nThe setup function initializes all system components and establishes communication interfaces. Serial communication begins at 115200 baud rate through the custom LPUART interface, providing high-speed data transfer for real-time monitoring. All output pins are configured using pinMode to enable proper control of the LEDs and buzzer, ensuring the hardware responds correctly to software commands.\n\n```arduino\nvoid setup() {\n MyLPUART1.begin(115200);\n pinMode(RED_PIN, OUTPUT);\n pinMode(GREEN_PIN, OUTPUT);\n pinMode(BUZZER_PIN, OUTPUT);\n MyLPUART1.println(\"sgp40 is starting, the reading can be taken after 10 seconds...\");\n updateLedFade(TONE_START);\n playTone(TONE_START);\n if (!mySgp40.begin(10000)) {\n   MyLPUART1.println(\"Failed to init chip. Please check connection.\");\n   showErrorState();\n   while (true);\n }\n MyLPUART1.println(\"sgp40 initialized successfully!\");\n}\n```\n\n```arduino\nvoid setup() {\n MyLPUART1.begin(115200);\n pinMode(RED_PIN, OUTPUT);\n pinMode(GREEN_PIN, OUTPUT);\n pinMode(BUZZER_PIN, OUTPUT);\n MyLPUART1.println(\"sgp40 is starting, the reading can be taken after 10 seconds...\");\n updateLedFade(TONE_START);\n playTone(TONE_START);\n if (!mySgp40.begin(10000)) {\n   MyLPUART1.println(\"Failed to init chip. Please check connection.\");\n   showErrorState();\n   while (true);\n }\n MyLPUART1.println(\"sgp40 initialized successfully!\");\n}\n```\n\nA startup message informs users that the SGP40 sensor requires a 10-second warm-up period before providing accurate readings, which is typical for gas sensors that need time to stabilize their internal chemistry. The system immediately provides visual and audio feedback through updateLedFade and playTone functions, giving users confidence that the device is operational and initializing properly.\n\nThe SGP40 sensor initialization uses the begin function with a 10-second timeout parameter, allowing sufficient time for the sensor to establish communication and complete its internal calibration. If initialization fails, the system immediately enters an error state with continuous error tones and LED flashing, then halts execution to prevent unreliable operation. Success results in a confirmation message, and the system proceeds to normal monitoring operation.\n\n# TVOC Sensor Reading and Alert System\n\nThe main loop implements a sophisticated non-blocking architecture using the ptScheduler system to manage multiple concurrent tasks without interfering with each other. The readSensorTask scheduler triggers the readAndEvaluateAir function every second, ensuring consistent air quality monitoring while allowing other operations to continue smoothly between readings.\n\n```arduino\nvoid loop() {\n if (readSensorTask.call()) {\n   readAndEvaluateAir();\n }\n if (lightTask.call() && toneRequest != -1) {\n   updateLedFade((ToneType)toneRequest);\n }\n if (soundTask.call() && toneRequest != -1 && toneRequest != TONE_SOFT) {\n   playTone((ToneType)toneRequest);\n }\n}\n```\n\n```arduino\nvoid loop() {\n if (readSensorTask.call()) {\n   readAndEvaluateAir();\n }\n if (lightTask.call() && toneRequest != -1) {\n   updateLedFade((ToneType)toneRequest);\n }\n if (soundTask.call() && toneRequest != -1 && toneRequest != TONE_SOFT) {\n   playTone((ToneType)toneRequest);\n }\n}\n```\n\nThe readAndEvaluateAir function retrieves the current TVOC index from the SGP40 sensor and immediately logs this value via serial communication for external monitoring or data analysis. The function then evaluates the reading against predefined thresholds to classify air quality into four categories. TVOC values from 0 to 200 indicate good air quality and trigger the soft tone with green LED indication. Values between 201 and 300 represent warning conditions with yellow LED display created by combining red and green LEDs. Readings from 301 to 500 activate alarm mode with red LEDs and urgent audio alerts. Any reading above 500 or sensor communication failure triggers the error state with rapid flashing and beeping.\n\nVisual feedback is managed through the updateLedFade function, which implements a sophisticated PWM-based fading algorithm that creates smooth color transitions rather than harsh on-off switching. The function calculates target brightness levels for red and green LEDs based on the current air quality state, then gradually fades the LEDs in and out using nested loops with precise timing control. This creates an aesthetically pleasing and attention-getting display that clearly communicates air quality status without being jarring or distracting.\n\nAudio alerts are handled by the playTone function, which uses timing control to ensure tones play at appropriate intervals without blocking other operations. The function employs the PlayRtttl library to convert text-based musical notation into PWM signals that drive the buzzer, creating distinct musical patterns that users can easily associate with different air quality levels. The system intelligently skips soft tones during good air quality conditions to avoid unnecessary noise while maintaining alertness for warning and alarm situations.\n\nThe error handling system provides robust fault detection and user notification through the showErrorState function, which immediately activates visual and audio error indicators when sensor communication fails or readings exceed normal ranges. This ensures users are promptly notified of system malfunctions or extremely dangerous air quality conditions that require immediate attention.\n\n# Download Complete Project Files\n\nThe GitHub repository includes the complete Arduino code for the Wearable Air Quality Pendant\n\n# Related Air Quality Monitoring Projects\n\nPreviously we have build many interesting projects on air quality Monitoring System. If you want to know more about those topics, links are given below.\n\nArduino Air Quality Monitoring System\n\nBuild an Arduino-based air quality monitoring system using the MQ135 sensor to detect harmful gases like CO₂, NH₃, and benzene. Learn circuit design, interfacing, and code to monitor pollution levels and ensure a healthier environment.\n\nTVOC and CO2 Measurement using Arduino and CCS811 Air Quality Sensor\n\nLearn how to measure TVOC and CO₂ levels using Arduino and the CCS811 air quality sensor. This project guides you through interfacing, circuit setup, and coding to monitor indoor air quality effectively for health and safety.\n\nIoT Based Air Quality Index Monitoring System – Monitor PM2.5, PM10, and CO using ESP32\n\nBuild an IoT-based Air Quality Index Monitoring System using ESP32 to measure PM2.5, PM10, and CO levels. This project helps you track pollution in real time with sensor integration and Wi-Fi connectivity for smart environmental monitoring.\n\nInterfacing Sharp GP2Y1014AU0F Sensor with Arduino to build Air Quality Analyser\n\nLearn how to interface the Sharp GP2Y1014AU0F dust sensor with Arduino to build a simple air quality analyzer. This project detects dust particles and provides real-time air pollution data, making it ideal for environmental monitoring applications.\n\nIoT based Air Pollution Monitoring System using Arduino\n\nBuild an IoT-based air pollution monitoring system using Arduino. This project uses sensors to detect harmful gases and sends real-time air quality data to the cloud for remote monitoring and analysis. Ideal for smart city and environmental applications.\n\n# Start a Discussion on:\n\n# Add New Comment\n\nLog in or register to post comments"}
{"title":"Arduino Location Tracker using SIM800L GSM Module and NEO-6M GPS Module","content":"Ever wanted to track your bike, car, or even monitor your loved one's location in real-time? Building your own Arduino GPS tracker gives you complete control over your tracking data without expensive monthly subscriptions. This comprehensive project shows you how to create a fully functional GPS tracking system using Arduino UNO R3, SIM800L GSM module, and NEO-6M GPS module, a perfect low-cost DIY combination for vehicle monitoring, asset protection, or personal safety applications. Explore our other GPS tracker builds, like an GPS tracker using ESP32 and a Raspberry Pi Pico GPS tracker. We've built many other projects using an Arduino that we think you'll enjoy.\n\nCommercial GPS trackers can cost $20-50 monthly in subscription fees, but our Arduino-based GPS tracker only requires a basic SIM card data plan. This article provides you complete step-by-step guide on how to build a practical GPS tracking device using Arduino to send real-time location data to the cloud, including web dashboard access and historical tracking. Yes, we wanted this project to be low-cost, simple to build, and yet practical so that you can use it in real life. Which is why we did not stop with just providing the Circuit Diagram and Code, but built a complete GPS Tracking platform called Geolinker, which is completely free to use. Basically, the Arduino hardware reads the GPS location data from satellite using the NEO-6M GPS module and sends it to the GeoLinker GPS visualizer via an API using the SIM800L Module as shown in the infographic GIF below. We have also built the GeoLinker Lite Arduino Library that allows you to easily communicate with the GeoLinker web App from Arduino, we will discuss more on this later in this article.\n\nExplore our other GPS tracker builds, like an GPS tracker using ESP32 and a Raspberry Pi Pico GPS tracker. We've built many other projects using an Arduino that we think you'll enjoy.\n\nIn fact, we have tested this Arduino-based GPS tracker project extensively at CircuitDigest around our office, and you can see a small snippet of the result in the first image. Notice how the GPS location is updated as the actual hardware (shown inside purple box) is moving around outside.\n\nThis way, you can not only track the location history of your Arduino-based GPS Tracker but can also use the GeoLinker web app to save the results, share them with someone, calculate the speed and distance, etc.  Sounds interesting, right?! So let's get right into it and start building....\n\n# Components Required\n\nBuilding this Arduino GPS tracker requires readily available components with an estimated total cost of $25-35. All components can be sourced from electronics suppliers like Amazon, AliExpress, or local electronics stores. Here's everything you need for this GPS tracking system using Arduino:\n\nAdditional Requirements: You'll also need a 2G-compatible SIM card with data plan ($5-10/month) and a power bank for portable operation. For permanent installations, consider using a 12V to 5V converter for the vehicle power supply. Also, if you are using from India, you will need an Airtel or Vodafone, or BSNL sim card with an active data plan. Please note we are using a 2G GSM module like SIM800L, so JIO and other 4G or 5G only networks will not work. We are also building a 4G GPS tracker, stay tuned if you need more information on that.\n\n# Why Build Your Own Arduino GPS Tracker?\n\n⇒ Zero Monthly Subscription Fees - Unlike commercial trackers charging $20-50/month, our Arduino GPS tracker only needs a basic SIM card data plan (typically $5-10/month)\n\n⇒ Real-time Location Monitoring - Track your vehicle, bike, or assets anywhere with continuous GPS updates showing exact latitude, longitude, and timestamps\n\n⇒ Professional Web Dashboard - Access your tracker's location from any device through our user-friendly GeoLinker Cloud interface - no app downloads required\n\n⇒ Complete Hardware Control - Modify tracking intervals, add sensors, or integrate with your own systems using our open-source approach\n\n⇒ Comprehensive Data Analysis - Download location history in CSV format to analyze travel patterns, time spent at locations, or create detailed reports\n\n⇒ Memory Optimized for Arduino UNO - Built specifically for Arduino UNO R3's 2KB RAM limitation using our lightweight GeoLinker Lite library\n\n⇒ Global GSM Network Support - Works on any 2G network worldwide, ensuring your GPS tracker using Arduino stays connected even in remote areas\n\n⇒ Scalable Multi-device Platform - Track multiple vehicles or assets from a single GeoLinker Cloud account with enterprise-grade reliability\n\n# Arduino GPS Tracker Circuit Diagram\n\nThe Arduino GPS tracker circuit connects three main components: Arduino UNO R3, NEO-6M GPS module, and SIM800L GSM module. This design uses both hardware and software serial communication since Arduino UNO has only one hardware serial port. Follow the diagram below for proper connections.\n\n# Neo-6M GPS Module Connections\n\nThe NEO-6M GPS module requires only three connections to the Arduino. This module continuously sends location data that the Arduino reads and processes for our GPS tracking system. If you are completely new to Neo-6M GPS module, I will definitely recommend that you check out our NEO-6M Arduino Tutorial to understand the basics of how this GPS module works.\n\n# SIM800L GSM Module Connections (Requires Level Shifting)\n\nThe SIM800L module needs special attention because it operates at 3.3V logic levels while Arduino uses 5V. We need a voltage divider circuit to protect the SIM800L from damage. If you are new to the SIM800L GSM module, check out our Arduino SIM800L tutorial to understand the basics of this module and how to use it with Arduino.\n\nImportant: Power the SIM800L through a diode from Arduino's 5V pin when using a power bank for adequate current supply.\n\n# Critical Connection Notes\n\nPower Requirements: Never power this Arduino GPS tracker from a computer USB port alone. The SIM800L requires up to 2A during transmission, which standard USB ports cannot provide. Always use a power bank or external 5V power supply.\n\nReset Pin Connection: Connect Arduino Pin 2 to the RST (reset) pin. This enables automatic switching between GPS and GSM modes to prevent memory corruption issues common with Arduino UNO's limited 2KB RAM.\n\nProgramming Tip: Always disconnect the GPS module's TX wire from Arduino Pin 0 before uploading code. The continuous GPS data interferes with programming. Reconnect after successful upload.\n\nAs mentioned earlier, Pin 2 connects to the Arduino's RST (reset) pin. This is used to switch between the GPS and GSM modes. If you wonder why we have to do this, this is because of the limited RAM available in the ATMEGA328. Without this, we have faced memory corruption when we used both GPS and GSM routines in the same sketch, caused by the huge string elements used in NMEA parsing and GSM HTTP post request payload. To prevent these kinds of issues, we have implemented two modes, in which the MCU will only need to handle the global and local variables that are specific to that mode, which prevents any memory corruption.\n\nWhile testing the circuit, I noticed that some clone Arduino boards have issues with the software serial. In some instances, even simple serial pass-through examples didn’t work. We never had any issue with a genuine Arduino Uno board. I assume this is because the Atmega328 used in these boards is also non-genuine. So keep this in mind, and if you face such issues, try to use a genuine Arduino board.  Here is the final setup of our hardware.\n\n# Arduino GPS Tracker Code Explanation\n\nWith the hardware connections complete, the next step involves implementing code for your GPS tracker. The GeoLinker Lite library simplifies the coding process by handling GPS communication, GSM connectivity, and cloud integration through straightforward function calls.\n\n# GeoLinker Lite Arduino Library\n\nAs mentioned earlier, we'll be using our GeoLinker Cloud platform for data storage and the specially designed GeoLinker Lite library optimized for Arduino UNO's limited 2KB RAM. We previously released the GeoLinker library for development boards with higher RAM capacity, such as the ESP32, ESP8266, Arduino UNO R4, Raspberry Pi Pico W, and Pico 2W. These boards can handle the full GeoLinker library without issues. Our ESP32 GPS tracker project shows how this library works and how to use it with ease.\n\nBut when it comes to the classic boards like Arduino UNO R3 and Nano, they have limited RAM of only 2Kb, which prevents them from using the standard GeoLinker library. These classic boards remain popular for many projects, but their memory constraints require a different approach. To address this limitation, we have released GeoLinker Lite, a simplified version designed specifically for boards with limited memory.\n\nGeoLinker Lite includes the core functions needed for GPS tracking whilst working within the memory limits of boards like Arduino UNO R3 and Nano. This library allows users of classic Arduino boards to connect to our cloud platform for location tracking and remote monitoring.\n\nBegin by installing the GeoLinker Lite library through the Arduino IDE library manager. Open the Arduino IDE, navigate to Tools > Manage Libraries, then search for \"GeoLinker Lite\" in the Library Manager. Click Install to add the library to your Arduino environment.\n\nThis library is specifically optimised for Arduino UNO R3 and Nano boards with limited RAM capacity.\n\n```arduino\n#include <GeoLinkerLite.h>\nGeoLinkerLite geoLinker(Serial, Serial);\n```\n\n```arduino\n#include <GeoLinkerLite.h>\nGeoLinkerLite geoLinker(Serial, Serial);\n```\n\nThe code starts by including the GeoLinker Lite header file with #include <GeoLinkerLite.h>. Next, create a GeoLinkerLite instance using GeoLinkerLite geoLinker(Serial, Serial). This constructor takes two parameters: the first Serial, which refers to GPS communication, and the second Serial handles debug output. Both use the same Serial port since the Arduino Uno has only one hardware serial. Using multiple software serials can cause issues, and the GPS module only sends data to the Arduino, whilst debug information goes to the serial monitor.\n\n```arduino\nvoid setup() {\n  Serial.begin(9600);\n  delay(1000);\n  geoLinker.setResetPin(2);                    // Reset control pin\n  geoLinker.setGSMPins(8, 9);                  // GSM RX, TX pins\n```\n\n```arduino\nvoid setup() {\n  Serial.begin(9600);\n  delay(1000);\n  geoLinker.setResetPin(2);                    // Reset control pin\n  geoLinker.setGSMPins(8, 9);                  // GSM RX, TX pins\n```\n\nThe setup function initialises serial communication at 9600 baud rate. A 1000ms delay allows the system to stabilise before configuration begins. The geoLinker.setResetPin(2) function configures digital Pin 2 as the reset control pin, enabling automatic system restart when needed. This is necessary to switch between modes since there is no software-based reboot control for Arduino. The geoLinker.setGSMPins() function assigns RX and b for communication with the SIM800L module.\n\n```arduino\ngeoLinker.setModemAPN(\"your.apn.here\");      // Your carrier's APN\n  geoLinker.setAPIKey(\"your_api_key\");         // Your GeoLinker API key\n  geoLinker.setDeviceID(\"arduino_tracker\");    // Unique device ID / Device name\n```\n\n```arduino\ngeoLinker.setModemAPN(\"your.apn.here\");      // Your carrier's APN\n  geoLinker.setAPIKey(\"your_api_key\");         // Your GeoLinker API key\n  geoLinker.setDeviceID(\"arduino_tracker\");    // Unique device ID / Device name\n```\n\nAfter that, you can find the network and cloud configuration parameters. The geoLinker.setModemAPN() function is used to set your mobile carrier's Access Point Name, which is essential for GPRS connectivity. Replace this with your specific carrier's APN settings. The geoLinker.setDeviceID() function assigns a unique identifier to your tracker for identification on the cloud platform. By configuring the device ID, you can not only easily identify your tracker, but also use multiple such trackers in a single Circuit Digest Cloud account.\n\nThe geoLinker.setAPIKey() function is used to configure the API key that is necessary to connect your device to the GeoLinker Cloud platform. You can obtain your unique API key from your CircuitDigest Cloud account. Just visit CircuitDigest Cloud and log in or register if you are a new user.\n\nThen create your free API key by following the instructions in the image below. Note that GeoLinker is an initiative by circuitdigest to make GPS tracking projects more accessible to our makers community, students, and engineers which is why we have made it free to use for all users. However do that note that each user can store a maximum of 10,0000 data points only; which is more than enough for a hobby project or a pilot engineering project.\n\nMore details on how to use GeoLinker can be found in our previous tutorial, Free IoT-based GPS Tracking Map for ESP32, NodeMCU, and Arduino.\n\n```arduino\ngeoLinker.setMaxRetries(3);                  // Max retry attempts to send a data points\n  geoLinker.setDebugLevel(1);                  // Debug level\n  geoLinker.setTimeOffset(5, 30);              // Timezone: Eg. india +5:30 hours\n```\n\n```arduino\ngeoLinker.setMaxRetries(3);                  // Max retry attempts to send a data points\n  geoLinker.setDebugLevel(1);                  // Debug level\n  geoLinker.setTimeOffset(5, 30);              // Timezone: Eg. india +5:30 hours\n```\n\nThe geoLinker.setMaxRetries() function determines how many times the system attempts to send data via GPRS before giving up. This helps handle temporary network issues without infinite retry loops. The geoLinker.setDebugLevel() function controls the amount of diagnostic information sent to the serial monitor. With 0, no debugging data will be printed. With 1 minimal debugging information and 2 detailed debugging information will be printed on the serial monitor. The geoLinker.setTimeOffset(5, 30) function configures timezone settings, with the example showing India's UTC+5:30 offset. This is used for time offset correction since the time stamp from the GPS data will be UTC.\n\n```arduino\ngeoLinker.begin();\n  delay(1000);                              // Increase this delay to increase update interval\n  geoLinker.run();\n```\n\n```arduino\ngeoLinker.begin();\n  delay(1000);                              // Increase this delay to increase update interval\n  geoLinker.run();\n```\n\nThe geoLinker.begin() function initialises all components, establishes GPS communication, connects to the GSM network, and prepares the system for operation. After a 1000ms delay, the geoLinker.run() function starts the main tracking loop. This function handles GPS data collection, processes location information, and transmits data to the GeoLinker Cloud platform. Increasing the delay before geoLinker.run() extends the interval between location updates. By default, the delay between the location updates is 20 seconds.\n\nThe loop function remains empty with only a delay statement because of the geoLinker.run() function manages the entire tracking process internally. The system operates continuously within the run function, collecting GPS data, managing GSM communication, and handling automatic resets when necessary.\n\n# Download Code from GitHub Repository\n\nHere is the link to our GitHub repository, where you'll find the source code, schematics, and all other necessary files to build your own GPS Tracker using Arduino Uno, SIM800L, and Neo-6 M GPS module.\n\n# Testing Arduino GPS Tracker in the Real World\n\nAfter uploading the code, take your Arduino GPS tracker outdoors for testing. GPS modules require clear sky view and typically need 2-5 minutes for initial satellite lock. Open Serial Monitor at 9600 baud to watch the boot sequence, you should see GPS signal acquisition, network registration, and successful data uploads to GeoLinker Cloud as show in the image below. You can see the serial monitor of Arduino on the left and the Geolinker map on the right, the hardware is connected to laptop and moved around on streets during this testing.\n\nNext, we decided to test by moving to different locations and see how the values get updated on the geolinker map. The default tracking interval in our code is 20 seconds, and location accuracy should be within 3-5 meters. We powered the hardware with a power bank placed in on the car dashboard and started driving to test if DIY GPS tracker is working the way it is supposed to. As you can see in the image below, as we drive around, the location gets updated on the app. You can even see the waypoints are plotted very close at places where there is traffic.\n\nIn conclusion, this simple Arduino Location tracker works much better than we expected it to be and is very practical to be used for a vehicle tracking, pet tracking, or asset tracking applications. We build everything on a breadboard to keep it beginner-friendly friendly but you can take it ahead and build a PCB with a neat enclosure. Also, having the location data sent to GeoLinker opens to many more possibilities. You can not only visualize your data with Geolinker, but you can also share it, filter it,  download it as a table, calculate speed, distance, and much more. You can fiddle around with the options there to explore more. You can track multiple devices with just a single API key, but the maximum number of waypoints is limited to 10,000, which is more than enough for personal use or for testing small prototypes. After 10,000 waypoints, your oldest data will be overwritten. You can also delete these waypoints if you want to make space for new devices.\n\n# Arduino GPS Tracker Troubleshooting Guide\n\nBuilding an Arduino GPS tracker can present various challenges. This comprehensive troubleshooting guide covers the most common issues and their solutions, organized by category for quick problem resolution.\n\n# Programming and Upload Issues\n\nQ1: Cannot upload code to Arduino - \"programmer not responding\" error?\n\nSolution: The GPS module continuously sends data to Pin 0 (RX), blocking code uploads. Disconnect the GPS TX wire from Arduino Pin 0 before programming. After successful upload, reconnect the wire. Always follow this sequence: Disconnect → Upload → Reconnect.\n\nQ2: Code compiles but Arduino resets continuously?\n\nSolution: This indicates insufficient power supply. The SIM800L requires up to 2A during transmission. Use a quality power bank (minimum 2A output) instead of computer USB power. Weak power causes brownout resets during GSM operations.\n\n# GPS Module Issues\n\nQ3: GPS shows \"no data\" or \"waiting for GPS signal\" continuously?\n\nThe NEO-6M GPS modules might be a tricky to get it working sometimes, always test it outdoors with a proper power supply and antenna. If you are facing problem, you can read our NEO-6m Troubleshooting guide  in which we have discussed every possible problems and its solutions\n\nQ4: GPS works initially but stops after some time?\n\nSolution: This often indicates power supply instability. The GPS module needs consistent 3.3V-5V power. Check all power connections are secure and use a stable power source. Loose connections cause intermittent GPS failures.\n\n# GSM/Cellular Connection Problems\n\nQ5: SIM800L doesn't respond or shows network registration failed?\n\n1. Verify SIM card works in a phone first \n2. Check SIM card supports 2G networks (Jio doesn't work - 4G only) \n3. Ensure proper voltage divider circuit (4.7kΩ + 10kΩ resistors) \n4. Test with known working carriers: Airtel, Vi, BSNL \n5. Verify antenna connection to SIM800L\n\nQ6: Getting HTTP 401 errors when sending data to cloud?\n\nSolution: HTTP 401 indicates authentication failure. Replace the placeholder API key with your actual GeoLinker Cloud API key. Get your free API key from Circuit Digest Cloud account. Verify the API key is correctly pasted without extra spaces.\n\n# Hardware and Connection Issues\n\nQ7: Software serial not working with clone Arduino boards?\n\nSolution: Many clone Arduino boards use non-genuine ATMEGA328P chips with software serial issues. Test with a simple serial passthrough example first. If problems persist, use a genuine Arduino UNO R3 board. To build this GPS tracker Arduino project, you need reliable serial communication so get a high quality Arduino UNO board with DIP IC and not SMD IC.\n\nQ8: SIM800L gets hot or stops working after some time?\n\nSolution: Overheating indicates power supply issues. The SIM800L needs 3.7V-4.2V with high current capability. Use the diode voltage drop method from Arduino 5V pin when powered by power bank. Never exceed 4.2V or the module may be damaged permanently.\n\n# Performance Optimization\n\nQ9: How to reduce battery consumption for portable tracking?\n\n1. Increase delay before geoLinker.run() for less frequent updates \n2. Use sleep modes between GPS readings (advanced modification) \n3. Reduce debug level to 0 for production use \n4. Consider solar charging for permanent outdoor installations \n5. Use efficient power bank with low self-discharge\n\nQ10: Can I track multiple vehicles with one account?\n\nYes! Set unique device IDs for each Arduino GPS tracker using geoLinker.setDeviceID(\"tracker_1\"), geoLinker.setDeviceID(\"tracker_2\"), etc. All trackers can use the same API key and will appear separately on your GeoLinker Cloud dashboard.\n\nBuilding your own Arduino GPS tracker provides complete control over your tracking data while eliminating expensive monthly subscription fees. This project demonstrates that with basic components costing $15-20, you can create a professional-grade tracking system rivaling commercial alternatives that charge $20-50 monthly.\n\nThe GeoLinker Lite library makes this GPS tracking project using Arduino accessible to beginners while providing the flexibility for advanced customizations. Whether you're tracking vehicles, assets, or personal items, this open-source approach offers unlimited scalability and modification possibilities. If you have any questions about this project, please leave them in the comment section at the bottom of this page, and we will get back to you. Would love to hear your thoughts and suggestions.\n\n# Other Projects on GPS Location Tracking\n\nPreviously, we have build many interesting Arduino projects and few with GPS location tracking. If you want to know more about those projects, links are given below.\n\nDIY Location Tracker using GSM SIM800 and Arduino\n\nBuild a DIY GPS location tracker using Arduino UNO, SIM800 GSM module, and GPS sensor. Learn how to send real-time location via SMS using latitude and longitude coordinates.\n\nIoT Based GPS Location Tracker using NodeMCU and GPS Module – Save GPS co-ordinates and view on Google Maps\n\nTrack and log live GPS coordinates to Google Maps using NodeMCU, Neo6M GPS, and ThingSpeak IoT platform. This project shows how to upload real-time GPS data over Wi-Fi and visualize location history.\n\nBuild A Low Power SMS Based Vehicle Tracking System with A9G GSM+GPS Module and Arduino\n\nCreate a compact GPS tracker using A9G GSM/GPS module and Arduino. This project combines both cellular connectivity and GNSS tracking in one chip, sending SMS updates with real-time location. Ideal for makers wanting a lightweight and standalone tracking solution for smart bags, vehicles, or asset monitoring.\n\n# Complete Project Code\n\n```arduino\n/* \n* GeoLinkerLite Library\n* Tutorial Link: https://circuitdigest.com/microcontroller-projects/arduino-gps-tracker-…\n*Code for: Arduino GPS Tracker Project\n* Code by: Jobit, CircuitDigest\n*/\n\n#include <GeoLinkerLite.h>\n// Create the GeoLinkerLite instance\n// Using Serial for both debug and GPS\nGeoLinkerLite geoLinker(Serial, Serial);\nvoid setup() {\n   Serial.begin(9600);\n   delay(1000);\n   \n   // Configure settings (optional - defaults are set in the library)\n   geoLinker.setResetPin(2);                    // Reset control pin\n   geoLinker.setGSMPins(8, 9);                  // GSM RX, TX pins\n   geoLinker.setModemAPN(\"your.apn.here\");      // Your carrier's APN\n   geoLinker.setAPIKey(\"your_api_key\");         // Your GeoLinker API key\n   geoLinker.setDeviceID(\"arduino_tracker\");    // Unique device ID / Device name\n   geoLinker.setMaxRetries(3);                  // Max retry attempts to send a data ponit via GPRS\n   geoLinker.setDebugLevel(1);                  // Debug level\n   geoLinker.setTimeOffset(5, 30);              // Timezone: Eg. india +5:30 hours\n   \n   // Initialize the library\n   geoLinker.begin();\n   \n   // Run the main functionality\n   delay(1000);                                // Increase this delay to increase upate interval\n   geoLinker.run();\n}\nvoid loop() {\n   // Should never reach here as both modes end with reset\n   delay(1000);\n}\n```\n\n```arduino\n/* \n* GeoLinkerLite Library\n* Tutorial Link: https://circuitdigest.com/microcontroller-projects/arduino-gps-tracker-…\n*Code for: Arduino GPS Tracker Project\n* Code by: Jobit, CircuitDigest\n*/\n\n#include <GeoLinkerLite.h>\n// Create the GeoLinkerLite instance\n// Using Serial for both debug and GPS\nGeoLinkerLite geoLinker(Serial, Serial);\nvoid setup() {\n   Serial.begin(9600);\n   delay(1000);\n   \n   // Configure settings (optional - defaults are set in the library)\n   geoLinker.setResetPin(2);                    // Reset control pin\n   geoLinker.setGSMPins(8, 9);                  // GSM RX, TX pins\n   geoLinker.setModemAPN(\"your.apn.here\");      // Your carrier's APN\n   geoLinker.setAPIKey(\"your_api_key\");         // Your GeoLinker API key\n   geoLinker.setDeviceID(\"arduino_tracker\");    // Unique device ID / Device name\n   geoLinker.setMaxRetries(3);                  // Max retry attempts to send a data ponit via GPRS\n   geoLinker.setDebugLevel(1);                  // Debug level\n   geoLinker.setTimeOffset(5, 30);              // Timezone: Eg. india +5:30 hours\n   \n   // Initialize the library\n   geoLinker.begin();\n   \n   // Run the main functionality\n   delay(1000);                                // Increase this delay to increase upate interval\n   geoLinker.run();\n}\nvoid loop() {\n   // Should never reach here as both modes end with reset\n   delay(1000);\n}\n```\n\n# Start a Discussion on:\n\n# Comments\n\nIn the components section, you forgot to mention the diode you used. Moreover, what tyle of diode did you use? Along with it exact number?\n\nLog in or register to post comments\n\nIn reply to In the components section,… by umarbabar\n\n1N4007/1N5408 would do fine.\n\nLog in or register to post comments\n\nI'm looking forward to the 4G version, there's no 2G, or 3G in Australia, I want to put it in my caravan. Any idea when it will be released?\nThank you!\n\nLog in or register to post comments\n\nIn reply to I'm looking forward to the… by davidbanks\n\nWe are working on it.\n\nLog in or register to post comments\n\n# Add New Comment\n\nLog in or register to post comments"}
{"title":"Gas Leakage Detector Using Arduino: Complete DIY Guide","content":"Gas leaks can pose serious safety risks, especially in homes, kitchens, and small commercial spaces. In this project, you'll learn how to build a simple and budget-friendly gas leakage detector using Arduino. This LPG gas leak detector uses an Arduino Uno and MQ-5 gas sensor to detect gas levels in the air and activates a buzzer and LED to alert users when a leak is present.\n\nThis is a beginner-friendly Arduino project that’s both practical and educational. It requires only a few basic components and offers a great way to apply electronics in real-life safety applications. Without further delay, let’s get started on building it!\n\n# Gas Leakage Detector Using Arduino Project\n\nThis project is built around the MQ-5 gas sensor, which is designed to detect gases like LPG, propane, and methane. The sensor constantly monitors the air, and if it detects gas levels above a safe limit, it sends a signal to the Arduino to take action.\n\nWhen the Arduino receives this signal, it immediately turns on a buzzer to sound an alarm and lights up an LED to give a visual warning. This helps alert anyone nearby about the gas leak. Once the gas levels drop back to normal, the system automatically turns off both the buzzer and the LED, making it a fully automated safety solution.\n\nAlthough we’re using the MQ-5 sensor in this project, other options like the MQ-2 and MQ-6 also work well for detecting LPG gas. If you’re curious about how these sensors work and want to explore more, check out a detailed article called \"Introduction to Gas Sensors: Construction, Types, and Working\". It’s a great resource to understand how gas sensors function and the differences between them.\n\n# MQ-5 vs MQ-2 vs MQ-6: Choosing the Right Gas Sensor\n\nWhile this gas leakage detector using Arduino uses the MQ-5 sensor, understanding the differences between gas sensors helps you choose the best option for your specific needs. The MQ-2 sensor detects LPG, propane, hydrogen, and smoke, making it suitable for multi-gas detection applications. The MQ-6 sensor is specifically designed for LPG and butane detection, offering higher sensitivity to these gases compared to MQ-5.\n\nFor this Arduino gas leak detector project, MQ-5 provides the perfect balance of sensitivity and reliability for residential LPG detection applications.\n\n# Components Required for Arduino Gas Leakage Detector Project\n\nBelow, you can see the required components list.\n\nArduino Uno – 1 (The Brain of the system)\n\nArduino Uno – 1 (The Brain of the system)\n\nMQ-5 Gas Sensor – 1 (Detects gas presence in the environment)\n\nMQ-5 Gas Sensor – 1 (Detects gas presence in the environment)\n\nBuzzer – 1 (Audible alert when gas is detected)\n\nBuzzer – 1 (Audible alert when gas is detected)\n\nLED – 1 (Visual indicator)\n\nLED – 1 (Visual indicator)\n\n220Ω resistor – 1 (Used with the LED)\n\n220Ω resistor – 1 (Used with the LED)\n\nBreadboard & jumper wires – Required Quantity(For quick prototyping)\n\nBreadboard & jumper wires – Required Quantity(For quick prototyping)\n\n9V battery or USB–1 (Powering the Circuit)\n\n9V battery or USB–1 (Powering the Circuit)\n\n# Circuit Diagram of Gas Leakage Detector Using Arduino\n\nThe circuit diagram for the gas leakage detector is simple and straightforward. Below, you can see the circuit diagram used in this project.\n\nThe system is powered using a 7.2V 18650 battery, which is connected to the Arduino's power input (Vin). The Arduino then supplies 5V to power the MQ-5 gas sensor and other connected components. A common ground (GND) line is used to ensure all components share the same electrical reference.\n\nThe digital output of the MQ-5 gas sensor is connected to Arduino pin A2. This setup allows the Arduino to continuously read and monitor the presence of LPG gas in the environment.\n\nFor alerts, a buzzer is connected to Arduino pin A0 with a 10kΩ resistor, providing an audible warning when gas is detected. In your case, you can connect the buzzer with or without a resistor based on your sound requirements. For testing purposes, we preferred lower sound, so we used a higher resistance of 10kΩ.\n\nAdditionally, an LED connected to pin A1 through a 220Ω resistor serves as a visual indicator during a gas leak.\n\nAbove, you can see the fully assembled image of the project as per the circuit diagram. You can use other voltage sources like a power adapter or USB power for powering the system, using a 2S battery is not the only option.\n\n# Arduino Code for Gas Leakage Detector Project\n\nFor this project, we simply chose the digital output of the MQ-5 sensor, which can be easily tuned via the built-in potentiometer on the sensor module. This eventually makes the code simple to understand. If you are completely new to arduino, check out our tutorial on Arduino IDE and Arduino Programming to understand the basics. The complete code for this project can be found at the bottom of this page, in this section lets understand the code section by section.\n\n# Variables and Pin Definitions\n\n```arduino\nconst int gasSensorDigitalPin = A2;\nconst int ledPin = A1;             \nconst int buzzerPin = A0;\n```\n\n```arduino\nconst int gasSensorDigitalPin = A2;\nconst int ledPin = A1;             \nconst int buzzerPin = A0;\n```\n\nThe code starts by defining three constant variables that specify which Arduino pins connect to each component. The gas sensor's digital output connects to pin A2, the warning LED connects to pin A1, and the buzzer connects to pin A0. These constants make the code easy to read and modify, if you need to change a pin connection, you only need to update it in one place, and that's here.\n\n# Setup Function\n\n```arduino\npinMode(gasSensorDigitalPin, INPUT); \npinMode(ledPin, OUTPUT);             \npinMode(buzzerPin, OUTPUT);\n```\n\n```arduino\npinMode(gasSensorDigitalPin, INPUT); \npinMode(ledPin, OUTPUT);             \npinMode(buzzerPin, OUTPUT);\n```\n\nThe setup function runs exactly once when the Arduino powers on or resets. This function configures the three pins for their specific roles, it sets pin A2 as an input to read signals from the gas sensor, while pins A1 and A0 are set as outputs to control the LED and buzzer, respectively.\n\n```arduino\nSerial.begin(9600);\nSerial.println(\"Gas Detection System Initialized (Digital Mode)\");\n```\n\n```arduino\nSerial.begin(9600);\nSerial.println(\"Gas Detection System Initialized (Digital Mode)\");\n```\n\nThe setup function also initializes serial communication at 9600 baud rate, which allows the Arduino to send status messages to your computer. Finally, it prints an initialization message to confirm the system has started successfully.\n\n# Loop Function\n\n```arduino\nint gasState = digitalRead(gasSensorDigitalPin);\n```\n\n```arduino\nint gasState = digitalRead(gasSensorDigitalPin);\n```\n\nThe loop function contains the core logic and runs continuously while the Arduino is powered. It starts by reading the digital state of the gas sensor using the digitalRead function. The sensor outputs either HIGH (normal conditions) or LOW (gas detected).\n\n```arduino\nif (gasState == LOW) {\n  digitalWrite(ledPin, HIGH);    \n  digitalWrite(buzzerPin, HIGH);\n  Serial.println(\"!! Gas Leak Detected !!\");\n} else {\n  digitalWrite(ledPin, LOW);     \n  digitalWrite(buzzerPin, LOW);   \n  Serial.println(\"Environment Normal\");\n}\n```\n\n```arduino\nif (gasState == LOW) {\n  digitalWrite(ledPin, HIGH);    \n  digitalWrite(buzzerPin, HIGH);\n  Serial.println(\"!! Gas Leak Detected !!\");\n} else {\n  digitalWrite(ledPin, LOW);     \n  digitalWrite(buzzerPin, LOW);   \n  Serial.println(\"Environment Normal\");\n}\n```\n\nThe code uses an if-else statement to handle two scenarios. When gas is detected (sensor reads LOW), it activates both alarm systems by turning on the LED and buzzer, then prints an alarm message to the serial monitor. When no gas is present (sensor reads HIGH), it turns off both the LED and buzzer, then prints a normal status message.\n\n```arduino\ndelay(800);\n```\n\n```arduino\ndelay(800);\n```\n\nThe loop ends with an 800-millisecond delay before repeating. This delay prevents the serial monitor from being flooded with messages and gives the system time to process each reading properly.\n\nThis Arduino code for gas leakage detection can be easily modified for different requirements. You can adjust the delay time, add multiple sensors, or integrate with other Arduino projects. The simple digital read approach makes this gas detector Arduino code perfect for beginners learning embedded programming.\n\n# GitHub Repository with Code and Circuit\n\n# Working of the Arduino Gas Leakage Detector\n\nOnce the code is successfully uploaded to the Arduino, you can begin testing the system. Since we are using the digital output of the MQ-5 gas sensor, it is essential to correctly tune the sensor's threshold using the onboard potentiometer to ensure accurate gas detection.\n\n# Tuning the Sensor Threshold\n\nThe gas sensor module has a small blue knob called a potentiometer that controls how sensitive the sensor is to gas. In digital mode, the sensor only gives two signals: HIGH means no gas detected, and LOW means gas detected. The potentiometer sets the \"trigger point\",  determining how much gas is needed before the sensor switches from HIGH to LOW.\n\nTo adjust it properly, first turn the potentiometer clockwise in clean air until the sensor's onboard LED turns OFF. Then bring some gas near the sensor (like from a lighter), and the LED should turn ON. If it doesn't turn ON, turn the potentiometer counter-clockwise to make it more sensitive. If it turns ON too easily, even in clean air, turn it clockwise to make it less sensitive.\n\nThis adjustment requires a trial-and-error method. If the sensor is too sensitive, turn the potentiometer clockwise to reduce sensitivity. If it's not sensitive enough, turn it counter-clockwise to increase sensitivity. Keep adjusting until it only triggers when actual gas is present, ensuring reliable detection without false alarms.\n\nRemember, this behavior might be completely reversed in some sensor modules.\n\n# Working Demo\n\nAfter successfully tuning the sensor, our system is ready to deploy. For testing purposes, I am using a small cigarette lighter, which contains the same components as LPG. Below you can see the image of the system where the warning signal is activated in the presence of gas from the cigarette lighter.\n\nAdvanced features such as SMS alert systems and IoT integration can also be incorporated into the project to enhance its functionality. These additions enable remote monitoring and real-time notifications, making the system more reliable and suitable for critical safety applications.\n\n# Troubleshooting Common Issues\n\nIf your Arduino-based gas leakage detector isn't working properly, ensure the MQ-5 gas sensor has warmed up for at least 24 hours for accurate readings, verify all connections match the circuit diagram, and confirm the potentiometer is properly tuned for your environment. You can also check out our dedicated tutorial on how to use mq5 gas sensor with arduino to understand the basics. If you are still facing problems, write them in the comment section below or us the ask the community option at the bottom of this page.\n\n# Safety Considerations and Limitations\n\nThis DIY gas leakage detector is designed for educational and basic monitoring purposes. For critical safety applications, always use certified commercial gas detectors as primary safety devices. This Arduino gas sensor project should serve as a supplementary monitoring system rather than a replacement for professional safety equipment.\n\n# Applications and Uses of Arduino Gas Leakage Detector\n\nThe gas leakage detector using Arduino offers versatile applications across various environments where gas safety is crucial. This Arduino-based gas detection system can be deployed in multiple settings to provide reliable safety monitoring.\n\nHome and Kitchen Safety: Install the detector near gas stoves, water heaters, and LPG cylinders to monitor cooking areas and utility rooms. The system provides immediate alerts when gas concentrations exceed safe levels, protecting families from potential gas poisoning or explosion risks.\n\nCommercial Applications: Small restaurants, food trucks, and commercial kitchens can benefit from this Arduino gas sensor project for continuous monitoring. The low-cost solution makes it accessible for small businesses that need reliable gas detection without expensive commercial systems.\n\nIndustrial Monitoring: Warehouses storing LPG cylinders, gas distribution centers, and small manufacturing units can implement this system for basic gas leak detection. The MQ-5 sensor effectively detects propane, butane, and methane leaks in industrial environments.\n\nEducational Projects: This project serves as an excellent learning tool for students studying electronics, embedded systems, and safety engineering. It demonstrates practical applications of Arduino programming and sensor interfacing in real-world safety scenarios.\n\nRV and Camping Safety: Recreational vehicles and camping setups using portable gas stoves or heaters can benefit from this portable gas detection system. The battery-powered operation makes it ideal for outdoor activities where gas safety monitoring is essential.\n\nLaboratory and Workshop Use: Research labs and workshops using gas-powered equipment can implement this system as a backup safety measure. The digital output mode provides simple on/off detection suitable for basic safety requirements.\n\n# Frequently Asked Questions About Gas Leakage Detector Using Arduino\n\n# Which gas sensor is best for Arduino gas leak detection?\n\nThe MQ-5 gas sensor is ideal for LPG detection in this Arduino gas leakage detector project. However, MQ-2 works for multiple gases, while MQ-6 offers higher LPG sensitivity. Choose based on your specific gas detection requirements.\n\n# How accurate is an Arduino-based gas leakage detector?\n\nThis DIY gas detector provides reliable detection for educational and supplementary monitoring purposes. While effective for basic gas leak detection, it should not replace certified commercial detectors for critical safety applications.\n\n# Can I use this gas detector for other gases besides LPG?\n\nYes, by replacing the MQ-5 sensor with other MQ series sensors, you can detect different gases. MQ-2 detects smoke and multiple gases, while MQ-7 detects carbon monoxide in your Arduino gas sensor project.\n\n# How long does the MQ-5 sensor last in this Arduino project?\n\nThe MQ-5 gas sensor typically lasts 2-5 years with continuous operation. Regular calibration and proper handling extend sensor life in your gas leakage detector using Arduino.\n\n# Conclusion\n\nBuilding a gas leakage detector using Arduino is an excellent way to learn electronics while creating a practical safety device. This Arduino-based gas detection system demonstrates how simple components like the MQ-5 gas sensor, buzzer, and LED can create an effective monitoring solution. Whether you're a student learning Arduino programming or someone interested in home safety automation, this gas detector Arduino project provides hands-on experience with sensor interfacing and embedded programming. Remember to always use this as a supplementary safety measure alongside certified commercial gas detectors.\n\nThis gas leakage detector using Arduino project can be further enhanced with wireless connectivity, smartphone notifications, or data logging capabilities. The modular design makes it easy to expand and customize for specific applications, making it a perfect foundation for advanced Arduino gas sensor projects.\n\n# Similar Gas Leakage Detector Projects\n\nPreviously we have build many interesting gas leakage detector projects. If you want to know more about those projects, links are given below.\n\nArduino Air Quality Monitoring System\n\nLearn how to build an Arduino-based Air Quality Monitoring System using the MQ-135 sensor. This project helps track air pollution levels with real-time data display, ideal for home and environmental monitoring applications.\n\nMeasuring CO2 Concentration in Air using Arduino and MQ-135 Sensor\n\nDiscover how to interface the MQ135 gas sensor with Arduino to measure CO2 levels in PPM. This project offers a simple way to monitor indoor air quality and detect harmful gases using a cost-effective setup.\n\nGas Detection and PPM Measurement using PIC Microcontroller and MQ Gas Sensors\n\nLearn how to build a gas detection and PPM measurement system using a PIC microcontroller and MQ gas sensor. This tutorial covers circuit design, sensor interfacing, and real-time gas concentration monitoring for safety applications.\n\n# Start a Discussion on:\n\n# Add New Comment\n\nLog in or register to post comments"}
{"title":"How to build a Smoke and Fire Alarm System using Arduino with SMS Notification","content":"What if you could get an instant SMS alert the moment a fire or smoke is detected at home or office? Through this project tutorial, you can build a fire and smoke alarm system using Arduino UNO R4 that sends real-time SMS notifications. This means you will immediately get alerted even if you are far away.\n\nIn this Arduino Project, you will also learn how to build an Arduino smoke alarm that sends SMS Alerts without needing to rely on the GSM module. The Arduino UNO R4 will detect fire or smoke using the specific sensors and trigger the SMS alert to the authorized person’s mobile number. It is a simple, low-cost way to improve safety in your house or office. You can also check out our other IoT-based projects if you are interested. That being said, let's dive into this project\n\n# How does a Fire & Smoke Alarm System Work?\n\nYou might wonder how this fire and smoke alarm system with SMS notification works when it detects fire or smoke without a GSM module? The secret lies behind the communication between Arduino and Cloud APIs. Let’s see how it works in-depth.\n\nArduino connects to the WiFi Hotspot - First of all, Arduino makes it connect to the existing WiFi network using wifi credentials. So that Arduino is able to communicate with the cloud SMS APIs for sending SMS Alerts.\n\nArduino connects to the WiFi Hotspot - First of all, Arduino makes it connect to the existing WiFi network using wifi credentials. So that Arduino is able to communicate with the cloud SMS APIs for sending SMS Alerts.\n\nFire and Smoke Detection - The sensors used with the Arduino are responsible for continuously monitoring the surroundings to detect Fire or smoke. When it detects, it immediately sends a signal to Arduino.\n\nFire and Smoke Detection - The sensors used with the Arduino are responsible for continuously monitoring the surroundings to detect Fire or smoke. When it detects, it immediately sends a signal to Arduino.\n\nArduino Triggers the Alert - After getting a fire and smoke signal from the sensors, without delay, it starts to trigger both the Alarm unit as well as the SMS alert. For an SMS alert, it sends an HTTP Request to the Cloud SMS API, which contains a recipient phone number and alert message.\n\nArduino Triggers the Alert - After getting a fire and smoke signal from the sensors, without delay, it starts to trigger both the Alarm unit as well as the SMS alert. For an SMS alert, it sends an HTTP Request to the Cloud SMS API, which contains a recipient phone number and alert message.\n\nDelivery of SMS from SMS API - After receiving an HTTP Request to send SMS to a specific mobile number. It sends that SMS through its mobile network. This makes the Arduino send SMS, even though it doesn't use any GSM modules at all.\n\nDelivery of SMS from SMS API - After receiving an HTTP Request to send SMS to a specific mobile number. It sends that SMS through its mobile network. This makes the Arduino send SMS, even though it doesn't use any GSM modules at all.\n\nHere, to send SMS alerts, I am using the Circuit Digest Cloud SMS APIs, which are known for being fast, reliable, and completely free of cost. You can explore the API Documentation of this SMS API to understand how to use it.\n\nLet's make sure you follow the Simple process to generate your SMS API Key, which is needed in the following tutorial, especially for the programming part.\n\n# Components Required\n\nI hope you understand the working of the Fire and Smoke Detector System with SMS Alerts. Now it’s time to prepare a components checklist for purchasing the components from the nearby electronics shops. Here are the things needed for making a DIY Fire and Smoke Alarm System.\n\nArduino UNO R4 WiFi Development Board\n\nArduino UNO R4 WiFi Development Board\n\nFlame Sensor\n\nFlame Sensor\n\nMQ2 Smoke Sensor\n\nMQ2 Smoke Sensor\n\n5V Active Buzzer\n\n5V Active Buzzer\n\nRed and Green LEDs\n\nRed and Green LEDs\n\n220-ohm resistors\n\n220-ohm resistors\n\nBreadboard\n\nBreadboard\n\nConnecting Wires\n\nConnecting Wires\n\n# Circuit Diagram\n\nThis circuit diagram illustrates a fire and smoke detection system using an Arduino UNO R4 WiFi, MQ2 smoke sensor, and a flame sensor (fire sensor). The Arduino is the central controller that receives input from the MQ2 and flame sensors, then activates an alarm system composed of a buzzer, red LED, and green LED depending on the detected conditions. The green LED indicates normal status, while the red LED and buzzer serve as warning indicators in case of fire or gas leak detection. The connections are made via a breadboard to allow for rapid prototyping and component testing. SMS.\n\nThe MQ2 gas sensor is designed to detect combustible gases such as LPG, butane, methane, alcohol, propane, hydrogen, and smoke. It has both analog (AO) and digital (DO) outputs. In this setup, the analog output (AO) is connected to the Arduino to provide varying voltage levels depending on the concentration of gas in the air. The flame sensor detects infrared light emitted by fire using a photodiode or IR receiver and is connected through its digital output to the Arduino. When the sensor detects a flame (based on IR radiation intensity), it sends a HIGH signal to the digital pin. The Arduino then processes these inputs and triggers the alarm system if the gas concentration or flame is above a certain threshold. This setup is ideal for home automation, industrial safety, IoT fire alert systems, and smart fire detection systems.\n\nLet’s check out our actual hardware setup and wiring connection of the Fire and Smoke detector system.\n\nWe can power the power supply either through its USB port or through the DC Power Jack connector. For simplicity, I decided to move on with a 5V USB power supply since it is easily available and helpful in serial debugging through its USB Port.\n\n# SMS Templates in Circuit Digest Cloud\n\nHere is the list of prebuilt SMS Templates provided by the Circuit Digest SMS API, where each SMS template is designed for a specific practical application.\n\nDue to these predefined SMS Templates, the possibilities of sending spam messages from this SMS API are nearly zero. This means that API misuse and bandwidth drop of the API server are greatly avoided.\n\nSince we are developing an “Arduino-based Smoke & Fire Alarm system with SMS Notification”. For that, I thought the “Device status Alert SMS Template with ID of 101” might be the right choice, as shown below.\n\nIn the above template, you can see the two “#var#”, which are user customizable, which means users can put their own message on it.\n\nYou can bring out your own message in place of “#var#” by initialising the custom messages to the global variables var1 and var2 present on this project code. For example, if I initialise the var1 to “house” and var2 to “FIRE EMERGENCY. Evacuate now!”. Then the SMS alert on the phone will look like this.\n\n# Arduino Smoke Detector Code\n\nCode Overview\n\nBefore diving on to the actual code. Let’s understand the core logic behind this program. Basically, this program enables the Arduino UNO R4 to connect to an existing WiFi network, so it can send an SMS alert via API when the flame sensor or smoke sensors detects fire and smoke.\n\nAt the same time, it also triggers the onboard LED and buzzer for alarm purposes. It also keeps a check on Wi-Fi connectivity status. Suppose if it gets disconnected, the code will make it connect to the network automatically.\n\nIncluding Headerfiles\n\n```arduino\n#include \"WiFiS3.h\"\n#include \"Arduino_LED_Matrix.h\"\n```\n\n```arduino\n#include \"WiFiS3.h\"\n#include \"Arduino_LED_Matrix.h\"\n```\n\nHere, “WiFiS3.h” consists for predefined class-specific functions, which simplify the WiFi-specific process, like connecting to an existing WiFi Network and sending HTTP requests over the Internet.\n\nWhereas, “Arduino_LED_Matrix.h” helps in bringing out different kinds of icons and animations on the onboard 12x8 LED Matrix to improve it’s user experience. Note, we don’t want to install these libraries individually, since they already come with an Arduino UNO R4 Board support package.\n\nArduino GPIO Pin Defining Macros\n\n```arduino\n#define Smoke_sensor 2\n#define Flame_sensor 6\n#define Green_led 3\n#define Red_led 5\n#define Buzzer 4\n```\n\n```arduino\n#define Smoke_sensor 2\n#define Flame_sensor 6\n#define Green_led 3\n#define Red_led 5\n#define Buzzer 4\n```\n\nInstead of using variables to hold GPIO Pin connection details of sensors, buzzer, LED..etc, here I used the #define macros to define GPIO Pins. The way of declaring the GPIO pins using Macros is more memory efficient than simply using variables.\n\nArduino LED Matrix Object creation\n\n```arduino\nArduinoLEDMatrix matrix;\n```\n\n```arduino\nArduinoLEDMatrix matrix;\n```\n\nHere I am creating a new object from the ArduinoLEDMatrix class, to use the ArduinoLEDMatrix class's specific pre built functions to bring out the animation and icons on the Arduino UNO’s onboard LED Matrix.\n\nGlobal Variables for Holding Credentials and Data\n\n```arduino\n/* --------------------- WiFi Credentials and WiFi status ----------------*/\nconst char *ssid = \"Semicon Media\";      //Your WiFi Router SSID\nconst char *password = \"xxxxxxxxxxxx\";   // Your WiFi Router password\nint status = WL_IDLE_STATUS;             // Connection status\n```\n\n```arduino\n/* --------------------- WiFi Credentials and WiFi status ----------------*/\nconst char *ssid = \"Semicon Media\";      //Your WiFi Router SSID\nconst char *password = \"xxxxxxxxxxxx\";   // Your WiFi Router password\nint status = WL_IDLE_STATUS;             // Connection status\n```\n\nThe above global variables are used for storing the WiFi Hotspot Credentials, so that Arduino can make use of them to connect to the WiFi network. The status variable is used for storing the WiFi connectivity status.\n\n```arduino\n/* ---------------------- API credentials and SMS Details ---------------------- */\nconst char* apiKey = \"xxxxxxxxxxx\";          // Replace with your API key\nconst char* templateID = \"101\";           // Replace with your template ID\nconst char* mobileNumber = \"91xxxxxxxxxxxx\"; // Replace with the recipient's mobile number with country code (eg : 91XXXXXXXXXX)\nconst char* var1 = \"house\";   // Replace with your custom variable\nconst char* var2 = \"FIRE EMERGENCY. Evacuate now!\";          // Replace with your custom variable\n```\n\n```arduino\n/* ---------------------- API credentials and SMS Details ---------------------- */\nconst char* apiKey = \"xxxxxxxxxxx\";          // Replace with your API key\nconst char* templateID = \"101\";           // Replace with your template ID\nconst char* mobileNumber = \"91xxxxxxxxxxxx\"; // Replace with the recipient's mobile number with country code (eg : 91XXXXXXXXXX)\nconst char* var1 = \"house\";   // Replace with your custom variable\nconst char* var2 = \"FIRE EMERGENCY. Evacuate now!\";          // Replace with your custom variable\n```\n\nThese variables hold the SMS API  Credentials like apiKey, SMS template ID, recipient mobile number as well as the user customizable SMS template variables. Here, make sure you replace the API key with your previously generated API, and don’t forget to update the recipient's mobile number too.\n\nIf you still haven’t generated api, just follow these simple steps to get an SMS API key within a matter of seconds.\n\n```arduino\n/* ---------------------- Network Led icons ---------------------- */\nconst uint32_t network_connect_icon[] = { 0x308311, 0xba1b4db0, 0xdb6db6db };\nconst uint32_t network_disconnect_icon[] = { 0x3003a1, 0xb41badb0, 0xdb6db6db };\n```\n\n```arduino\n/* ---------------------- Network Led icons ---------------------- */\nconst uint32_t network_connect_icon[] = { 0x308311, 0xba1b4db0, 0xdb6db6db };\nconst uint32_t network_disconnect_icon[] = { 0x3003a1, 0xb41badb0, 0xdb6db6db };\n```\n\nnetwork_connect_icon[] and network_disconnect_icon[] hold the bitmap data for the 12x8 LED matrix to bring out the network connected status and network disconnected status icon on it.\n\n```arduino\n/* ---------------------- Network connection animation ---------------------- */\nconst uint32_t wifi_connection_anime[][4] = {\n { 0x0, 0x0, 0x0, 600 },\n { 0x0, 0x0, 0x600600, 600 },\n { 0x0, 0xc00, 0xc06c06c0, 600 },\n { 0x1, 0x80180d80, 0xd86d86d8, 600 },\n { 0x300301, 0xb01b0db0, 0xdb6db6db, 660}\n};\nThis two-dimensional array is used for holding the bitmap sequence of the LED Matrix display to bring out the network connection animation.\n/* ---------------------- Sensor Ststus Variables ---------------------- */\nbool flame_status = false;\nbool smoke_status = true;\n```\n\n```arduino\n/* ---------------------- Network connection animation ---------------------- */\nconst uint32_t wifi_connection_anime[][4] = {\n { 0x0, 0x0, 0x0, 600 },\n { 0x0, 0x0, 0x600600, 600 },\n { 0x0, 0xc00, 0xc06c06c0, 600 },\n { 0x1, 0x80180d80, 0xd86d86d8, 600 },\n { 0x300301, 0xb01b0db0, 0xdb6db6db, 660}\n};\nThis two-dimensional array is used for holding the bitmap sequence of the LED Matrix display to bring out the network connection animation.\n/* ---------------------- Sensor Ststus Variables ---------------------- */\nbool flame_status = false;\nbool smoke_status = true;\n```\n\nThese status variables are used for holding the sensor status, like flame detection status and smoke detection status.\n\nWiFi Connect Function\n\n```arduino\n/* --------------------------- WiFi connect Function --------------------------- */\nvoid wifi_connect(){\n if (WiFi.status() == WL_NO_MODULE) {\n   Serial.println(\"Communication with WiFi module failed!\");\n   matrix.loadFrame(network_disconnect_icon);\n   while (true);\n }\n Serial.print(\"Connecting to WiFi...\");\n matrix.loadSequence(network_connection_anime);\n matrix.play(true);\n delay(6000);\n while (WiFi.begin(ssid, password) != WL_CONNECTED) {\n   Serial.print(\".\");\n   delay(1000);\n }\n matrix.loadFrame(network_connect_icon);\n Serial.println(\"\\nConnected to WiFi!\");\n Serial.print(\"IP Address: \");\n Serial.println(WiFi.localIP());\n}\n```\n\n```arduino\n/* --------------------------- WiFi connect Function --------------------------- */\nvoid wifi_connect(){\n if (WiFi.status() == WL_NO_MODULE) {\n   Serial.println(\"Communication with WiFi module failed!\");\n   matrix.loadFrame(network_disconnect_icon);\n   while (true);\n }\n Serial.print(\"Connecting to WiFi...\");\n matrix.loadSequence(network_connection_anime);\n matrix.play(true);\n delay(6000);\n while (WiFi.begin(ssid, password) != WL_CONNECTED) {\n   Serial.print(\".\");\n   delay(1000);\n }\n matrix.loadFrame(network_connect_icon);\n Serial.println(\"\\nConnected to WiFi!\");\n Serial.print(\"IP Address: \");\n Serial.println(WiFi.localIP());\n}\n```\n\nThis function is responsible for making Arduino connect to the authorized Wi-Fi hotspot using its Wi-Fi credentials. While trying to connect to the network,  it will bring out the network connecting animation.\n\nAfter successfully getting connected to the Wi-Fi network, it will bring out the stable Network connected image on the LED Matrix.\n\nWiFi Reconnect Function\n\n```arduino\n/* ------------------------ WiFi reconnect Function ----------------------------- */\nvoid wifi_reconnect(){\n   Serial.println(\"Wifi Reconnecting........\");\n   matrix.loadFrame(network_disconnect_icon);\n   delay(6000);\n   wifi_connect();\n}\n```\n\n```arduino\n/* ------------------------ WiFi reconnect Function ----------------------------- */\nvoid wifi_reconnect(){\n   Serial.println(\"Wifi Reconnecting........\");\n   matrix.loadFrame(network_disconnect_icon);\n   delay(6000);\n   wifi_connect();\n}\n```\n\nIf the Arduino gets disconnected from the wifi hotspot, it uses this function to reconnect to the network. After the call of this function, it will bring out the WiFi disconnected symbol on the led matrix for six seconds.\n\nLater it makes a call on the wifi_connect() function to get connected to the Internet.\n\nFire and Smoke Detect Function\n\n```arduino\n/* ------------------------ Fire & Smoke detect Function ------------------------- */\nbool fire_smoke_detect(){\n flame_status = digitalRead(Flame_sensor);\n smoke_status = digitalRead(Smoke_sensor);\n if(!flame_status || !smoke_status){\n     return true;\n }\n else{\n    return false;\n }\n}\n```\n\n```arduino\n/* ------------------------ Fire & Smoke detect Function ------------------------- */\nbool fire_smoke_detect(){\n flame_status = digitalRead(Flame_sensor);\n smoke_status = digitalRead(Smoke_sensor);\n if(!flame_status || !smoke_status){\n     return true;\n }\n else{\n    return false;\n }\n}\n```\n\nThis fire and smoke detection function is used to continuously track the fire and smoke sensor status. If the fire or smoke is detected by any of the sensors, it will return “true” else it will return “false” to its calling function.\n\nSMS Alert trigger Function\n\n```arduino\n/* ------------------------ SMS Trigger Function ---------------------------------- */\nvoid trigger_SMS(){\n  if (WiFi.status() == WL_CONNECTED) {\n   WiFiClient client; // Initialize WiFi client\n   String apiUrl = \"/send_sms?ID=\" + String(templateID);\n   Serial.print(\"Connecting to server...\");\n   if (client.connect(\"www.circuitdigest.cloud\", 80)) { // Connect to the server\n     Serial.println(\"connected!\");\n     // Create the HTTP POST request\n     String payload = \"{\\\"mobiles\\\":\\\"\" + String(mobileNumber) +\n                      \"\\\",\\\"var1\\\":\\\"\" + String(var1) +\n                      \"\\\",\\\"var2\\\":\\\"\" + String(var2) + \"\\\"}\";\n     // Send HTTP request headers\n     client.println(\"POST \" + apiUrl + \" HTTP/1.1\");\n     client.println(\"Host: www.circuitdigest.cloud\");\n     client.println(\"Authorization: \" + String(apiKey));\n     client.println(\"Content-Type: application/json\");\n     client.println(\"Content-Length: \" + String(payload.length()));\n     client.println(); // End of headers\n     client.println(payload); // Send the JSON payload\n     // Wait for the response\n     int responseCode = -1; // Variable to store HTTP response code\n     while (client.connected() || client.available()) {\n       if (client.available()) {\n         String line = client.readStringUntil('\\n'); // Read a line from the response\n         Serial.println(line); // Print the response line (for debugging)\n         // Check for the HTTP response code\n         if (line.startsWith(\"HTTP/\")) {\n           responseCode = line.substring(9, 12).toInt(); // Extract response code (e.g., 200, 404)\n           Serial.print(\"HTTP Response Code: \");\n           Serial.println(responseCode);\n         }\n         // Stop reading headers once we reach an empty line\n         if (line == \"\\r\") {\n           break;\n         }\n       }\n     }\n     // Check response\n     if (responseCode == 200) {\n       Serial.println(\"SMS sent successfully!\");\n     } else {\n       Serial.print(\"Failed to send SMS. Error code: \");\n       Serial.println(responseCode);\n     }\n     client.stop(); // Disconnect from the server\n   } else {\n     Serial.println(\"Connection to server failed!\");\n   }\n } else {\n   Serial.println(\"WiFi not connected!\");\n }\n}\n```\n\n```arduino\n/* ------------------------ SMS Trigger Function ---------------------------------- */\nvoid trigger_SMS(){\n  if (WiFi.status() == WL_CONNECTED) {\n   WiFiClient client; // Initialize WiFi client\n   String apiUrl = \"/send_sms?ID=\" + String(templateID);\n   Serial.print(\"Connecting to server...\");\n   if (client.connect(\"www.circuitdigest.cloud\", 80)) { // Connect to the server\n     Serial.println(\"connected!\");\n     // Create the HTTP POST request\n     String payload = \"{\\\"mobiles\\\":\\\"\" + String(mobileNumber) +\n                      \"\\\",\\\"var1\\\":\\\"\" + String(var1) +\n                      \"\\\",\\\"var2\\\":\\\"\" + String(var2) + \"\\\"}\";\n     // Send HTTP request headers\n     client.println(\"POST \" + apiUrl + \" HTTP/1.1\");\n     client.println(\"Host: www.circuitdigest.cloud\");\n     client.println(\"Authorization: \" + String(apiKey));\n     client.println(\"Content-Type: application/json\");\n     client.println(\"Content-Length: \" + String(payload.length()));\n     client.println(); // End of headers\n     client.println(payload); // Send the JSON payload\n     // Wait for the response\n     int responseCode = -1; // Variable to store HTTP response code\n     while (client.connected() || client.available()) {\n       if (client.available()) {\n         String line = client.readStringUntil('\\n'); // Read a line from the response\n         Serial.println(line); // Print the response line (for debugging)\n         // Check for the HTTP response code\n         if (line.startsWith(\"HTTP/\")) {\n           responseCode = line.substring(9, 12).toInt(); // Extract response code (e.g., 200, 404)\n           Serial.print(\"HTTP Response Code: \");\n           Serial.println(responseCode);\n         }\n         // Stop reading headers once we reach an empty line\n         if (line == \"\\r\") {\n           break;\n         }\n       }\n     }\n     // Check response\n     if (responseCode == 200) {\n       Serial.println(\"SMS sent successfully!\");\n     } else {\n       Serial.print(\"Failed to send SMS. Error code: \");\n       Serial.println(responseCode);\n     }\n     client.stop(); // Disconnect from the server\n   } else {\n     Serial.println(\"Connection to server failed!\");\n   }\n } else {\n   Serial.println(\"WiFi not connected!\");\n }\n}\n```\n\nThe SMS trigger function is used to send an SMS alert to the recipient’s mobile number using the predefined SMS templates. Here is how it utilises the Cloud API to send SMS It uses the WiFiClient for HTTP communication and sends a JSON payload using the HTTP POST method.\n\nAfter that, it extracts the HTTP response code for status verification and properly disconnects from the cloud API client.\n\nAlarm Trigger Function\n\n```arduino\n/* -------------------------- Alarm Trigger Function ----------------------------- */\nvoid trigger_Alarm(){\n   static unsigned long prevmillis = 0;\n   static bool buzzer_state = false;\n   const unsigned long beep_interval = 100;\n    digitalWrite(Red_led, HIGH);\n    digitalWrite(Green_led, LOW);\n    //Buzzer Beep Rate\n    if(millis() - prevmillis >= beep_interval){\n       prevmillis = millis();\n       buzzer_state = !buzzer_state;\n       digitalWrite(Buzzer, buzzer_state);\n    }\n}\n```\n\n```arduino\n/* -------------------------- Alarm Trigger Function ----------------------------- */\nvoid trigger_Alarm(){\n   static unsigned long prevmillis = 0;\n   static bool buzzer_state = false;\n   const unsigned long beep_interval = 100;\n    digitalWrite(Red_led, HIGH);\n    digitalWrite(Green_led, LOW);\n    //Buzzer Beep Rate\n    if(millis() - prevmillis >= beep_interval){\n       prevmillis = millis();\n       buzzer_state = !buzzer_state;\n       digitalWrite(Buzzer, buzzer_state);\n    }\n}\n```\n\nThe alarm trigger function is used to trigger the buzzer with non-blocking beep rate adjust control and also make the status LEDs glow.\n\nSetup Function\n\n```arduino\n/* ------------------------- Setup Function --------------------------------*/\nvoid setup() {\n   //Initialize serial and wait for port to open:\n Serial.begin(9600);\n while (!Serial);\n matrix.begin();\n wifi_connect();\n pinMode(Smoke_sensor, INPUT);\n pinMode(Flame_sensor, INPUT);\n pinMode(Green_led, OUTPUT);\n pinMode(Red_led, OUTPUT);\n pinMode(Buzzer, OUTPUT);\n digitalWrite(Green_led, HIGH);\n digitalWrite(Red_led, LOW);\n digitalWrite(Buzzer, LOW);\n}\n```\n\n```arduino\n/* ------------------------- Setup Function --------------------------------*/\nvoid setup() {\n   //Initialize serial and wait for port to open:\n Serial.begin(9600);\n while (!Serial);\n matrix.begin();\n wifi_connect();\n pinMode(Smoke_sensor, INPUT);\n pinMode(Flame_sensor, INPUT);\n pinMode(Green_led, OUTPUT);\n pinMode(Red_led, OUTPUT);\n pinMode(Buzzer, OUTPUT);\n digitalWrite(Green_led, HIGH);\n digitalWrite(Red_led, LOW);\n digitalWrite(Buzzer, LOW);\n}\n```\n\nHere, the setup function is responsible for initializing the serial monitor, the onboard LED matrix, and making the Arduino connect to the Wi-Fi network. After that, it makes sure the Red LED and Buzzer remain off in the initial stage.\n\nLoop Function\n\n```arduino\n/* ---------------------------- Loop Function ---------------------------------- */\nvoid loop() {\n   if(WiFi.status() != WL_CONNECTED){\n       wifi_reconnect();\n   }\n  if(fire_smoke_detect() == true){\n      trigger_SMS();\n      while(1){\n         trigger_Alarm();\n      }\n  }\n}\n```\n\n```arduino\n/* ---------------------------- Loop Function ---------------------------------- */\nvoid loop() {\n   if(WiFi.status() != WL_CONNECTED){\n       wifi_reconnect();\n   }\n  if(fire_smoke_detect() == true){\n      trigger_SMS();\n      while(1){\n         trigger_Alarm();\n      }\n  }\n}\n```\n\nHere is our main loop function, which is responsible for continuously checking whether fire or smoke is detected or not. If it gets detected by sensors, it will trigger the Fire Emergency SMS alert to the recipient’s mobile phone.\n\nAfter that, it keeps on triggering the Buzzer alarm to alert individuals in the house. This alarm gets stopped only after a hard reset of the Arduino UNO board.\n\n# Uploading code into Arduino\n\nLet’s get to see the above program working in action; for that, we need to flash the compiled code into Arduino’s flash memory.\n\nBefore flashing the code, we want to make sure the “Arduino UNO R4 WiFi Board” is properly selected in the Arduino IDE as shown below.\n\nAfter selecting the board port properly, next we want to make sure our Arduino board is showing on the Arduino IDE’s port section. If it is shown, select it. So that we can be able to program it.\n\nFinally, click the upload button to flash the code into the Arduino IDE’s flash memory.\n\n# Final Check and System Testing\n\nAfter the program flash, the Arduino UNO R4 WiFI tries to connect to the existing WiFi network using WiFi credentials. While it’s trying to connect to the network, it will bring out the “Network connecting animation” on its onboard LED Matrix as shown below.\n\nAfter successfully connecting to the WiFi network, it will display the “Network Connected Symbol” on the LED matrix to give a visual feedback to the user for get to know the WiFi network status as shown here.\n\nNext, our Arduino starts to monitor the fire and smoke status by continuously retrieving the data from the Fire and smoke sensor. If any one of the sensors gets triggered, it will send an SMS Alert to the authorized mobile number instantly as well as trigger the Buzzer alarm with LED indication.\n\nWhile working, there is a possibility of Wi-Fi disconnection due to a Wi-Fi router power outage. To indicate the Wi-Fi disconnection, it brings out the “Network Disconnection image” on the LED Matrix as represented below. Since Wi-Fi connectivity is crucial for sending SMS alerts.\n\nHere is a complete working demonstration of our Fire and Smoke detector using Arduino with SMS Alert.\n\n# Working of Fire and Smoke Alarm System\n\n# GitHub Repository with Code and Circuit\n\n# Similar Fire and Smoke Detection Projects\n\nThese projects offer various approaches to fire and smoke detection using Arduino, ranging from basic alarms to advanced systems with IoT capabilities.\n\nInterfacing Flame Sensor with Arduino\n\nLearn how to interface a flame sensor with Arduino to build a simple fire alarm system that detects fire using infrared light and activates an alert through a buzzer and LED.\n\nHow Does MQ-2 Flammable Gas and Smoke Sensor Work with Arduino?\n\nExplore how to interface the MQ2 gas sensor with Arduino to detect gases like LPG, smoke, and methane, and trigger alerts using LEDs and buzzers for safety applications.\n\nIoT Based Forest Fire Detection System using Arduino and GSM Module\n\nBuild an IoT-based forest fire detection system using Arduino and a GSM module that monitors environmental conditions and sends SMS alerts when a fire is detected.\n\nInterfacing Flame Sensor with Arduino to Build a Fire Alarm System\n\nExplore how to interface a flame sensor with Arduino to detect fire and trigger visual and audio alerts, helping build a basic fire detection system for safety applications.\n\nSimple Smoke Detector Alarm Circuit\n\nExplore a simple smoke detector alarm circuit using a TGS 813 gas sensor that triggers a buzzer when smoke is detected, ideal for basic fire safety applications.\n\n# Complete Project Code\n\n```arduino\n/*==================== Header Files =========================-*/\n#include \"WiFiS3.h\"\n#include \"Arduino_LED_Matrix.h\"\n/*=====================Macros============================-*/\n/*-------------------------------- Pin Definitions -------------------------------------------*/\n#define Smoke_sensor 2\n#define Flame_sensor 6\n#define Green_led 3\n#define Red_led 5\n#define Buzzer 4\n/*=================Object Instantiation ========================-*/\nArduinoLEDMatrix matrix;  \n/*=====================Global variables=======================-*/\n/* --------------------- WiFi Credentials and WiFi status -----------------------------------*/\nconst char *ssid = \"Semicon Media\";      //Your WiFi Router SSID\nconst char *password = \"xxxxxxxxxx\";   // Your WiFi Router password\nint status = WL_IDLE_STATUS;             // Connection status\n/* ---------------------- API credentials and SMS Details ---------------------- */\nconst char* apiKey = \"xxxxxxxxx\";          // Replace with your API key\nconst char* templateID = \"101\";           // Replace with your template ID\nconst char* mobileNumber = \"91xxxxxxxxxx\"; // Replace with the recipient's mobile number with country code (eg : 91XXXXXXXXXX)\nconst char* var1 = \"house\";   // Replace with your custom variable\nconst char* var2 = \"FIRE EMERGENCY. Evacuate now!\";          // Replace with your custom variable\n/* ---------------------- Network Led icons ---------------------- */\nconst uint32_t network_connect_icon[] = { 0x308311, 0xba1b4db0, 0xdb6db6db };\nconst uint32_t network_disconnect_icon[] = { 0x3003a1, 0xb41badb0, 0xdb6db6db };\n/* ---------------------- Network connection animation ---------------------- */\nconst uint32_t network_connection_anime[][4] = {\n { 0x0, 0x0, 0x0, 600 },\n    { 0x0, 0x0, 0x600600, 600 },\n    { 0x0, 0xc00, 0xc06c06c0, 600 },\n    { 0x1, 0x80180d80, 0xd86d86d8, 600 },\n    { 0x300301, 0xb01b0db0, 0xdb6db6db, 660}\n};\n/* ---------------------- Sensor Ststus Variables ---------------------- */\nbool flame_status = false;\nbool smoke_status = true;\n/*======================== User Defined Functions =============================-*/\n/* --------------------------- WiFi connect Function --------------------------- */\nvoid wifi_connect(){\n if (WiFi.status() == WL_NO_MODULE) {\n   Serial.println(\"Communication with WiFi module failed!\");\n   matrix.loadFrame(network_disconnect_icon);\n   while (true);\n }\n Serial.print(\"Connecting to WiFi...\");\n matrix.loadSequence(network_connection_anime);\n matrix.play(true);\n delay(6000);\n while (WiFi.begin(ssid, password) != WL_CONNECTED) {\n   Serial.print(\".\");\n   delay(1000);\n }\n matrix.loadFrame(network_connect_icon);\n \n Serial.println(\"\\nConnected to WiFi!\");\n Serial.print(\"IP Address: \");\n Serial.println(WiFi.localIP());\n}\n/* ------------------------ WiFi reconnect Function ----------------------------- */\nvoid wifi_reconnect(){\n   Serial.println(\"Wifi Reconnecting........\");\n   matrix.loadFrame(network_disconnect_icon);\n   delay(6000);\n   wifi_connect();\n}\n/* ------------------------ Fire & Smoke detect Function ------------------------- */\nbool fire_smoke_detect(){\n flame_status = digitalRead(Flame_sensor);\n smoke_status = digitalRead(Smoke_sensor);\n if(!flame_status || !smoke_status){\n     return true;\n }\n else{\n    return false;\n }\n}\n/* ------------------------ SMS Trigger Function ---------------------------------- */\nvoid trigger_SMS(){\n  if (WiFi.status() == WL_CONNECTED) {\n   WiFiClient client; // Initialize WiFi client\n   \n   String apiUrl = \"/send_sms?ID=\" + String(templateID);\n   Serial.print(\"Connecting to server...\");\n   if (client.connect(\"www.circuitdigest.cloud\", 80)) { // Connect to the server\n     Serial.println(\"connected!\");\n     // Create the HTTP POST request\n     String payload = \"{\\\"mobiles\\\":\\\"\" + String(mobileNumber) + \n                      \"\\\",\\\"var1\\\":\\\"\" + String(var1) + \n                      \"\\\",\\\"var2\\\":\\\"\" + String(var2) + \"\\\"}\";\n     // Send HTTP request headers\n     client.println(\"POST \" + apiUrl + \" HTTP/1.1\");\n     client.println(\"Host: www.circuitdigest.cloud\");\n     client.println(\"Authorization: \" + String(apiKey));\n     client.println(\"Content-Type: application/json\");\n     client.println(\"Content-Length: \" + String(payload.length()));\n     client.println(); // End of headers\n     client.println(payload); // Send the JSON payload\n     // Wait for the response\n     int responseCode = -1; // Variable to store HTTP response code\n     while (client.connected() || client.available()) {\n       if (client.available()) {\n         String line = client.readStringUntil('\\n'); // Read a line from the response\n         Serial.println(line); // Print the response line (for debugging)\n         // Check for the HTTP response code\n         if (line.startsWith(\"HTTP/\")) {\n           responseCode = line.substring(9, 12).toInt(); // Extract response code (e.g., 200, 404)\n           Serial.print(\"HTTP Response Code: \");\n           Serial.println(responseCode);\n         }\n         // Stop reading headers once we reach an empty line\n         if (line == \"\\r\") {\n           break;\n         }\n       }\n     }  \n     // Check response\n     if (responseCode == 200) {\n       Serial.println(\"SMS sent successfully!\");\n     } else {\n       Serial.print(\"Failed to send SMS. Error code: \");\n       Serial.println(responseCode);\n     }\n     client.stop(); // Disconnect from the server\n   } else {\n     Serial.println(\"Connection to server failed!\");\n   }\n } else {\n   Serial.println(\"WiFi not connected!\");\n }\n}\n/* -------------------------- Alarm Trigger Function ----------------------------- */\nvoid trigger_Alarm(){\n   static unsigned long prevmillis = 0;\n   static bool buzzer_state = false;\n   const unsigned long beep_interval = 100;\n    digitalWrite(Red_led, HIGH);\n    digitalWrite(Green_led, LOW);\n    //Buzzer Beep Rate\n    if(millis() - prevmillis >= beep_interval){\n       prevmillis = millis();\n       buzzer_state = !buzzer_state;\n       digitalWrite(Buzzer, buzzer_state);\n    }\n}\n/*=============================== Main Functions =============================-*/\n/* ------------------------- Setup Function --------------------------------*/\nvoid setup() {\n   //Initialize serial and wait for port to open:\n Serial.begin(9600);\n while (!Serial);\n matrix.begin();\n wifi_connect();\n pinMode(Smoke_sensor, INPUT);\n pinMode(Flame_sensor, INPUT);\n pinMode(Green_led, OUTPUT);\n pinMode(Red_led, OUTPUT); \n pinMode(Buzzer, OUTPUT);\n digitalWrite(Green_led, HIGH);\n digitalWrite(Red_led, LOW);\n digitalWrite(Buzzer, LOW);\n}\n/* ---------------------------- Loop Function ---------------------------------- */\nvoid loop() {\n   if(WiFi.status() != WL_CONNECTED){\n       wifi_reconnect();\n   }\n  if(fire_smoke_detect() == true){\n      trigger_SMS();\n      while(1){\n         trigger_Alarm();\n      }\n  }\n}\n```\n\n```arduino\n/*==================== Header Files =========================-*/\n#include \"WiFiS3.h\"\n#include \"Arduino_LED_Matrix.h\"\n/*=====================Macros============================-*/\n/*-------------------------------- Pin Definitions -------------------------------------------*/\n#define Smoke_sensor 2\n#define Flame_sensor 6\n#define Green_led 3\n#define Red_led 5\n#define Buzzer 4\n/*=================Object Instantiation ========================-*/\nArduinoLEDMatrix matrix;  \n/*=====================Global variables=======================-*/\n/* --------------------- WiFi Credentials and WiFi status -----------------------------------*/\nconst char *ssid = \"Semicon Media\";      //Your WiFi Router SSID\nconst char *password = \"xxxxxxxxxx\";   // Your WiFi Router password\nint status = WL_IDLE_STATUS;             // Connection status\n/* ---------------------- API credentials and SMS Details ---------------------- */\nconst char* apiKey = \"xxxxxxxxx\";          // Replace with your API key\nconst char* templateID = \"101\";           // Replace with your template ID\nconst char* mobileNumber = \"91xxxxxxxxxx\"; // Replace with the recipient's mobile number with country code (eg : 91XXXXXXXXXX)\nconst char* var1 = \"house\";   // Replace with your custom variable\nconst char* var2 = \"FIRE EMERGENCY. Evacuate now!\";          // Replace with your custom variable\n/* ---------------------- Network Led icons ---------------------- */\nconst uint32_t network_connect_icon[] = { 0x308311, 0xba1b4db0, 0xdb6db6db };\nconst uint32_t network_disconnect_icon[] = { 0x3003a1, 0xb41badb0, 0xdb6db6db };\n/* ---------------------- Network connection animation ---------------------- */\nconst uint32_t network_connection_anime[][4] = {\n { 0x0, 0x0, 0x0, 600 },\n    { 0x0, 0x0, 0x600600, 600 },\n    { 0x0, 0xc00, 0xc06c06c0, 600 },\n    { 0x1, 0x80180d80, 0xd86d86d8, 600 },\n    { 0x300301, 0xb01b0db0, 0xdb6db6db, 660}\n};\n/* ---------------------- Sensor Ststus Variables ---------------------- */\nbool flame_status = false;\nbool smoke_status = true;\n/*======================== User Defined Functions =============================-*/\n/* --------------------------- WiFi connect Function --------------------------- */\nvoid wifi_connect(){\n if (WiFi.status() == WL_NO_MODULE) {\n   Serial.println(\"Communication with WiFi module failed!\");\n   matrix.loadFrame(network_disconnect_icon);\n   while (true);\n }\n Serial.print(\"Connecting to WiFi...\");\n matrix.loadSequence(network_connection_anime);\n matrix.play(true);\n delay(6000);\n while (WiFi.begin(ssid, password) != WL_CONNECTED) {\n   Serial.print(\".\");\n   delay(1000);\n }\n matrix.loadFrame(network_connect_icon);\n \n Serial.println(\"\\nConnected to WiFi!\");\n Serial.print(\"IP Address: \");\n Serial.println(WiFi.localIP());\n}\n/* ------------------------ WiFi reconnect Function ----------------------------- */\nvoid wifi_reconnect(){\n   Serial.println(\"Wifi Reconnecting........\");\n   matrix.loadFrame(network_disconnect_icon);\n   delay(6000);\n   wifi_connect();\n}\n/* ------------------------ Fire & Smoke detect Function ------------------------- */\nbool fire_smoke_detect(){\n flame_status = digitalRead(Flame_sensor);\n smoke_status = digitalRead(Smoke_sensor);\n if(!flame_status || !smoke_status){\n     return true;\n }\n else{\n    return false;\n }\n}\n/* ------------------------ SMS Trigger Function ---------------------------------- */\nvoid trigger_SMS(){\n  if (WiFi.status() == WL_CONNECTED) {\n   WiFiClient client; // Initialize WiFi client\n   \n   String apiUrl = \"/send_sms?ID=\" + String(templateID);\n   Serial.print(\"Connecting to server...\");\n   if (client.connect(\"www.circuitdigest.cloud\", 80)) { // Connect to the server\n     Serial.println(\"connected!\");\n     // Create the HTTP POST request\n     String payload = \"{\\\"mobiles\\\":\\\"\" + String(mobileNumber) + \n                      \"\\\",\\\"var1\\\":\\\"\" + String(var1) + \n                      \"\\\",\\\"var2\\\":\\\"\" + String(var2) + \"\\\"}\";\n     // Send HTTP request headers\n     client.println(\"POST \" + apiUrl + \" HTTP/1.1\");\n     client.println(\"Host: www.circuitdigest.cloud\");\n     client.println(\"Authorization: \" + String(apiKey));\n     client.println(\"Content-Type: application/json\");\n     client.println(\"Content-Length: \" + String(payload.length()));\n     client.println(); // End of headers\n     client.println(payload); // Send the JSON payload\n     // Wait for the response\n     int responseCode = -1; // Variable to store HTTP response code\n     while (client.connected() || client.available()) {\n       if (client.available()) {\n         String line = client.readStringUntil('\\n'); // Read a line from the response\n         Serial.println(line); // Print the response line (for debugging)\n         // Check for the HTTP response code\n         if (line.startsWith(\"HTTP/\")) {\n           responseCode = line.substring(9, 12).toInt(); // Extract response code (e.g., 200, 404)\n           Serial.print(\"HTTP Response Code: \");\n           Serial.println(responseCode);\n         }\n         // Stop reading headers once we reach an empty line\n         if (line == \"\\r\") {\n           break;\n         }\n       }\n     }  \n     // Check response\n     if (responseCode == 200) {\n       Serial.println(\"SMS sent successfully!\");\n     } else {\n       Serial.print(\"Failed to send SMS. Error code: \");\n       Serial.println(responseCode);\n     }\n     client.stop(); // Disconnect from the server\n   } else {\n     Serial.println(\"Connection to server failed!\");\n   }\n } else {\n   Serial.println(\"WiFi not connected!\");\n }\n}\n/* -------------------------- Alarm Trigger Function ----------------------------- */\nvoid trigger_Alarm(){\n   static unsigned long prevmillis = 0;\n   static bool buzzer_state = false;\n   const unsigned long beep_interval = 100;\n    digitalWrite(Red_led, HIGH);\n    digitalWrite(Green_led, LOW);\n    //Buzzer Beep Rate\n    if(millis() - prevmillis >= beep_interval){\n       prevmillis = millis();\n       buzzer_state = !buzzer_state;\n       digitalWrite(Buzzer, buzzer_state);\n    }\n}\n/*=============================== Main Functions =============================-*/\n/* ------------------------- Setup Function --------------------------------*/\nvoid setup() {\n   //Initialize serial and wait for port to open:\n Serial.begin(9600);\n while (!Serial);\n matrix.begin();\n wifi_connect();\n pinMode(Smoke_sensor, INPUT);\n pinMode(Flame_sensor, INPUT);\n pinMode(Green_led, OUTPUT);\n pinMode(Red_led, OUTPUT); \n pinMode(Buzzer, OUTPUT);\n digitalWrite(Green_led, HIGH);\n digitalWrite(Red_led, LOW);\n digitalWrite(Buzzer, LOW);\n}\n/* ---------------------------- Loop Function ---------------------------------- */\nvoid loop() {\n   if(WiFi.status() != WL_CONNECTED){\n       wifi_reconnect();\n   }\n  if(fire_smoke_detect() == true){\n      trigger_SMS();\n      while(1){\n         trigger_Alarm();\n      }\n  }\n}\n```\n\n# Start a Discussion on:\n\n# Add New Comment\n\nLog in or register to post comments"}
{"title":"How to Build a Smart Helmet using Arduino?","content":"In this project, we’re making an ordinary two-wheeler helmet smart using an RF Transmitter & Receiver. The best part: this Arduino-based smart helmet is simple to build and does not require advanced engineering knowledge or complex components.\n\n# Smart Helmet using Arduino - Quick Overview\n\nBuild Time: 6-8 hours | Cost: $40-60 | Difficulty: Intermediate\n\nWhat You'll Learn: RF communication, Sensor integration, I2C display, Drowsiness detection logic\n\nApplications: Motorcycle safety, Theft prevention, Alcohol detection, Driver alertness monitoring\n\n# Building a Smart Helmet with Arduino\n\nWearing a helmet is a legal requirement in most countries, including India. This life-saving gadget is sure to benefit from tech enhancements.\n\nThis project is split into two parts: the Transmitter (placed in the helmet) and the Receiver (placed in the vehicle). Depending on the features and application, the component list may vary. However, as an overall idea, we will be using an RF transmitter and receiver that operate at 433 MHz. Also, we've built a good number of RF Projects and IoT Projects that might be worth checking out.\n\n# Key Features\n\nTheft Detection\n\nTheft Detection\n\nWear Detection\n\nWear Detection\n\nAlcohol Detection\n\nAlcohol Detection\n\nDrowsiness Detection\n\nDrowsiness Detection\n\nUnlike normal drowsiness detection projects, this is a better smart helmet for accident detection as it uses a special time window logic. It ignores normal blinking but tracks sleep signals within a set period. If multiple signals occur within a defined time window or the eyes remain closed for too long, the system detects drowsiness. This smart approach enhances safety with simple yet effective monitoring.\n\n# Components Required\n\nSince this project has two different circuits (Transmitter and Receiver), I will list the required components for each separately.\n\n# Transmitter Side\n\nArduino UNO R3 - 1\n\nArduino UNO R3 - 1\n\n433 MHz RF Transmitter - 1\n\n433 MHz RF Transmitter - 1\n\nIR Sensor - 2 (one for wear detection and another for drowsiness detection)\n\nIR Sensor - 2 (one for wear detection and another for drowsiness detection)\n\nMQ-3 Sensor - 1 (for alcohol detection)\n\nMQ-3 Sensor - 1 (for alcohol detection)\n\nLED & Buzzer - 1 each (for warnings)\n\nLED & Buzzer - 1 each (for warnings)\n\nAny battery source for powering the setup\n\nAny battery source for powering the setup\n\nHelmet for demo purpose\n\nHelmet for demo purpose\n\nBreadboard - 1\n\nBreadboard - 1\n\nConnecting wires - required quantity\n\nConnecting wires - required quantity\n\n# Receiver Side\n\nArduino UNO R3 - 1\n\nArduino UNO R3 - 1\n\n433 MHz RF Receiver - 1\n\n433 MHz RF Receiver - 1\n\n16x2 LCD Display with I2C Module - 1\n\n16x2 LCD Display with I2C Module - 1\n\n1-Channel Relay Module - 1 (for turning the engine on & off)\n\n1-Channel Relay Module - 1 (for turning the engine on & off)\n\nLED & Buzzer - 1 each (for warnings)\n\nLED & Buzzer - 1 each (for warnings)\n\nBreadboard - 1\n\nBreadboard - 1\n\nConnecting wires - required quantity\n\nConnecting wires - required quantity\n\n# Optional\n\nFor demonstration purposes, we will be using a separate BO motor with a separate battery power source.\n\nThis completes the required components list. As usual, the list is completely customizable according to your requirements and ideas. You are not limited to the list above.\n\nBefore proceeding to the next step, kindly verify the working of each and every component.\n\nWith this, let's move to the next step.\n\n# Circuit Diagram and Assembly\n\nFirst, let's take a look at the transmitter side. The complexity here is that we need to fix the circuit in a mobile and remote place, like a helmet. So, simplifying the circuit is crucial to make it compact and reliable.\n\n# Transmitter Section\n\nThe circuit diagram for this smart helmet project is simple and easy to understand, but the assembly can get a bit challenging.\n\nHere, we planned to use three sensors: two IR obstacle detection sensors (for sleep detection and wear detection) and an MQ3 alcohol detection sensor. All three require a 5V DC input, so with the help of some external wires, I made a parallel connection between the VCC and GND of all the sensors, making it a single input. Similarly, I soldered an extra wire at the output of each sensor so that it would be easy to attach to the breadboard with a minimal footprint. If you are a beginner, you can check out our Arduino IR sensor and Arduino MQ3 sensor tutorials to understand more about these sensors and how they work with Arduino.\n\nThe length of the wires was carefully calculated while placing all the sensors in their actual positions on the helmet. The sensors’ outputs are connected to the analog input pins as follows:\n\nMQ3 (Alcohol Detection) → A0\n\nMQ3 (Alcohol Detection) → A0\n\nWear Detection Sensor → A1\n\nWear Detection Sensor → A1\n\nSleep Detection Sensor → A2\n\nSleep Detection Sensor → A2\n\nYou can refer to the image below to understand the actual wiring of the sensors in the helmet.\n\nTo make the installation simple and efficient, I used an old cardboard box and made appropriate cutouts. The placement of components depends entirely on the type of helmet and specific requirements.\n\nI have used a half-size breadboard for the main circuit connections. Here, I connected the RF transmitter module, LED, buzzer, and all sensor connections. The RF transmitter module was powered with 5V, just like the sensor network.\n\nThe 12th pin was connected to the data pin of the transmitter module.\n\nThe 12th pin was connected to the data pin of the transmitter module.\n\nThe LED and buzzer were connected to the same I/O pin, pin 7, with a 1KΩ current-limiting resistor.\n\nThe LED and buzzer were connected to the same I/O pin, pin 7, with a 1KΩ current-limiting resistor.\n\nYou can refer to the image below for a clearer view of the circuit connections and placement in the helmet.\n\nFor powering the circuit, I used a 2-cell lithium battery.\n\nFinally, coming to the antenna of the transmitter module, I used an online calculator to determine the length of the antenna wire. The approximate value was 17 cm.\n\nBelow you can see the assembled image of the circuit connection alone for more clarification\n\nWith this, the transmitter part is complete.\n\n# Receiver Section\n\nNow, moving on to the receiver section, which is also a simple circuit. The main components used here are:\n\nLCD with I2C\n\nLCD with I2C\n\nArduino Uno\n\nArduino Uno\n\nRF receiver module\n\nRF receiver module\n\nRelay module\n\nRelay module\n\nBuzzer and LED for indication\n\nBuzzer and LED for indication\n\nBelow, you can see the circuit diagram of the receiver section. If you want to learn more about these components and how they work with Arduino, you can check out our Arduino LCD display, Arduino RF module, and Arduino relay module tutorials.\n\nThere are a total of four connections from the Arduino I/O pins:\n\nRelay → Pin 4\n\nRelay → Pin 4\n\nLED & Buzzer → Pin 5\n\nLED & Buzzer → Pin 5\n\nI2C Display Module → SDA (A4), SCL (A5)\n\nI2C Display Module → SDA (A4), SCL (A5)\n\nRF Receiver Module → Pin 11 (Data Pin)\n\nRF Receiver Module → Pin 11 (Data Pin)\n\nAll the modules are powered with 5V from the Arduino. Below is the assembled image of the receiver side.\n\nJust like the transmitter side, the receiver also requires an antenna, so I added the same 17 cm wire.\n\nAdditionally, I made one extra modification by adding an extra battery and motor to the relay for demonstration purposes. The motor's switch was connected to the NO (Normally Open) and Common terminals of the relay.\n\nWith this, the circuit connection and assembly of both the transmitter and receiver sides are completed.\n\nNext, let's move on to the coding part.\n\n# Transmitter Code Implementation\n\nHere, the program continuously monitors sensor inputs, evaluates drowsiness based on a time-window logic, and alerts the user if drowsiness is detected. The processed data is transmitted wirelessly at regular intervals.\n\n# Libraries Used\n\nRH_ASK – Sub library of RadioHead that handles RF communication using the ASK (Amplitude Shift Keying) protocol. (External Library)\nSPI – Required by the RadioHead library for low-level communication. (Built-in Library)\n\n# Variables and Constants\n\nDebugging\n\nDEBUG_MODE – Enables/disables debug messages in Serial Monitor.\n\nDebugging\n\nDEBUG_MODE – Enables/disables debug messages in Serial Monitor.\n\nDEBUG_MODE – Enables/disables debug messages in Serial Monitor.\n\nSensor Pins\n\nalcoholSensorPin = A0 (Reads alcohol sensor input)\n\nwearSensorPin = A1 ( Checks if the helmet is worn)\n\nsleepSensorPin = A2 ( Detects micro-sleep events)\n\nbuzzerPin = 7 (Controls the buzzer)\n\nSensor Pins\n\nalcoholSensorPin = A0 (Reads alcohol sensor input)\n\nalcoholSensorPin = A0 (Reads alcohol sensor input)\n\nwearSensorPin = A1 ( Checks if the helmet is worn)\n\nwearSensorPin = A1 ( Checks if the helmet is worn)\n\nsleepSensorPin = A2 ( Detects micro-sleep events)\n\nsleepSensorPin = A2 ( Detects micro-sleep events)\n\nbuzzerPin = 7 (Controls the buzzer)\n\nbuzzerPin = 7 (Controls the buzzer)\n\nDrowsiness Detection\n\ndrowsinessThreshold = 5 (Number of sleep detections required within a time window to confirm drowsiness)\n\ndrowsinessTimeWindow = 10000 ms (10 seconds window for evaluating drowsiness)\n\nresetTime = 5000 ms ( Resets drowsiness state if no sleep signals occur within 5 seconds)\n\nsleepTimestamps[] – Stores timestamps of detected sleep signals\n\nsleepIndex – Tracks the circular buffer index\n\nisDrowsy – Stores the current drowsiness status\n\nDrowsiness Detection\n\ndrowsinessThreshold = 5 (Number of sleep detections required within a time window to confirm drowsiness)\n\ndrowsinessThreshold = 5 (Number of sleep detections required within a time window to confirm drowsiness)\n\ndrowsinessTimeWindow = 10000 ms (10 seconds window for evaluating drowsiness)\n\ndrowsinessTimeWindow = 10000 ms (10 seconds window for evaluating drowsiness)\n\nresetTime = 5000 ms ( Resets drowsiness state if no sleep signals occur within 5 seconds)\n\nresetTime = 5000 ms ( Resets drowsiness state if no sleep signals occur within 5 seconds)\n\nsleepTimestamps[] – Stores timestamps of detected sleep signals\n\nsleepTimestamps[] – Stores timestamps of detected sleep signals\n\nsleepIndex – Tracks the circular buffer index\n\nsleepIndex – Tracks the circular buffer index\n\nisDrowsy – Stores the current drowsiness status\n\nisDrowsy – Stores the current drowsiness status\n\nRF Communication\n\nrf_driver – RF communication object\n\nlastSendTime – Tracks the last transmission time\n\nsendInterval = 50 ms (Sends data every 50 milliseconds)\n\nRF Communication\n\nrf_driver – RF communication object\n\nrf_driver – RF communication object\n\nlastSendTime – Tracks the last transmission time\n\nlastSendTime – Tracks the last transmission time\n\nsendInterval = 50 ms (Sends data every 50 milliseconds)\n\nsendInterval = 50 ms (Sends data every 50 milliseconds)\n\n# Setup Function\n\n1. Debug Mode Initialization (if enabled, starts Serial Monitor at 9600 baud rate).\n\n```arduino\n#if DEBUG_MODE\n Serial.begin(9600);  // Start Serial Monitor\n Serial.println(\"System Initialized...\");\n#endif\n```\n\n```arduino\n#if DEBUG_MODE\n Serial.begin(9600);  // Start Serial Monitor\n Serial.println(\"System Initialized...\");\n#endif\n```\n\n2. RF Module Initialization – Calls rf_driver.init() to set up RF communication.\n rf_driver.init();\n\n3. Pin Configuration –\n\npinMode(INPUT) for all sensor pins.\n\npinMode(INPUT) for all sensor pins.\n\npinMode(OUTPUT) for the buzzer.\n\npinMode(OUTPUT) for the buzzer.\n\nEnsures the buzzer is OFF initially.\n\nEnsures the buzzer is OFF initially.\n\n```arduino\npinMode(wearSensorPin, INPUT);\npinMode(alcoholSensorPin, INPUT);\npinMode(sleepSensorPin, INPUT);\npinMode(buzzerPin, OUTPUT);\ndigitalWrite(buzzerPin, LOW);  // Ensure buzzer is OFF initially\n```\n\n```arduino\npinMode(wearSensorPin, INPUT);\npinMode(alcoholSensorPin, INPUT);\npinMode(sleepSensorPin, INPUT);\npinMode(buzzerPin, OUTPUT);\ndigitalWrite(buzzerPin, LOW);  // Ensure buzzer is OFF initially\n```\n\n# Loop Function\n\nThe loop function continuously reads sensor inputs and processes the data for drowsiness detection, buzzer activation, and RF transmission. The alcohol sensor is read to determine alcohol presence, the sleep sensor checks for drowsiness-related signals, and the helmet sensor verifies if the helmet is worn. These values are essential for determining the rider’s condition.\n\n```arduino\nint alcoholLevel = !digitalRead(alcoholSensorPin);\n int sleepSignal = !digitalRead(sleepSensorPin);\n int helmetStatus = !digitalRead(wearSensorPin);\n```\n\n```arduino\nint alcoholLevel = !digitalRead(alcoholSensorPin);\n int sleepSignal = !digitalRead(sleepSensorPin);\n int helmetStatus = !digitalRead(wearSensorPin);\n```\n\nFor drowsiness detection, the system uses a circular buffer to store timestamps of detected sleep signals. If a sleep signal is recorded, its timestamp is stored in the buffer. The system then checks if the number of sleep signals within the specified drowsinessTimeWindow exceeds the drowsinessThreshold. If this condition is met, drowsiness is detected, and isDrowsy is set to true. If no sleep signals occur within resetTime, the system resets isDrowsy to false, ensuring normal blinking does not trigger false alarms.\n\n```arduino\nif (sleepSignal) {\n   lastSleepDetectionTime = currentMillis;\n   // Store the current timestamp in the circular buffer\n   sleepTimestamps[sleepIndex] = currentMillis;\n   sleepIndex = (sleepIndex + 1) % drowsinessThreshold;\n   // Check if there are 'drowsinessThreshold' sleep detections within 'drowsinessTimeWindow'\n   int count = 0;\n   for (int i = 0; i < drowsinessThreshold; i++) {\n     if (currentMillis - sleepTimestamps[i] <= drowsinessTimeWindow) {\n       count++;\n     }\n   }\n   \n   isDrowsy = (count >= drowsinessThreshold);\n }\n // **Reset drowsiness detection if no sleep signals for resetTime**\n if (currentMillis - lastSleepDetectionTime > resetTime) {\n   isDrowsy = false;\n }\n#if DEBUG_MODE\n Serial.print(\"Drowsiness Detected: \");\n Serial.println(isDrowsy ? \"YES\" : \"NO\");\n#endif\n```\n\n```arduino\nif (sleepSignal) {\n   lastSleepDetectionTime = currentMillis;\n   // Store the current timestamp in the circular buffer\n   sleepTimestamps[sleepIndex] = currentMillis;\n   sleepIndex = (sleepIndex + 1) % drowsinessThreshold;\n   // Check if there are 'drowsinessThreshold' sleep detections within 'drowsinessTimeWindow'\n   int count = 0;\n   for (int i = 0; i < drowsinessThreshold; i++) {\n     if (currentMillis - sleepTimestamps[i] <= drowsinessTimeWindow) {\n       count++;\n     }\n   }\n   \n   isDrowsy = (count >= drowsinessThreshold);\n }\n // **Reset drowsiness detection if no sleep signals for resetTime**\n if (currentMillis - lastSleepDetectionTime > resetTime) {\n   isDrowsy = false;\n }\n#if DEBUG_MODE\n Serial.print(\"Drowsiness Detected: \");\n Serial.println(isDrowsy ? \"YES\" : \"NO\");\n#endif\n```\n\nThe buzzer activates when drowsiness is detected, alerting the rider. If isDrowsy is true, the buzzer turns ON; otherwise, it remains OFF. This immediate feedback helps prevent accidents due to drowsiness.\n\n```arduino\n// **Activate Buzzer on Drowsiness Detection**\n if (isDrowsy) {\n   digitalWrite(buzzerPin, HIGH);  // Turn ON buzzer\n } else {\n   digitalWrite(buzzerPin, LOW);   // Turn OFF buzzer\n }\n```\n\n```arduino\n// **Activate Buzzer on Drowsiness Detection**\n if (isDrowsy) {\n   digitalWrite(buzzerPin, HIGH);  // Turn ON buzzer\n } else {\n   digitalWrite(buzzerPin, LOW);   // Turn OFF buzzer\n }\n```\n\nFor RF transmission, if the defined sendInterval has elapsed, the system constructs a comma-separated data string containing sensor values. This string is converted into a character array and transmitted wirelessly using rf_driver.send(). This ensures continuous monitoring and communication with external systems.\n\n```arduino\n// **Send data at regular intervals**\n if (currentMillis - lastSendTime >= sendInterval) {\n   lastSendTime = currentMillis;\n   // Convert sensor values to a formatted string\n   String data = String(helmetStatus) + \",\" + String(alcoholLevel) + \",\" + String(isDrowsy ? 1 : 0);\n   // Convert string to char array for RF transmission\n   char msg[data.length() + 1];\n   data.toCharArray(msg, data.length() + 1);\n   // Send data via RF\n   rf_driver.send((uint8_t *)msg, strlen(msg));\n   rf_driver.waitPacketSent();\n```\n\n```arduino\n// **Send data at regular intervals**\n if (currentMillis - lastSendTime >= sendInterval) {\n   lastSendTime = currentMillis;\n   // Convert sensor values to a formatted string\n   String data = String(helmetStatus) + \",\" + String(alcoholLevel) + \",\" + String(isDrowsy ? 1 : 0);\n   // Convert string to char array for RF transmission\n   char msg[data.length() + 1];\n   data.toCharArray(msg, data.length() + 1);\n   // Send data via RF\n   rf_driver.send((uint8_t *)msg, strlen(msg));\n   rf_driver.waitPacketSent();\n```\n\nA small delay of 10ms is included at the end of the loop to prevent excessive processing load while maintaining responsiveness.\n\nNext, let's take a look at the receiver code.\n\n# Receiver Code Implementation\n\nThe Receiver System communicates wirelessly using an RF module with the Transmitter System and displays status information on an LCD screen. If the rider is not wearing the helmet or has consumed alcohol, the vehicle ignition is disabled. A buzzer alerts the user in case of drowsiness or safety violations.\n\n# Libraries Used\n\nWire.h: Used for I2C communication, essential for LCD operation.(Built-in Library)\n\nWire.h: Used for I2C communication, essential for LCD operation.(Built-in Library)\n\nLiquidCrystal_I2C.h: Controls the 16x2 LCD display via the I2C interface. (External Library)\n\nLiquidCrystal_I2C.h: Controls the 16x2 LCD display via the I2C interface. (External Library)\n\nRH_ASK.h: Enables communication with an RF module, using the RadioHead ASK (Amplitude Shift Keying) protocol. (External Library)\n\nRH_ASK.h: Enables communication with an RF module, using the RadioHead ASK (Amplitude Shift Keying) protocol. (External Library)\n\nSPI.h: Required for RF communication, used internally by RH_ASK. (Built-in Library)\n\nSPI.h: Required for RF communication, used internally by RH_ASK. (Built-in Library)\n\n# Variables and Constants\n\nHardware Configuration\n\nignitionRelay (Pin 4): Controls the vehicle ignition (ON/OFF state).\n\nbuzzerPin (Pin 5): Controls the buzzer for alerting the rider.\n\nlcd (0x27, 16, 2): LCD initialization with I2C address 0x27.\n\nrf_driver (2000, 11, 12, 0): Configures the RF module (2000 bps baud rate, RX on pin 11, TX on pin 12).\n\nHardware Configuration\n\nignitionRelay (Pin 4): Controls the vehicle ignition (ON/OFF state).\n\nignitionRelay (Pin 4): Controls the vehicle ignition (ON/OFF state).\n\nbuzzerPin (Pin 5): Controls the buzzer for alerting the rider.\n\nbuzzerPin (Pin 5): Controls the buzzer for alerting the rider.\n\nlcd (0x27, 16, 2): LCD initialization with I2C address 0x27.\n\nlcd (0x27, 16, 2): LCD initialization with I2C address 0x27.\n\nrf_driver (2000, 11, 12, 0): Configures the RF module (2000 bps baud rate, RX on pin 11, TX on pin 12).\n\nrf_driver (2000, 11, 12, 0): Configures the RF module (2000 bps baud rate, RX on pin 11, TX on pin 12).\n\nData Variables\n\nstr_helmet, str_alcohol, str_sleep: Store received sensor values as strings.\n\nhelmetStatus, alcoholLevel, sleepStatus: Store integer-converted sensor readings.\n\nengineState: Boolean representing whether the engine should be ON or OFF.\n\nlastReceivedTime: Tracks the last received RF data timestamp.\n\ntimeout: Defines the period (5000ms) before showing a system offline message.\n\npage, lastPage: Manage the LCD page display system.\n\nlastPageSwitch, pageInterval: Handle page switching every 3 seconds.\n\nData Variables\n\nstr_helmet, str_alcohol, str_sleep: Store received sensor values as strings.\n\nstr_helmet, str_alcohol, str_sleep: Store received sensor values as strings.\n\nhelmetStatus, alcoholLevel, sleepStatus: Store integer-converted sensor readings.\n\nhelmetStatus, alcoholLevel, sleepStatus: Store integer-converted sensor readings.\n\nengineState: Boolean representing whether the engine should be ON or OFF.\n\nengineState: Boolean representing whether the engine should be ON or OFF.\n\nlastReceivedTime: Tracks the last received RF data timestamp.\n\nlastReceivedTime: Tracks the last received RF data timestamp.\n\ntimeout: Defines the period (5000ms) before showing a system offline message.\n\ntimeout: Defines the period (5000ms) before showing a system offline message.\n\npage, lastPage: Manage the LCD page display system.\n\npage, lastPage: Manage the LCD page display system.\n\nlastPageSwitch, pageInterval: Handle page switching every 3 seconds.\n\nlastPageSwitch, pageInterval: Handle page switching every 3 seconds.\n\nSetup Function\n\nThe setup function begins by initializing serial communication at a baud rate of 115200, ensuring efficient data transmission for debugging and monitoring. It then initializes the RF module, enabling wireless communication for receiving helmet, alcohol, and sleep status data. The LCD screen is also set up at this stage, displaying the startup message \"Smart Helmet\" to indicate that the system is powered on.\n\n```arduino\nlcd.begin();\n lcd.backlight();\n lcd.setCursor(0, 0);\n lcd.print(\"Smart Helmet\");\n delay(1000);\n lcd.clear();\n```\n\n```arduino\nlcd.begin();\n lcd.backlight();\n lcd.setCursor(0, 0);\n lcd.print(\"Smart Helmet\");\n delay(1000);\n lcd.clear();\n```\n\nNext, the ignitionRelay and buzzerPin are configured as output pins, allowing the system to control the vehicle ignition and alert mechanisms. By default, the vehicle remains OFF, and the buzzer stays silent to prevent unnecessary alerts during startup. Finally, the system introduces a brief delay before clearing the LCD screen, ensuring a smooth transition into the main loop function.\n\n```arduino\npinMode(ignitionRelay, OUTPUT);\npinMode(buzzerPin, OUTPUT);\ndigitalWrite(ignitionRelay, LOW); // Default: Vehicle OFF\ndigitalWrite(buzzerPin, LOW); // Default: No alert\n```\n\n```arduino\npinMode(ignitionRelay, OUTPUT);\npinMode(buzzerPin, OUTPUT);\ndigitalWrite(ignitionRelay, LOW); // Default: Vehicle OFF\ndigitalWrite(buzzerPin, LOW); // Default: No alert\n```\n\nLoop Function\n\nThe loop function is responsible for continuously receiving and processing RF data. It first reads incoming RF signals and extracts key sensor values, including helmet status, alcohol level, and sleep status. These values are received as strings and are converted into integers for further processing.\n\n```arduino\nif (rf_driver.recv(buf, &buflen)) {\n   String str_out = String((char*)buf);\n   lastReceivedTime = millis(); // Update last received time\n   // Extract values from received string\n   int comma1 = str_out.indexOf(',');\n   int comma2 = str_out.lastIndexOf(',');\n   if (comma1 > 0 && comma2 > comma1) {\n     str_helmet = str_out.substring(0, comma1);\n     str_alcohol = str_out.substring(comma1 + 1, comma2);\n     str_sleep = str_out.substring(comma2 + 1);\n     helmetStatus = str_helmet.toInt();\n     alcoholLevel = str_alcohol.toInt();\n     sleepStatus = str_sleep.toInt();\n     // Control vehicle ignition based on conditions\n     engineState = (helmetStatus && !alcoholLevel);\n     digitalWrite(ignitionRelay, engineState);\n     // Activate buzzer if sleep or alcohol detected\n     digitalWrite(buzzerPin, (sleepStatus || alcoholLevel || page == 99) ? HIGH : LOW);\n     Serial.print(\"Received: \");\n     Serial.println(str_out);\n   }\n }\n```\n\n```arduino\nif (rf_driver.recv(buf, &buflen)) {\n   String str_out = String((char*)buf);\n   lastReceivedTime = millis(); // Update last received time\n   // Extract values from received string\n   int comma1 = str_out.indexOf(',');\n   int comma2 = str_out.lastIndexOf(',');\n   if (comma1 > 0 && comma2 > comma1) {\n     str_helmet = str_out.substring(0, comma1);\n     str_alcohol = str_out.substring(comma1 + 1, comma2);\n     str_sleep = str_out.substring(comma2 + 1);\n     helmetStatus = str_helmet.toInt();\n     alcoholLevel = str_alcohol.toInt();\n     sleepStatus = str_sleep.toInt();\n     // Control vehicle ignition based on conditions\n     engineState = (helmetStatus && !alcoholLevel);\n     digitalWrite(ignitionRelay, engineState);\n     // Activate buzzer if sleep or alcohol detected\n     digitalWrite(buzzerPin, (sleepStatus || alcoholLevel || page == 99) ? HIGH : LOW);\n     Serial.print(\"Received: \");\n     Serial.println(str_out);\n   }\n }\n```\n\nBased on the received data, the system controls the vehicle ignition. The engine is allowed to start only if the rider is wearing a helmet and no alcohol is detected. If either condition is not met, the ignition remains off. Additionally, the buzzer is activated if alcohol is detected or the rider shows signs of drowsiness, alerting the user immediately.\n\nTo ensure reliability, the code also implements timeout handling. If no data is received for more than five seconds, the system considers itself offline. In this case, the LCD screen displays a \"System Offline\" message, and the buzzer is triggered to alert the rider.\n\n```arduino\nif (millis() - lastReceivedTime > timeout) {\n   if (page != 99) {\n     digitalWrite(buzzerPin, HIGH);\n     lcd.clear();\n     lcd.print(\"No Data Received\");\n     lcd.setCursor(0, 1);\n     lcd.print(\"System Offline\");\n     page = 99;\n   }\n   return;\n }\n```\n\n```arduino\nif (millis() - lastReceivedTime > timeout) {\n   if (page != 99) {\n     digitalWrite(buzzerPin, HIGH);\n     lcd.clear();\n     lcd.print(\"No Data Received\");\n     lcd.setCursor(0, 1);\n     lcd.print(\"System Offline\");\n     page = 99;\n   }\n   return;\n }\n```\n\nThe LCD display is managed through a page-switching mechanism. The system cycles through two display pages every three seconds. Page 0 displays the helmet and alcohol status, while Page 1 provides information on the rider’s drowsiness and the engine's state. The display is updated only when necessary to optimize performance and reduce unnecessary screen refreshes.\n\n```arduino\nswitch (page) {\n   case 0:  // Page 1: Helmet, Alcohol, and Sleep Status\n     lcd.setCursor(0, 0);\n     lcd.print(\"Helmet: \");\n     lcd.print(helmetStatus == 1 ? \"Yes\" : \"No \");\n     lcd.setCursor(0, 1);\n     lcd.print(\"Alcohol: \");\n     lcd.print(alcoholLevel == 1 ? \"Yes\" : \"No \");\n     break;\n   case 1:  // Page 2: Sleep Status and Engine State\n     lcd.setCursor(0, 0);\n     lcd.print(\"Sleep: \");\n     lcd.print(sleepStatus == 1 ? \"Yes\" : \"No \");\n     lcd.setCursor(0, 1);\n     lcd.print(\"Engine: \");\n     lcd.print(engineState ? \"ON \" : \"OFF\");\n     break;\n }\n```\n\n```arduino\nswitch (page) {\n   case 0:  // Page 1: Helmet, Alcohol, and Sleep Status\n     lcd.setCursor(0, 0);\n     lcd.print(\"Helmet: \");\n     lcd.print(helmetStatus == 1 ? \"Yes\" : \"No \");\n     lcd.setCursor(0, 1);\n     lcd.print(\"Alcohol: \");\n     lcd.print(alcoholLevel == 1 ? \"Yes\" : \"No \");\n     break;\n   case 1:  // Page 2: Sleep Status and Engine State\n     lcd.setCursor(0, 0);\n     lcd.print(\"Sleep: \");\n     lcd.print(sleepStatus == 1 ? \"Yes\" : \"No \");\n     lcd.setCursor(0, 1);\n     lcd.print(\"Engine: \");\n     lcd.print(engineState ? \"ON \" : \"OFF\");\n     break;\n }\n```\n\nThis smart helmet system ensures rider safety by enforcing helmet usage and preventing vehicle ignition in unsafe conditions. The next step is to upload the code and test the system in real-world conditions.\n\n# How Does It Work\n\nOnce both the transmitter and receiver sections are uploaded with the appropriate code, we can check their functionality. As usual, for understanding the code, you can check out the flowchart in our GitHub repo to understand the working easily.\n\nThe working of this project is simple. There are a total of four features to check out. I will be adding the detailed working of all four features below.\n\n# Theft Detection\n\nThe working of this theft detection system is simple. When there is no data received from the transmitter, it means the helmet is too far from the two-wheeler. In this way, we can implement this feature of theft detection.\n\nBelow, you can see the theft detection in the smart helmet.\n\nHere, I unplugged the power of the transmitter section so that the receiver can't receive the data. According to our logic, this triggers the theft detection. During this time, the warning LED and buzzer turn ON to alert the surroundings. After reconnecting, it will work properly.\n\n# Wear Detection\n\nFor wear detection, we are using data from an IR obstacle sensor placed near the MQ3 sensor at the cheek area. So, while wearing it, it is possible to determine whether the helmet is worn or not.\n\nIn the above image,, the system is turned ON by connecting the battery to the circuit. But the helmet isn’t worn yet, so we can see \"NO\" near the helmet indicator on the display.\n\nOnce the helmet is worn, the receiver gets the data, triggering the engine to turn ON. You can see that the demo motor connected to the relay of the receiver starts rotating, and the expected variables are updated on the LCD display.\n\nAbove, you can see the display result while the person is wearing the helmet and the engine is turned ON.\n\n# Sleep Detection\n\nFor this test, we asked the person to avoid blinking, which results in no triggers. But if the blinking time is slow or the eyes remain closed, the trigger starts. The user will then hear the buzzer turn ON along with the warning light, and the status will be displayed on the screen.\n\nAbove, you can see the collage image that describes the process when sleep is detected.\n\n# Alcohol Detection\n\nThis is also a simple demonstration where we used IsoPropyl Alcohol (IPA) for testing. Similar to wear detection, if the user is detected as having consumed alcohol, the vehicle won’t start.\n\nAbove, you can see the demonstration of alcohol detection. The engine can only be started once the sensor stops detecting alcohol.\n\n# Sensor Setup and Calibration\n\nEnsure every sensor’s potentiometer is set properly depending on the environment and conditions. Since every sensor module consists of a comparator circuit made using an OPAMP, it needs to have a proper threshold set using the potentiometer.\n\nEnsure every sensor’s potentiometer is set properly depending on the environment and conditions. Since every sensor module consists of a comparator circuit made using an OPAMP, it needs to have a proper threshold set using the potentiometer.\n\nThe placement of sensors is important to ensure proper functioning of the system.\n\nThe placement of sensors is important to ensure proper functioning of the system.\n\n# Project Code & Circuit on GitHub\n\n# Similar Drowsiness Detection Projects\n\nExplore similar DIY projects that use techniques like facial recognition and heart rate monitoring to detect driver drowsiness and keep you safe with timely alerts on the road.\n\nArduino based Driver Drowsiness Detection & Alerting System\n\nAn Arduino Nano-based system that uses an eye blink sensor to detect driver drowsiness and sounds a buzzer to alert them. A simple, low-cost solution to help prevent drowsiness-related accidents.\n\nDrowsiness Detection System\n\nLearn how to build a Drowsiness Detection System using Raspberry Pi and Arduino that monitors facial cues, steering behavior, and EEG signals to alert sleepy drivers and prevent road accidents.\n\niN-Car Drowsiness Detection and Alert System with CAN Bus Integration\n\nDemonstrating drowsiness detection system that uses facial recognition, motion, and ECG sensors to monitor driver alertness. It triggers timely alerts to help prevent accidents caused by drowsiness.\n\n# Complete Project Code\n\n```arduino\n/*\n Smart Helmet Reciever code\n Features:\n - Wireless communication via RF module (2000 bps, RX pin 11, TX pin 12)\n - LCD display (I2C Address: 0x27)\n - Ignition control based on helmet status and alcohol detection\n - Buzzer alerts for sleep detection or alcohol presence\n - Automatic page switching on LCD every 3 seconds\n - Timeout alert when no data is received for 5 seconds\n*/\n#include <Wire.h>\n#include <LiquidCrystal_I2C.h>\n#include <RH_ASK.h>\n#include <SPI.h>\n// Initialize LCD display and RF module\nLiquidCrystal_I2C lcd(0x27, 16, 2);\nRH_ASK rf_driver(2000, 11, 12, 0);\n// Define pin connections\nconst int ignitionRelay = 4;\nconst int buzzerPin = 5;\n// Variables to store received data\nString str_helmet = \"0\", str_alcohol = \"0\", str_sleep = \"0\";\nint helmetStatus = 0, alcoholLevel = 0, sleepStatus = 0;\nbool engineState = false;\n// Timeout and page switching variables\nunsigned long lastReceivedTime = 0;\nconst unsigned long timeout = 5000;\nint page = 0, lastPage = -1;\nunsigned long lastPageSwitch = 0;\nconst unsigned long pageInterval = 3000;\nvoid setup() {\n Serial.begin(115200); // Initialize serial communication\n rf_driver.init(); // Initialize RF module\n pinMode(ignitionRelay, OUTPUT);\n pinMode(buzzerPin, OUTPUT);\n digitalWrite(ignitionRelay, LOW); // Default: Vehicle OFF\n digitalWrite(buzzerPin, LOW); // Default: No alert\n lcd.begin();\n lcd.backlight();\n lcd.setCursor(0, 0);\n lcd.print(\"Smart Helmet\");\n delay(1000);\n lcd.clear();\n}\nvoid loop() {\n uint8_t buf[20];\n uint8_t buflen = sizeof(buf);\n // Check if RF data is received\n if (rf_driver.recv(buf, &buflen)) {\n   String str_out = String((char*)buf);\n   lastReceivedTime = millis(); // Update last received time\n   // Extract values from received string\n   int comma1 = str_out.indexOf(',');\n   int comma2 = str_out.lastIndexOf(',');\n   if (comma1 > 0 && comma2 > comma1) {\n     str_helmet = str_out.substring(0, comma1);\n     str_alcohol = str_out.substring(comma1 + 1, comma2);\n     str_sleep = str_out.substring(comma2 + 1);\n     helmetStatus = str_helmet.toInt();\n     alcoholLevel = str_alcohol.toInt();\n     sleepStatus = str_sleep.toInt();\n     // Control vehicle ignition based on conditions\n     engineState = (helmetStatus && !alcoholLevel);\n     digitalWrite(ignitionRelay, engineState);\n     // Activate buzzer if sleep or alcohol detected\n     digitalWrite(buzzerPin, (sleepStatus || alcoholLevel || page == 99) ? HIGH : LOW);\n     Serial.print(\"Received: \");\n     Serial.println(str_out);\n   }\n }\n // Handle timeout if no data received for a set time\n if (millis() - lastReceivedTime > timeout) {\n   if (page != 99) {\n     digitalWrite(buzzerPin, HIGH);\n     lcd.clear();\n     lcd.print(\"No Data Received\");\n     lcd.setCursor(0, 1);\n     lcd.print(\"System Offline\");\n     page = 99;\n   }\n   return;\n }\n // Handle automatic page switching\n if (millis() - lastPageSwitch > pageInterval) {\n   lastPageSwitch = millis();\n   page = (page + 1) % 2;\n   delay(200); // Small delay to prevent rapid switching\n }\n // Clear LCD only when switching pages\n if (page != lastPage) {\n   lcd.clear();\n   lastPage = page;\n }\n // Display different pages based on current page index\n switch (page) {\n   case 0:  // Page 1: Helmet, Alcohol, and Sleep Status\n     lcd.setCursor(0, 0);\n     lcd.print(\"Helmet: \");\n     lcd.print(helmetStatus == 1 ? \"Yes\" : \"No \");\n     lcd.setCursor(0, 1);\n     lcd.print(\"Alcohol: \");\n     lcd.print(alcoholLevel == 1 ? \"Yes\" : \"No \");\n     break;\n   case 1:  // Page 2: Sleep Status and Engine State\n     lcd.setCursor(0, 0);\n     lcd.print(\"Sleep: \");\n     lcd.print(sleepStatus == 1 ? \"Yes\" : \"No \");\n     lcd.setCursor(0, 1);\n     lcd.print(\"Engine: \");\n     lcd.print(engineState ? \"ON \" : \"OFF\");\n     break;\n }\n}\n```\n\n```arduino\n/*\n Smart Helmet Reciever code\n Features:\n - Wireless communication via RF module (2000 bps, RX pin 11, TX pin 12)\n - LCD display (I2C Address: 0x27)\n - Ignition control based on helmet status and alcohol detection\n - Buzzer alerts for sleep detection or alcohol presence\n - Automatic page switching on LCD every 3 seconds\n - Timeout alert when no data is received for 5 seconds\n*/\n#include <Wire.h>\n#include <LiquidCrystal_I2C.h>\n#include <RH_ASK.h>\n#include <SPI.h>\n// Initialize LCD display and RF module\nLiquidCrystal_I2C lcd(0x27, 16, 2);\nRH_ASK rf_driver(2000, 11, 12, 0);\n// Define pin connections\nconst int ignitionRelay = 4;\nconst int buzzerPin = 5;\n// Variables to store received data\nString str_helmet = \"0\", str_alcohol = \"0\", str_sleep = \"0\";\nint helmetStatus = 0, alcoholLevel = 0, sleepStatus = 0;\nbool engineState = false;\n// Timeout and page switching variables\nunsigned long lastReceivedTime = 0;\nconst unsigned long timeout = 5000;\nint page = 0, lastPage = -1;\nunsigned long lastPageSwitch = 0;\nconst unsigned long pageInterval = 3000;\nvoid setup() {\n Serial.begin(115200); // Initialize serial communication\n rf_driver.init(); // Initialize RF module\n pinMode(ignitionRelay, OUTPUT);\n pinMode(buzzerPin, OUTPUT);\n digitalWrite(ignitionRelay, LOW); // Default: Vehicle OFF\n digitalWrite(buzzerPin, LOW); // Default: No alert\n lcd.begin();\n lcd.backlight();\n lcd.setCursor(0, 0);\n lcd.print(\"Smart Helmet\");\n delay(1000);\n lcd.clear();\n}\nvoid loop() {\n uint8_t buf[20];\n uint8_t buflen = sizeof(buf);\n // Check if RF data is received\n if (rf_driver.recv(buf, &buflen)) {\n   String str_out = String((char*)buf);\n   lastReceivedTime = millis(); // Update last received time\n   // Extract values from received string\n   int comma1 = str_out.indexOf(',');\n   int comma2 = str_out.lastIndexOf(',');\n   if (comma1 > 0 && comma2 > comma1) {\n     str_helmet = str_out.substring(0, comma1);\n     str_alcohol = str_out.substring(comma1 + 1, comma2);\n     str_sleep = str_out.substring(comma2 + 1);\n     helmetStatus = str_helmet.toInt();\n     alcoholLevel = str_alcohol.toInt();\n     sleepStatus = str_sleep.toInt();\n     // Control vehicle ignition based on conditions\n     engineState = (helmetStatus && !alcoholLevel);\n     digitalWrite(ignitionRelay, engineState);\n     // Activate buzzer if sleep or alcohol detected\n     digitalWrite(buzzerPin, (sleepStatus || alcoholLevel || page == 99) ? HIGH : LOW);\n     Serial.print(\"Received: \");\n     Serial.println(str_out);\n   }\n }\n // Handle timeout if no data received for a set time\n if (millis() - lastReceivedTime > timeout) {\n   if (page != 99) {\n     digitalWrite(buzzerPin, HIGH);\n     lcd.clear();\n     lcd.print(\"No Data Received\");\n     lcd.setCursor(0, 1);\n     lcd.print(\"System Offline\");\n     page = 99;\n   }\n   return;\n }\n // Handle automatic page switching\n if (millis() - lastPageSwitch > pageInterval) {\n   lastPageSwitch = millis();\n   page = (page + 1) % 2;\n   delay(200); // Small delay to prevent rapid switching\n }\n // Clear LCD only when switching pages\n if (page != lastPage) {\n   lcd.clear();\n   lastPage = page;\n }\n // Display different pages based on current page index\n switch (page) {\n   case 0:  // Page 1: Helmet, Alcohol, and Sleep Status\n     lcd.setCursor(0, 0);\n     lcd.print(\"Helmet: \");\n     lcd.print(helmetStatus == 1 ? \"Yes\" : \"No \");\n     lcd.setCursor(0, 1);\n     lcd.print(\"Alcohol: \");\n     lcd.print(alcoholLevel == 1 ? \"Yes\" : \"No \");\n     break;\n   case 1:  // Page 2: Sleep Status and Engine State\n     lcd.setCursor(0, 0);\n     lcd.print(\"Sleep: \");\n     lcd.print(sleepStatus == 1 ? \"Yes\" : \"No \");\n     lcd.setCursor(0, 1);\n     lcd.print(\"Engine: \");\n     lcd.print(engineState ? \"ON \" : \"OFF\");\n     break;\n }\n}\n```\n\n# Start a Discussion on:\n\n# Comments\n\n# Welcome to My Comment\n\nThis is a paragraph of my comment.\n\nBRO MIND BLOWING BRO\n\nLog in or register to post comments\n\nHello. Can u please provide me the place whare i cand download the library LiquidCrystal I2C.h that you used?\n\nbecause when compiling it gives me the error Compilation error: no matching function for call to 'LiquidCrystal_I2C::begin()'\n\nLog in or register to post comments\n\nIn reply to Hello. Can u please provide… by irinafinoghen\n\nUse lcd.init(); instead of lcd.begin();\n\nLog in or register to post comments\n\n# Add New Comment\n\nLog in or register to post comments"}
{"title":"How to Build an IoT-based Weather Monitoring System Using Arduino?","content":"Have you ever wanted to build your own IoT-based Weather Monitoring Station? Imagine monitoring real-time temperature, humidity levels, atmospheric pressure, rainfall detection, air quality index (AQI), and more—right from your local network. With the power of the Arduino UNO R4 WiFi, you can create a dynamic weather dashboard web page that displays all your environmental data in real-time without relying on third-party cloud services.\n\nNo need to stress about complicated cloud setups or costly subscription plans. This DIY IoT Weather Station project only requires a few environmental sensors and the versatile Arduino UNO R4 WiFi board. It blends IoT, web development, and embedded programming, making it an ideal IoT project for beginners, students, and tech enthusiasts interested in smart weather systems, Arduino projects, and real-time data monitoring.\n\nIf you are new to Arduino UNO R4, then I strongly recommend that you go through this “Getting Started with Arduino UNO R4 & Arduino IoT Cloud” tutorial before proceeding.\n\n# What is an IoT-Based Weather Monitoring System?\n\nAn IoT-Based Weather Monitoring System uses sensors to collect real-time environmental data like temperature, humidity, and air pressure. It transmits the data to the cloud using IoT protocols such as Wi-Fi or LoRa. Users can access this information remotely via the web or mobile apps. This system helps in accurate forecasting, environmental research, and smart agriculture.\n\nThis Arduino Weather Monitoring System Project is very helpful in getting to know about your surrounding weather status from indoors. What makes this project different from others is that it gives you the advantage of fully customizing the local webpage user interface based on your creativity, whereas you can’t get this level of flexibility from the cloud platforms.\n\n# Block Diagram\n\nThe image below shows the weather monitoring system using an IoT block diagram. Let's understand how it works by splitting it into three sections\n\nGathering The Data From The Environment\n\nThis system uses a wide range of environmental sensors to capture the weather key parameters like temperature, humidity level, Atmospheric pressure, AQI Index, and Rainfall status continuously and send that data to Arduino through serial communication protocols as well as Normal Analog and Digital signals.\n\nServing The Locally Accessible Webpage\n\nAfter getting the weather data from the environmental sensors, Arduino creates the local webpage that displays the sensor data by turning itself into a mini local web server. This means you can know weather data from a phone, tablet, or computer by simply connecting to the same network where the Arduino is connected.\n\nDynamically Updating The Webpage for Live Updates\n\nArduino-served Webpage keeps on refreshing the data dynamically, so you’ll always see the latest weather info. Whether the temperature rises, the humidity changes, or the Rain is falling, you will see instantly on your device. No need to manually refresh the webpage every time.\n\n# Components Required\n\nHere are the components needed to build an Arduino Weather Monitoring System. Let’s see what things we need to build it.\n\nArduino UNO R4 WiFi\n\nArduino UNO R4 WiFi\n\nBMP180 Barometric Pressure Sensor\n\nBMP180 Barometric Pressure Sensor\n\nDHT11 Temperature & Humidity Sensor\n\nDHT11 Temperature & Humidity Sensor\n\nMQ135 Air Monitoring Sensor\n\nMQ135 Air Monitoring Sensor\n\nRain Sensor with Sensor Module\n\nRain Sensor with Sensor Module\n\nBreadboard\n\nBreadboard\n\nConnecting Wires\n\nConnecting Wires\n\nAs you can see from the above components list, we will be using 4 different sensors to read various parameters like temperature, humidity, pressure, air quality, rain status, etc from the atmosphere. If you are a complete beginner with these sensors, check out the BMP180 tutorial, DHT11 Tutorial, MQ135 Tutorial, and Rain Sensor tutorial to understand how these sensors work and how you can use them with Arduino.\n\n# Circuit Diagram for Arduino-Based Weather Monitoring System\n\nIn the above image, you can find the circuit diagram of our Weather Monitoring System using Arduino. This circuit diagram helps turn our scattered electronic components found on the workbench into a functional Mini Weather Station.\n\nAs you can see, I am using a wide variety of sensors here for measuring each weather parameter, like\n\nBMP180 Sensor - used for measuring the Atmospheric pressure. If the pressure is High means “Clear, sunny weather!” and if the pressure is low, it means “Rainy or stormy weather!”\n\nBMP180 Sensor - used for measuring the Atmospheric pressure. If the pressure is High means “Clear, sunny weather!” and if the pressure is low, it means “Rainy or stormy weather!”\n\nDHT11 Sensor - used for measuring Temperature and Humidity. Here, temperature tells “How warm or cool the Air is” and humidity tells “How much water vapour is in the Air”.\n\nDHT11 Sensor - used for measuring Temperature and Humidity. Here, temperature tells “How warm or cool the Air is” and humidity tells “How much water vapour is in the Air”.\n\nMQ135 Sensor - used for measuring the Pollutants present in the Air. Here, monitoring the AQI(pollutant level) is important for health reasons, especially if we have asthma or lung allergies. (Note, it is not accurate, but might work well in indoor/outdoor environments)\n\nMQ135 Sensor - used for measuring the Pollutants present in the Air. Here, monitoring the AQI(pollutant level) is important for health reasons, especially if we have asthma or lung allergies. (Note, it is not accurate, but might work well in indoor/outdoor environments)\n\nRain sensor - used for detecting whether it’s currently raining or not.\n\nRain sensor - used for detecting whether it’s currently raining or not.\n\nThe Arduino UNO R4 WiFi collects all of this sensor data and makes the live data reflected on the Local Webpage instantly.\n\n# Hardware Pinout of IoT Weather Monitoring System\n\nTo make the hardware connection easy to understand, we have given a connection mapping below that explains the connection between your Arduino board and the various environmental sensors.\n\n# MQ135 Sensor and Arduino\n\n# DHT11 Sensor and Arduino\n\n# BMP180 Sensor and Arduino\n\n# Rain Sensor and Arduino\n\n# Hardware Setup of Weather Monitoring System using Arduino\n\nHere is the complete hardware that was built from using the above circuit diagram as a blueprint\n\nFor power supply, you can either power it through the 12V DC jack port or through the USB port.\n\n# Arduino Code for IoT-based Weather Monitoring System\n\nBefore jumping into the code explanation, I will give you a short overview of this code. First of all, this code, ensures our Arduino UNO R4 WiFi is connected to our Local Access point.  After that, it starts to serve the dynamic webpage by acting as a local web server.\n\nAt the same time, it continuously retrieves data from the sensor every second and makes that data reflect on that dynamic webpage with a graphical chart format. It also utilizes the built-in 12x8 LED matrix for displaying the connection status. It ensures Arduino automatically connects to the Hotspot whenever it gets disconnected.\n\nI hope you get a clear overview. Let’s move on to a step-by-step code explanation.\n\n# Including Header Files for Prebuilt Functions\n\n```arduino\n#include <Adafruit_BMP085.h>\n#include <Adafruit_Sensor.h>\n#include <DHT.h>\n#include <DHT_U.h>\n#include \"Arduino_LED_Matrix.h\"\n#include \"WiFiS3.h\"\n```\n\n```arduino\n#include <Adafruit_BMP085.h>\n#include <Adafruit_Sensor.h>\n#include <DHT.h>\n#include <DHT_U.h>\n#include \"Arduino_LED_Matrix.h\"\n#include \"WiFiS3.h\"\n```\n\nHere,\n\n1.Adafruit_BMP085.h && Adafruit_Sensor.h\n\n- It helps in interfacing with the BMP180 using simpler I2C APIs as well to parse the Humidity data.\n\n2.DHT.h && DHT_U.h\n\nIt is used for establishing a connection with the DHT11 sensor through its serial communication protocol with ease.\n\n3.Arduino_LED_Matrix.h\n\nArduino UNO R4 built-in 8x12 LED matrix can be easily customizable using its provided prebuilt routines.\n\n4.WiFiS3.h\n\nWe know Arduino UNO R4 supports WiFi features, where this library comes in handy for easy WiFi setup and configuration.\n\nNote “Arduino_LED_Matrix.h” and “WiFiS3.h” come along with the board support package of Arduino UNO R4 WiFi. So, we don’t need to install it separately.\n\nYou can easily get this library by clicking the appropriate header file name.\n\nAfter downloading the ZIP file from the GitHub repo, you can install it either through the Arduino IDE, by going to Sketch -> Include Library -> Add ZIP Library and selecting the downloaded ZIP file, or by simply extracting the ZIP file into the Arduino library folder.\n\n# Macros for Sensor Pin Mapping\n\n```arduino\n#define Rain_SensorPin 3\n#define Air_SensorPin A0\n#define Temp_Hum_SensorPin 2\n```\n\n```arduino\n#define Rain_SensorPin 3\n#define Air_SensorPin A0\n#define Temp_Hum_SensorPin 2\n```\n\nHere, I used macros to hold the pin data of the Rain sensor, DHT11 sensor, and MQ135 sensor, where the sensor is going to connect to the appropriate pin of the Arduino.\n\n# Creating Objects for Sensor, WiFi & LED Matrix\n\nThis step is about creating objects for the sensor, WiFi, and LED matrix to easily use the prebuilt APIs.\n\n```arduino\nDHT_Unified dht(Temp_Hum_SensorPin, DHT11);\nAdafruit_BMP085 bmp;\nWiFiServer server(80);\nArduinoLEDMatrix matrix;\n```\n\n```arduino\nDHT_Unified dht(Temp_Hum_SensorPin, DHT11);\nAdafruit_BMP085 bmp;\nWiFiServer server(80);\nArduinoLEDMatrix matrix;\n```\n\nHere, I am creating a new object for the DHT11 sensor, and the BMP180 sensor to initialize it properly by passing its pin details and the type of sensor used.\n\nWhereas the creation of a server() object to make use of the WiFi module’s Web Server capability and a matrix object to control the built-in LED matrix with ease by utilizing its class specific API’s.\n\n# Holding Important Data Using Global Variables\n\n```arduino\nconst uint32_t wifi_connected[] = {\n                               0x3f840,\n        0x49f22084,\n        0xe4110040\n};\nconst uint32_t no_wifi[] = {\n                               0x403f844,\n        0x49f22484,\n        0xe4110040\n};\n```\n\n```arduino\nconst uint32_t wifi_connected[] = {\n                               0x3f840,\n        0x49f22084,\n        0xe4110040\n};\nconst uint32_t no_wifi[] = {\n                               0x403f844,\n        0x49f22484,\n        0xe4110040\n};\n```\n\nHere, these two array variables, wifi_connected[] && no_wifi[] hold the hexadecimal code, which is vital for bringing up the wifi connected symbol and wifi disconnected symbol on Arduino UNO R4’s builtin 12x8 LED Matrix.\n\n```arduino\nchar ssid[] = \"Semicon Media\";\nchar pass[] = \"xxxxxxxxxxxx\";\n```\n\n```arduino\nchar ssid[] = \"Semicon Media\";\nchar pass[] = \"xxxxxxxxxxxx\";\n```\n\nssid[] and pass[] character array is used to hold your WiFi Router password. So that your Arduino UNO R4 can connect to this local network. Don’t forget to replace it with your Wifi router credentials.\n\n```arduino\nfloat temperature = 0.0, humidity = 0.0, pressure = 0.0;\nint AQI = 0, rainfall = 0;\n```\n\n```arduino\nfloat temperature = 0.0, humidity = 0.0, pressure = 0.0;\nint AQI = 0, rainfall = 0;\n```\n\nThese variables are used to hold the weather parameter info like temperature, humidity, pressure, AQI, and rainfall status, which was obtained from its respective sensors.\n\n```arduino\nunsigned long lastSensorUpdate = 0;\nunsigned long lastWiFiCheck = 0;\n```\n\n```arduino\nunsigned long lastSensorUpdate = 0;\nunsigned long lastWiFiCheck = 0;\n```\n\nHere, these two variables act as status variables, where “lastSensorUpdate” keeps a record of the last time the weather data was fetched from the sensor, and “lastWiFiCheck” tracks the last time the Wi-Fi status was checked.\n\n# wifi_connect() Function\n\nwifi_connect() Function establishes the initial connection to the specified WiFi network.\n\n```arduino\nvoid wifi_connect(){\n if (WiFi.status() == WL_NO_MODULE) {\n   Serial.println(\"Communication with WiFi module failed!\");\n   matrix.loadFrame(no_wifi);\n   while (true);\n }\n Serial.print(\"Connecting to WiFi...\");\n matrix.loadSequence(LEDMATRIX_ANIMATION_WIFI_SEARCH);\n matrix.play(true);\n delay(6000);\n while (WiFi.begin(ssid, pass) != WL_CONNECTED) {\n   Serial.print(\".\");\n   delay(1000);\n }\n \n matrix.loadFrame(wifi_connected);\n \n Serial.println(\"\\nConnected to WiFi!\");\n Serial.print(\"IP Address: \");\n Serial.println(WiFi.localIP());\n}\n```\n\n```arduino\nvoid wifi_connect(){\n if (WiFi.status() == WL_NO_MODULE) {\n   Serial.println(\"Communication with WiFi module failed!\");\n   matrix.loadFrame(no_wifi);\n   while (true);\n }\n Serial.print(\"Connecting to WiFi...\");\n matrix.loadSequence(LEDMATRIX_ANIMATION_WIFI_SEARCH);\n matrix.play(true);\n delay(6000);\n while (WiFi.begin(ssid, pass) != WL_CONNECTED) {\n   Serial.print(\".\");\n   delay(1000);\n }\n \n matrix.loadFrame(wifi_connected);\n \n Serial.println(\"\\nConnected to WiFi!\");\n Serial.print(\"IP Address: \");\n Serial.println(WiFi.localIP());\n}\n```\n\nThe wifi_connect() function is used for making a wifi connection with the authorized hotspot using its wifi credentials details.\n\nWhile trying to connect to the hotspot, it brings a wifi connection animation on the built-in 12x8 LED matrix, to indicate the board is trying to connect to the internet. Later, it brings out a stable WiFi symbol after successful connection with the Hotspot.\n\n# wifi_reconnect() Function\n\nwifi_reconnect() Function handles automatic reconnection to the network if the WiFi connection is lost.\n\n```arduino\nvoid wifi_reconnect(){\n   Serial.println(\"Wifi Reconnecting........\");\n   matrix.loadFrame(no_wifi);\n   delay(6000);\n   wifi_connect();\n}\n```\n\n```arduino\nvoid wifi_reconnect(){\n   Serial.println(\"Wifi Reconnecting........\");\n   matrix.loadFrame(no_wifi);\n   delay(6000);\n   wifi_connect();\n}\n```\n\nThis wifi_reconnect() gets used when we need to re-establish the connection between the Arduino and the Hotspot after getting lost.\n\nWhenever the connection gets lost, it brings out the “No Internet” symbol on the LED matrix and tries to connect again by calling out the wifi_connect() function.\n\n# read_sensor_data() function\n\nread_sensor_data() function retrieves real-time data from the connected sensors.\n\n```arduino\nvoid read_sensor_data(){\n   sensors_event_t event;\n   dht.temperature().getEvent(&event);\n   temperature = event.temperature;\n   dht.humidity().getEvent(&event);\n   humidity = event.relative_humidity;\n   pressure = bmp.readPressure() / 100.0; // Convert Pa to mbar\n   int mq135Raw = analogRead(Air_SensorPin);\n   float mq135PPM = mq135Raw * (5.0 / 1023.0) * 200.0; // Convert raw value to PPM\n   AQI = map(mq135PPM, 0, 500, 0, 300); // Convert PPM to AQI (adjust as needed)\n   rainfall = digitalRead(Rain_SensorPin) == HIGH ? 0 : 1;\n   Serial.println(\"-------------------------\");\n   Serial.println(temperature);\n   Serial.println(humidity);\n   Serial.println(rainfall);\n   Serial.println(pressure);\n   Serial.println(\"-------------------------\");\n}\n```\n\n```arduino\nvoid read_sensor_data(){\n   sensors_event_t event;\n   dht.temperature().getEvent(&event);\n   temperature = event.temperature;\n   dht.humidity().getEvent(&event);\n   humidity = event.relative_humidity;\n   pressure = bmp.readPressure() / 100.0; // Convert Pa to mbar\n   int mq135Raw = analogRead(Air_SensorPin);\n   float mq135PPM = mq135Raw * (5.0 / 1023.0) * 200.0; // Convert raw value to PPM\n   AQI = map(mq135PPM, 0, 500, 0, 300); // Convert PPM to AQI (adjust as needed)\n   rainfall = digitalRead(Rain_SensorPin) == HIGH ? 0 : 1;\n   Serial.println(\"-------------------------\");\n   Serial.println(temperature);\n   Serial.println(humidity);\n   Serial.println(rainfall);\n   Serial.println(pressure);\n   Serial.println(\"-------------------------\");\n}\n```\n\nHere, the read_sensor_data() function is used to fetch the weather parameter data from the respective sensors by utilizing the sensor-specific APIs. After collecting data, it does unit conversions like converting pressure from Pa to mbar & raw air sensor value to PPM and makes it to store in respective global variables.\n\n# send_json_data() function\n\nsend_json_data() function sends real-time JSON data to the user's web browser.\n\n```arduino\nvoid send_json_data(WiFiClient &client) {\n client.println(\"HTTP/1.1 200 OK\");\n client.println(\"Content-Type: application/json\");\n client.println(\"Connection: close\");\n client.println();\n \n String json = \"{\\\"temperature\\\":\" + String(temperature) +\n               \",\\\"humidity\\\":\" + String(humidity) +\n               \",\\\"pressure\\\":\" + String(pressure) +\n               \",\\\"aqi\\\":\" + String(AQI) +\n               \",\\\"rainfall\\\":\" + String(rainfall) + \"}\";\n \n client.println(json);\n}\n```\n\n```arduino\nvoid send_json_data(WiFiClient &client) {\n client.println(\"HTTP/1.1 200 OK\");\n client.println(\"Content-Type: application/json\");\n client.println(\"Connection: close\");\n client.println();\n \n String json = \"{\\\"temperature\\\":\" + String(temperature) +\n               \",\\\"humidity\\\":\" + String(humidity) +\n               \",\\\"pressure\\\":\" + String(pressure) +\n               \",\\\"aqi\\\":\" + String(AQI) +\n               \",\\\"rainfall\\\":\" + String(rainfall) + \"}\";\n \n client.println(json);\n}\n```\n\nThe send_json_data() function is responsible for fetching the weather data from the global variables and sending weather data from the Arduino to a connected client(Browser) in JSON format over WiFi.\n\nThe response contains the weather data in a structured format, making it easy for the client to parse and display.\n\n# send_web_page() function\n\nThe function serves the dynamic web page directly to the user's web browser.\n\n```arduino\nvoid send_web_page(WiFiClient &client) {\n // Send HTTP headers\n client.println(\"HTTP/1.1 200 OK\");\n client.println(\"Content-Type: text/html\");\n client.println(\"Connection: close\");\n client.println();\n // Use raw string literal for HTML content\n const char* html = R\"rawliteral(\n<!DOCTYPE html>\n<html lang='en'>\n<head>\n<meta charset='UTF-8'>\n<meta name='viewport' content='width=device-width, initial-scale=1.0'>\n<title>Weather Dashboard</title>\n<style>\n body { font-family: Arial, sans-serif; background: #f4f4f4; color: #333; text-align: center; padding: 20px; }\n h1 { font-size: 2rem; color: #0077cc; }\n .container { max-width: 900px; margin: auto; }\n .data-container { display: flex; flex-direction: column; gap: 10px; }\n .data-row { display: flex; justify-content: space-between; align-items: center; }\n .data-card { background: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); flex: 1; margin: 5px; text-align: center; }\n .graph { background: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); margin-top: 15px; }\n canvas { width: 100%; height: 400px; }\n</style>\n</head>\n<body>\n<h1>Weather Dashboard</h1>\n<div class='container'>\n <div id='weather' class='data-container'></div>\n <div class='graph'><canvas id='combinedGraph'></canvas></div>\n</div>\n<script src='https://cdn.jsdelivr.net/npm/chart.js'></script>\n<script>\n const ctxCombined = document.getElementById('combinedGraph').getContext('2d');\n // Create a single graph with both temperature and humidity\n const combinedChart = new Chart(ctxCombined, {\n   type: 'line',\n   data: {\n     labels: [],\n     datasets: [\n       {\n         label: 'Temperature (°C)',\n         data: [],\n         borderColor: '#ff5733',\n         backgroundColor: 'rgba(255, 87, 51, 0.2)',\n         fill: true,\n         tension: 0.4,\n         pointRadius: 3\n       },\n       {\n         label: 'Humidity (%)',\n         data: [],\n         borderColor: '#2196f3',\n         backgroundColor: 'rgba(33, 150, 243, 0.2)',\n         fill: true,\n         tension: 0.4,\n         pointRadius: 3\n       }\n     ]\n   },\n   options: {\n     responsive: true,\n     maintainAspectRatio: false,\n     animation: false,\n     scales: {\n       x: { title: { display: true, text: 'Time' } },\n       y: { \n         beginAtZero: true,\n         min: 0,\n         max: 100,\n         ticks: { stepSize: 10 }\n       }\n     }\n   }\n });\n // Fetch and update data\n function fetchWeatherData() {\n   fetch('/data')\n     .then(response => response.json())\n     .then(data => {\n       document.getElementById('weather').innerHTML = `\n         <div class='data-row'>\n           <div class='data-card'>Temp: ${data.temperature}°C &nbsp;&nbsp;  Humidity: ${data.humidity}%</div>\n         </div>\n         <div class='data-row'>\n           <div class='data-card'>Pressure: ${data.pressure} mbar</div>\n         </div>\n         <div class='data-row'>\n           <div class='data-card'>AQI: ${data.aqi} &nbsp;&nbsp;  Rainfall: ${data.rainfall ? 'Yes' : 'No'}</div>\n         </div>`;\n       let time = new Date().toLocaleTimeString();\n       \n       // Add new data points\n       combinedChart.data.labels.push(time);\n       combinedChart.data.datasets[0].data.push(data.temperature);  // Temperature\n       combinedChart.data.datasets[1].data.push(data.humidity);    // Humidity\n       // Keep only the last 10 points\n       if (combinedChart.data.labels.length > 10) {\n         combinedChart.data.labels.shift();\n         combinedChart.data.datasets[0].data.shift();\n         combinedChart.data.datasets[1].data.shift();\n       }\n       combinedChart.update();\n     });\n }\n setInterval(fetchWeatherData, 1000);\n</script>\n</body>\n</html>\n)rawliteral\";\n // Send the entire HTML content in one go\n client.print(html);\n}\n```\n\n```arduino\nvoid send_web_page(WiFiClient &client) {\n // Send HTTP headers\n client.println(\"HTTP/1.1 200 OK\");\n client.println(\"Content-Type: text/html\");\n client.println(\"Connection: close\");\n client.println();\n // Use raw string literal for HTML content\n const char* html = R\"rawliteral(\n<!DOCTYPE html>\n<html lang='en'>\n<head>\n<meta charset='UTF-8'>\n<meta name='viewport' content='width=device-width, initial-scale=1.0'>\n<title>Weather Dashboard</title>\n<style>\n body { font-family: Arial, sans-serif; background: #f4f4f4; color: #333; text-align: center; padding: 20px; }\n h1 { font-size: 2rem; color: #0077cc; }\n .container { max-width: 900px; margin: auto; }\n .data-container { display: flex; flex-direction: column; gap: 10px; }\n .data-row { display: flex; justify-content: space-between; align-items: center; }\n .data-card { background: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); flex: 1; margin: 5px; text-align: center; }\n .graph { background: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); margin-top: 15px; }\n canvas { width: 100%; height: 400px; }\n</style>\n</head>\n<body>\n<h1>Weather Dashboard</h1>\n<div class='container'>\n <div id='weather' class='data-container'></div>\n <div class='graph'><canvas id='combinedGraph'></canvas></div>\n</div>\n<script src='https://cdn.jsdelivr.net/npm/chart.js'></script>\n<script>\n const ctxCombined = document.getElementById('combinedGraph').getContext('2d');\n // Create a single graph with both temperature and humidity\n const combinedChart = new Chart(ctxCombined, {\n   type: 'line',\n   data: {\n     labels: [],\n     datasets: [\n       {\n         label: 'Temperature (°C)',\n         data: [],\n         borderColor: '#ff5733',\n         backgroundColor: 'rgba(255, 87, 51, 0.2)',\n         fill: true,\n         tension: 0.4,\n         pointRadius: 3\n       },\n       {\n         label: 'Humidity (%)',\n         data: [],\n         borderColor: '#2196f3',\n         backgroundColor: 'rgba(33, 150, 243, 0.2)',\n         fill: true,\n         tension: 0.4,\n         pointRadius: 3\n       }\n     ]\n   },\n   options: {\n     responsive: true,\n     maintainAspectRatio: false,\n     animation: false,\n     scales: {\n       x: { title: { display: true, text: 'Time' } },\n       y: { \n         beginAtZero: true,\n         min: 0,\n         max: 100,\n         ticks: { stepSize: 10 }\n       }\n     }\n   }\n });\n // Fetch and update data\n function fetchWeatherData() {\n   fetch('/data')\n     .then(response => response.json())\n     .then(data => {\n       document.getElementById('weather').innerHTML = `\n         <div class='data-row'>\n           <div class='data-card'>Temp: ${data.temperature}°C &nbsp;&nbsp;  Humidity: ${data.humidity}%</div>\n         </div>\n         <div class='data-row'>\n           <div class='data-card'>Pressure: ${data.pressure} mbar</div>\n         </div>\n         <div class='data-row'>\n           <div class='data-card'>AQI: ${data.aqi} &nbsp;&nbsp;  Rainfall: ${data.rainfall ? 'Yes' : 'No'}</div>\n         </div>`;\n       let time = new Date().toLocaleTimeString();\n       \n       // Add new data points\n       combinedChart.data.labels.push(time);\n       combinedChart.data.datasets[0].data.push(data.temperature);  // Temperature\n       combinedChart.data.datasets[1].data.push(data.humidity);    // Humidity\n       // Keep only the last 10 points\n       if (combinedChart.data.labels.length > 10) {\n         combinedChart.data.labels.shift();\n         combinedChart.data.datasets[0].data.shift();\n         combinedChart.data.datasets[1].data.shift();\n       }\n       combinedChart.update();\n     });\n }\n setInterval(fetchWeatherData, 1000);\n</script>\n</body>\n</html>\n)rawliteral\";\n // Send the entire HTML content in one go\n client.print(html);\n}\n```\n\nThis send_web_page() function is responsible for generating and sending an HTML-based weather dashboard to a connected client(Browser) over WiFi.\n\n# How the Webpage HTML Code Works\n\n1.HTML Structure\n\nDisplays weather data cards (temperature, humidity, pressure, AQI, rainfall).\n\nDisplays weather data cards (temperature, humidity, pressure, AQI, rainfall).\n\nIt includes a graph for plotting temperature and humidity using Chart.js.\n\nIt includes a graph for plotting temperature and humidity using Chart.js.\n\n2.CSS Styling\n\nLight theme with responsive layout and modern styling.\n\nLight theme with responsive layout and modern styling.\n\n3.JavaScript\n\nFetches weather data from the Arduino local web server (/data endpoint) i.e, JSON data serve path “https://Arduino_IP _Address/data” every second.\n\nFetches weather data from the Arduino local web server (/data endpoint) i.e, JSON data serve path “https://Arduino_IP _Address/data” every second.\n\nUpdates the data cards and appends new data points to the graphs dynamically.\n\nUpdates the data cards and appends new data points to the graphs dynamically.\n\n4. Graphs\n\nUses Chart.js to create real-time line charts for temperature and humidity.\n\nUses Chart.js to create real-time line charts for temperature and humidity.\n\nKeeps only the last 10 data points visible.\n\nKeeps only the last 10 data points visible.\n\nOverall, this function creates a real-time weather dashboard with dynamic weather data and interactive graphs, using HTML, CSS, JavaScript, and Chart.js.\n\nYou can also able to customize this webpage by editing the HTML Code to unleash your Creativity. But make sure your code fetches the weather data from the JSON endpoint/data.\n\n# run_local_webserver()\n\nThis function activates the local webserver to serve both the webpage and live JSON data.\n\n```arduino\nvoid run_local_webserver(){\n WiFiClient client = server.available();\n if (client) {\n   String request = client.readStringUntil('\\r');\n   client.flush();\n   if (request.indexOf(\"GET / \") != -1) {\n     send_web_page(client);\n   } else if (request.indexOf(\"GET /data\") != -1) {\n     send_json_data(client);\n   }\n   client.stop();\n }\n}\n```\n\n```arduino\nvoid run_local_webserver(){\n WiFiClient client = server.available();\n if (client) {\n   String request = client.readStringUntil('\\r');\n   client.flush();\n   if (request.indexOf(\"GET / \") != -1) {\n     send_web_page(client);\n   } else if (request.indexOf(\"GET /data\") != -1) {\n     send_json_data(client);\n   }\n   client.stop();\n }\n}\n```\n\nThe run_local_webserver() function handles incoming HTTP requests on the Arduino web server and responds accordingly. Note that it only responds to the client, which gets connected to the same network where the Arduino is connected.\n\nLet’s consider the scenario,\n\nWhenever the client requests access on  “http://ARDUINO_IP_ADDRESS/” or “http://ARDUINO_IP_ADDRESS”, then it makes a call on the send_web_page() function to serve the Dynamic weather dashboard web page to the requested client.\n\nWhenever the client requests access on  “http://ARDUINO_IP_ADDRESS/data”, it makes a call on the send_json_data() function to send the weather data in JSON format to the requested client.\n\n# Flash The Code into Arduino\n\nI hope you understand the working logic of the above code. Let’s upload this code into Arduino to see it working in action.\n\nBefore flashing the code, we want to make sure that, board is selected properly. In our case, it’s Arduino UNO R4 WiFi Board.\n\nAfter that we want to correct serial port, that is used by Arduino UNO R4 WiFi for programming. If you see the Port Option is greyed Out. Then check out this tutorial Arduino not Working? Tips to troubleshoot the board.\n\nLet’s finally upload the code into Arduino by clicking the Upload button present on the Arduino IDE, as shown above.\n\n# Working Demonstration of IoT Weather Monitoring System\n\nBelow, you can find the Working demonstration of the Arduino Weather monitoring system, where it collects the external environmental parameters like Temperature, Humidity, Rainfall status, Atmospheric pressure, Air Quality Index, and make it visible on the Locally Served Webpage.\n\n# GitHub Repository with Code and Circuit\n\n# Similar IoT-Based Weather Monitoring Projects\n\nWe have built several interesting IoT-based Weather Monitoring Projects using different sensors and microcontrollers. If you want to explore those projects, links are given below.\n\nIoT Weather Station using NodeMCU: Monitoring Humidity, Temperature and Pressure over Internet\n\nBuild an IoT-based weather station using ESP12E NodeMCU to monitor temperature, humidity, and pressure, displaying real-time data on a web server accessible over the Internet.\n\nInterfacing DHT11 Temperature & Humidity Sensor with STM32F103C8\n\nLearn how to interface the DHT11 temperature and humidity sensor with the STM32F103C8 (Blue Pill) board using the Arduino IDE. It displays real-time temperature and humidity readings on a 16x2 I2C LCD.\n\nLive Temperature and Humidity Monitoring over Internet using Arduino and ThingSpeak\n\nThis IoT project monitors temperature and humidity using sensors and displays real-time data on the ThingSpeak cloud platform.\n\nReal-Time Temperature and Humidity Monitoring Webserver with Raspberry Pi Pico W and DHT11 Sensor\n\nLearn how to use Raspberry Pi Pico W and a DHT11 sensor to monitor temperature and humidity. The collected data is displayed in real-time on a local webserver hosted by the Pico W.\n\n# Complete Project Code\n\n```arduino\n/*--------------------------------------------------------------\n---------------------------Header Files-------------------------\n----------------------------------------------------------------*/\n#include <Adafruit_BMP085.h>\n#include <Adafruit_Sensor.h>\n#include <DHT.h>\n#include <DHT_U.h>\n#include \"Arduino_LED_Matrix.h\"\n#include \"WiFiS3.h\"\n/*-----------------------------------------------------------------------\n-------------------------Sensor pin definition Macros-------------------\n-------------------------------------------------------------------------*/\n#define Rain_SensorPin 3\n#define Air_SensorPin A3\n#define Temp_Hum_SensorPin 2\n/*-------------------------------------------------------------------------\n--------------------------Object instantiation-----------------------------\n--------------------------------------------------------------------------*/\nDHT_Unified dht(Temp_Hum_SensorPin, DHT11);\nAdafruit_BMP085 bmp;\nWiFiServer server(80);\nArduinoLEDMatrix matrix;  \n/*--------------------------------------------------------------------\n-------------------------Global variables----------------------------\n----------------------------------------------------------------------*/\n//Bring WiFi Connected Symbol on LED Matrix\nconst uint32_t wifi_connected[] = {\n   0x3f840,\n        0x49f22084,\n        0xe4110040\n};\n\n//Bring WiFi Disconnrcted Symbol on LED Matrix\nconst uint32_t no_wifi[] = {\n   0x403f844,\n        0x49f22484,\n        0xe4110040\n};\n//SSID & PASSWORD of LAN Router\nchar ssid[] = \"Semicon Media\";\nchar pass[] = \"XXXXXXXXXXXXX\";\n//Variables to hold weather data from sensors\nfloat temperature = 0.0, humidity = 0.0, pressure = 0.0;\nint AQI = 0, rainfall = 0;\n//Flag variable for storing last sensor data update time and last wifi connectivity checking time\nunsigned long lastSensorUpdate = 0;\nunsigned long lastWiFiCheck = 0;\n/*---------------------------------------------------------------------\n-----------------User Defined Functions--------------------------------\n---------------------------------------------------------------------------*/\n//Function for making Arduino to connect to the WiFi Network\nvoid wifi_connect(){\n if (WiFi.status() == WL_NO_MODULE) {\n   Serial.println(\"Communication with WiFi module failed!\");\n   matrix.loadFrame(no_wifi);\n   while (true);\n }\n Serial.print(\"Connecting to WiFi...\");\n matrix.loadSequence(LEDMATRIX_ANIMATION_WIFI_SEARCH);\n matrix.play(true);\n delay(6000);\n while (WiFi.begin(ssid, pass) != WL_CONNECTED) {\n   Serial.print(\".\");\n   delay(1000);\n }\n matrix.loadFrame(wifi_connected);\n \n Serial.println(\"\\nConnected to WiFi!\");\n Serial.print(\"IP Address: \");\n Serial.println(WiFi.localIP());\n}\n//Function for making Arduino to reconnect to the WiFi Network, after getting disconnected\nvoid wifi_reconnect(){\n   Serial.println(\"Wifi Reconnecting........\");\n   matrix.loadFrame(no_wifi);\n   delay(6000);\n   wifi_connect();\n}\n//Functiom to read the weather data from the collection of sensors\nvoid read_sensor_data(){\n   sensors_event_t event;\n   dht.temperature().getEvent(&event);\n   temperature = event.temperature;\n   dht.humidity().getEvent(&event);\n   humidity = event.relative_humidity;\n   pressure = bmp.readPressure() / 100.0; // Convert Pa to mbar\n   int mq135Raw = analogRead(Air_SensorPin);\n   float mq135PPM = mq135Raw * (5.0 / 1023.0) * 20.0; // Convert raw value to PPM\n   AQI = map(mq135PPM, 0, 500, 0, 300); // Convert PPM to AQI (adjust as needed)\n   rainfall = digitalRead(Rain_SensorPin) == HIGH ? 0 : 1;\n}\n//Function to send JSON data to the requested Web client Device(Browser)\nvoid send_json_data(WiFiClient &client) {\n client.println(\"HTTP/1.1 200 OK\");\n client.println(\"Content-Type: application/json\");\n client.println(\"Connection: close\");\n client.println();\n \n String json = \"{\\\"temperature\\\":\" + String(temperature) +\n               \",\\\"humidity\\\":\" + String(humidity) +\n               \",\\\"pressure\\\":\" + String(pressure) +\n               \",\\\"aqi\\\":\" + String(AQI) +\n               \",\\\"rainfall\\\":\" + String(rainfall) + \"}\";\n \n client.println(json);\n}\n//Function to send Dynamic weather dashboard webpage to the requested web client(Browser)\nvoid send_web_page(WiFiClient &client) {\n // Send HTTP headers\n client.println(\"HTTP/1.1 200 OK\");\n client.println(\"Content-Type: text/html\");\n client.println(\"Connection: close\");\n client.println();\n // Use raw string literal for HTML content\n const char* html = R\"rawliteral(\n<!DOCTYPE html>\n<html lang='en'>\n<head>\n<meta charset='UTF-8'>\n<meta name='viewport' content='width=device-width, initial-scale=1.0'>\n<title>Weather Dashboard</title>\n<style>\n body { font-family: Arial, sans-serif; background: #f4f4f4; color: #333; text-align: center; padding: 20px; }\n h1 { font-size: 2rem; color: #0077cc; }\n .container { max-width: 900px; margin: auto; }\n .data-container { display: flex; flex-direction: column; gap: 10px; }\n .data-row { display: flex; justify-content: space-between; align-items: center; }\n .data-card { background: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); flex: 1; margin: 5px; text-align: center; }\n .graph { background: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); margin-top: 15px; }\n canvas { width: 100%; height: 400px; }\n</style>\n</head>\n<body>\n<h1>Weather Dashboard</h1>\n<div class='container'>\n <div id='weather' class='data-container'></div>\n <div class='graph'><canvas id='combinedGraph'></canvas></div>\n</div>\n<script src='https://cdn.jsdelivr.net/npm/chart.js'></script&gt;\n<script>\n const ctxCombined = document.getElementById('combinedGraph').getContext('2d');\n // Create a single graph with both temperature and humidity\n const combinedChart = new Chart(ctxCombined, {\n   type: 'line',\n   data: {\n     labels: [],\n     datasets: [\n       {\n         label: 'Temperature (°C)',\n         data: [],\n         borderColor: '#ff5733',\n         backgroundColor: 'rgba(255, 87, 51, 0.2)',\n         fill: true,\n         tension: 0.4,\n         pointRadius: 3\n       },\n       {\n         label: 'Humidity (%)',\n         data: [],\n         borderColor: '#2196f3',\n         backgroundColor: 'rgba(33, 150, 243, 0.2)',\n         fill: true,\n         tension: 0.4,\n         pointRadius: 3\n       }\n     ]\n   },\n   options: {\n     responsive: true,\n     maintainAspectRatio: false,\n     animation: false,\n     scales: {\n       x: { title: { display: true, text: 'Time' } },\n       y: { \n         beginAtZero: true,\n         min: 0,\n         max: 100,\n         ticks: { stepSize: 10 }\n       }\n     }\n   }\n });\n // Fetch and update data\n function fetchWeatherData() {\n   fetch('/data')\n     .then(response => response.json())\n     .then(data => {\n       document.getElementById('weather').innerHTML = `\n         <div class='data-row'>\n           <div class='data-card'> Temp: ${data.temperature}°C &nbsp;&nbsp;  Humidity: ${data.humidity}%</div>\n         </div>\n         <div class='data-row'>\n           <div class='data-card'> Pressure: ${data.pressure} mbar</div>\n         </div>\n         <div class='data-row'>\n           <div class='data-card'> AQI: ${data.aqi} &nbsp;&nbsp;  Rainfall: ${data.rainfall ? 'Yes' : 'No'}</div>\n         </div>`;\n       let time = new Date().toLocaleTimeString();\n       // Add new data points\n       combinedChart.data.labels.push(time);\n       combinedChart.data.datasets[0].data.push(data.temperature);  // Temperature\n       combinedChart.data.datasets[1].data.push(data.humidity);    // Humidity\n       // Keep only the last 10 points\n       if (combinedChart.data.labels.length > 10) {\n         combinedChart.data.labels.shift();\n         combinedChart.data.datasets[0].data.shift();\n         combinedChart.data.datasets[1].data.shift();\n       }\n       combinedChart.update();\n     });\n }\n setInterval(fetchWeatherData, 1000);\n</script>\n</body>\n</html>\n)rawliteral\";\n // Send the entire HTML content in one go\n client.print(html);\n}\n//Function to run a local webserver on Arduino for handling client request\nvoid run_local_webserver(){\n WiFiClient client = server.available();\n if (client) {\n   String request = client.readStringUntil('\\r');\n   client.flush();\n   if (request.indexOf(\"GET / \") != -1) {\n     send_web_page(client);\n   } else if (request.indexOf(\"GET /data\") != -1) {\n     send_json_data(client);\n   }\n   client.stop();\n }\n}\n/*-----------------------------------------------------------------\n-----------------------Setup Function------------------------------\n------------------------------------------------------------------*/\nvoid setup() {\n Serial.begin(115200);\n while (!Serial) {}\n matrix.begin();\n wifi_connect();\n server.begin();\n pinMode(Rain_SensorPin, INPUT);\n pinMode(Air_SensorPin, INPUT);\n dht.begin();\n while (!bmp.begin()) {\n   Serial.println(\"BMP085 sensor not found, check wiring!\");\n }\n}\n/*-----------------------------------------------------------\n-----------------Loop function-------------------------------\n-------------------------------------------------------------*/\nvoid loop() {\nif (millis() - lastSensorUpdate >= 1000) {\n   lastSensorUpdate = millis();\n   read_sensor_data();\n}\nif(millis() - lastWiFiCheck >= 5000){\n    lastWiFiCheck = millis();\n    \n    if(WiFi.status() != WL_CONNECTED){\n       wifi_reconnect();\n    }\n}\nrun_local_webserver();  \n}\n```\n\n```arduino\n/*--------------------------------------------------------------\n---------------------------Header Files-------------------------\n----------------------------------------------------------------*/\n#include <Adafruit_BMP085.h>\n#include <Adafruit_Sensor.h>\n#include <DHT.h>\n#include <DHT_U.h>\n#include \"Arduino_LED_Matrix.h\"\n#include \"WiFiS3.h\"\n/*-----------------------------------------------------------------------\n-------------------------Sensor pin definition Macros-------------------\n-------------------------------------------------------------------------*/\n#define Rain_SensorPin 3\n#define Air_SensorPin A3\n#define Temp_Hum_SensorPin 2\n/*-------------------------------------------------------------------------\n--------------------------Object instantiation-----------------------------\n--------------------------------------------------------------------------*/\nDHT_Unified dht(Temp_Hum_SensorPin, DHT11);\nAdafruit_BMP085 bmp;\nWiFiServer server(80);\nArduinoLEDMatrix matrix;  \n/*--------------------------------------------------------------------\n-------------------------Global variables----------------------------\n----------------------------------------------------------------------*/\n//Bring WiFi Connected Symbol on LED Matrix\nconst uint32_t wifi_connected[] = {\n   0x3f840,\n        0x49f22084,\n        0xe4110040\n};\n\n//Bring WiFi Disconnrcted Symbol on LED Matrix\nconst uint32_t no_wifi[] = {\n   0x403f844,\n        0x49f22484,\n        0xe4110040\n};\n//SSID & PASSWORD of LAN Router\nchar ssid[] = \"Semicon Media\";\nchar pass[] = \"XXXXXXXXXXXXX\";\n//Variables to hold weather data from sensors\nfloat temperature = 0.0, humidity = 0.0, pressure = 0.0;\nint AQI = 0, rainfall = 0;\n//Flag variable for storing last sensor data update time and last wifi connectivity checking time\nunsigned long lastSensorUpdate = 0;\nunsigned long lastWiFiCheck = 0;\n/*---------------------------------------------------------------------\n-----------------User Defined Functions--------------------------------\n---------------------------------------------------------------------------*/\n//Function for making Arduino to connect to the WiFi Network\nvoid wifi_connect(){\n if (WiFi.status() == WL_NO_MODULE) {\n   Serial.println(\"Communication with WiFi module failed!\");\n   matrix.loadFrame(no_wifi);\n   while (true);\n }\n Serial.print(\"Connecting to WiFi...\");\n matrix.loadSequence(LEDMATRIX_ANIMATION_WIFI_SEARCH);\n matrix.play(true);\n delay(6000);\n while (WiFi.begin(ssid, pass) != WL_CONNECTED) {\n   Serial.print(\".\");\n   delay(1000);\n }\n matrix.loadFrame(wifi_connected);\n \n Serial.println(\"\\nConnected to WiFi!\");\n Serial.print(\"IP Address: \");\n Serial.println(WiFi.localIP());\n}\n//Function for making Arduino to reconnect to the WiFi Network, after getting disconnected\nvoid wifi_reconnect(){\n   Serial.println(\"Wifi Reconnecting........\");\n   matrix.loadFrame(no_wifi);\n   delay(6000);\n   wifi_connect();\n}\n//Functiom to read the weather data from the collection of sensors\nvoid read_sensor_data(){\n   sensors_event_t event;\n   dht.temperature().getEvent(&event);\n   temperature = event.temperature;\n   dht.humidity().getEvent(&event);\n   humidity = event.relative_humidity;\n   pressure = bmp.readPressure() / 100.0; // Convert Pa to mbar\n   int mq135Raw = analogRead(Air_SensorPin);\n   float mq135PPM = mq135Raw * (5.0 / 1023.0) * 20.0; // Convert raw value to PPM\n   AQI = map(mq135PPM, 0, 500, 0, 300); // Convert PPM to AQI (adjust as needed)\n   rainfall = digitalRead(Rain_SensorPin) == HIGH ? 0 : 1;\n}\n//Function to send JSON data to the requested Web client Device(Browser)\nvoid send_json_data(WiFiClient &client) {\n client.println(\"HTTP/1.1 200 OK\");\n client.println(\"Content-Type: application/json\");\n client.println(\"Connection: close\");\n client.println();\n \n String json = \"{\\\"temperature\\\":\" + String(temperature) +\n               \",\\\"humidity\\\":\" + String(humidity) +\n               \",\\\"pressure\\\":\" + String(pressure) +\n               \",\\\"aqi\\\":\" + String(AQI) +\n               \",\\\"rainfall\\\":\" + String(rainfall) + \"}\";\n \n client.println(json);\n}\n//Function to send Dynamic weather dashboard webpage to the requested web client(Browser)\nvoid send_web_page(WiFiClient &client) {\n // Send HTTP headers\n client.println(\"HTTP/1.1 200 OK\");\n client.println(\"Content-Type: text/html\");\n client.println(\"Connection: close\");\n client.println();\n // Use raw string literal for HTML content\n const char* html = R\"rawliteral(\n<!DOCTYPE html>\n<html lang='en'>\n<head>\n<meta charset='UTF-8'>\n<meta name='viewport' content='width=device-width, initial-scale=1.0'>\n<title>Weather Dashboard</title>\n<style>\n body { font-family: Arial, sans-serif; background: #f4f4f4; color: #333; text-align: center; padding: 20px; }\n h1 { font-size: 2rem; color: #0077cc; }\n .container { max-width: 900px; margin: auto; }\n .data-container { display: flex; flex-direction: column; gap: 10px; }\n .data-row { display: flex; justify-content: space-between; align-items: center; }\n .data-card { background: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); flex: 1; margin: 5px; text-align: center; }\n .graph { background: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); margin-top: 15px; }\n canvas { width: 100%; height: 400px; }\n</style>\n</head>\n<body>\n<h1>Weather Dashboard</h1>\n<div class='container'>\n <div id='weather' class='data-container'></div>\n <div class='graph'><canvas id='combinedGraph'></canvas></div>\n</div>\n<script src='https://cdn.jsdelivr.net/npm/chart.js'></script&gt;\n<script>\n const ctxCombined = document.getElementById('combinedGraph').getContext('2d');\n // Create a single graph with both temperature and humidity\n const combinedChart = new Chart(ctxCombined, {\n   type: 'line',\n   data: {\n     labels: [],\n     datasets: [\n       {\n         label: 'Temperature (°C)',\n         data: [],\n         borderColor: '#ff5733',\n         backgroundColor: 'rgba(255, 87, 51, 0.2)',\n         fill: true,\n         tension: 0.4,\n         pointRadius: 3\n       },\n       {\n         label: 'Humidity (%)',\n         data: [],\n         borderColor: '#2196f3',\n         backgroundColor: 'rgba(33, 150, 243, 0.2)',\n         fill: true,\n         tension: 0.4,\n         pointRadius: 3\n       }\n     ]\n   },\n   options: {\n     responsive: true,\n     maintainAspectRatio: false,\n     animation: false,\n     scales: {\n       x: { title: { display: true, text: 'Time' } },\n       y: { \n         beginAtZero: true,\n         min: 0,\n         max: 100,\n         ticks: { stepSize: 10 }\n       }\n     }\n   }\n });\n // Fetch and update data\n function fetchWeatherData() {\n   fetch('/data')\n     .then(response => response.json())\n     .then(data => {\n       document.getElementById('weather').innerHTML = `\n         <div class='data-row'>\n           <div class='data-card'> Temp: ${data.temperature}°C &nbsp;&nbsp;  Humidity: ${data.humidity}%</div>\n         </div>\n         <div class='data-row'>\n           <div class='data-card'> Pressure: ${data.pressure} mbar</div>\n         </div>\n         <div class='data-row'>\n           <div class='data-card'> AQI: ${data.aqi} &nbsp;&nbsp;  Rainfall: ${data.rainfall ? 'Yes' : 'No'}</div>\n         </div>`;\n       let time = new Date().toLocaleTimeString();\n       // Add new data points\n       combinedChart.data.labels.push(time);\n       combinedChart.data.datasets[0].data.push(data.temperature);  // Temperature\n       combinedChart.data.datasets[1].data.push(data.humidity);    // Humidity\n       // Keep only the last 10 points\n       if (combinedChart.data.labels.length > 10) {\n         combinedChart.data.labels.shift();\n         combinedChart.data.datasets[0].data.shift();\n         combinedChart.data.datasets[1].data.shift();\n       }\n       combinedChart.update();\n     });\n }\n setInterval(fetchWeatherData, 1000);\n</script>\n</body>\n</html>\n)rawliteral\";\n // Send the entire HTML content in one go\n client.print(html);\n}\n//Function to run a local webserver on Arduino for handling client request\nvoid run_local_webserver(){\n WiFiClient client = server.available();\n if (client) {\n   String request = client.readStringUntil('\\r');\n   client.flush();\n   if (request.indexOf(\"GET / \") != -1) {\n     send_web_page(client);\n   } else if (request.indexOf(\"GET /data\") != -1) {\n     send_json_data(client);\n   }\n   client.stop();\n }\n}\n/*-----------------------------------------------------------------\n-----------------------Setup Function------------------------------\n------------------------------------------------------------------*/\nvoid setup() {\n Serial.begin(115200);\n while (!Serial) {}\n matrix.begin();\n wifi_connect();\n server.begin();\n pinMode(Rain_SensorPin, INPUT);\n pinMode(Air_SensorPin, INPUT);\n dht.begin();\n while (!bmp.begin()) {\n   Serial.println(\"BMP085 sensor not found, check wiring!\");\n }\n}\n/*-----------------------------------------------------------\n-----------------Loop function-------------------------------\n-------------------------------------------------------------*/\nvoid loop() {\nif (millis() - lastSensorUpdate >= 1000) {\n   lastSensorUpdate = millis();\n   read_sensor_data();\n}\nif(millis() - lastWiFiCheck >= 5000){\n    lastWiFiCheck = millis();\n    \n    if(WiFi.status() != WL_CONNECTED){\n       wifi_reconnect();\n    }\n}\nrun_local_webserver();  \n}\n```\n\n# Start a Discussion on:\n\n# Add New Comment\n\nLog in or register to post comments"}
{"title":"How to Send SMS with Arduino UNO R4 via Internet?","content":"Ever wished your Arduino could send you an SMS alert when something important happens—like an intruder detected by your DIY security system, or a gas leak in your kitchen? With just an Arduino UNO R4 and a few lines of code, you can make that happen—no expensive GSM module required.\n\nIn this tutorial, I’ll show you how to send SMS using Arduino UNO R4 and the free CircuitDigest Cloud SMS API. It’s perfect for adding instant mobile alerts to your IoT Projects and Arduino projects. Whether it’s fire detection, motion sensing, or home automation, this setup has you covered. Best of all, the API is completely free to use for up to 100 SMS per month and currently supports Indian mobile numbers—more than enough for most hobby and DIY electronics projects.\n\nNote: The CircuitDigest SMS API is a free service designed to support the electronics and maker community. It enables hobbyists, students, and developers to easily send SMS alerts from their projects—perfect for prototyping and testing IoT devices. While this guide focuses on Arduino UNO R4, the API is fully compatible with NodeMCU, ESP32, Raspberry Pi, and virtually any SoC or SoM module capable of connecting to the internet.\n\n# Components Required\n\nTo make Arduino send a text message to your phone without using a GSM module, you don’t need a lot of fancy equipment. The hardware requirement is minimal, cost-efficient, and easily available in the electronic component market. The required components are listed below; make a note of it.\n\nArduino UNO R4 WiFi development board.\n\nArduino UNO R4 WiFi development board.\n\nUSB to Micro USB-B data cable.\n\nUSB to Micro USB-B data cable.\n\n12V DC adaptor with male barrel jack plug / 5V DC USB-B adaptor\n\n12V DC adaptor with male barrel jack plug / 5V DC USB-B adaptor\n\nPersonal computer installed with Arduino IDE\n\nPersonal computer installed with Arduino IDE\n\nOnce you have these components in hand, then you are in one step ahead to make the Arduino send SMS via the internet.\n\n# Hardware setup of the SMS sending Arduino\n\nIn the below image you can see the actual hardware setup of our project, which looks much simpler.\n\nHere I directly connect the Arduino UNO R4 WiFi board through a USB cable, which it consumes power from the PC, this setup is essential for programming the Arduino board from Arduino IDE.\n\nAfter programming the Arduino board, we can either power it from the PC USB port or using external power adaptors.\n\n# Installing the Required Board Libraries in Arduino IDE\n\nBefore you start coding in Arduino IDE to give life to the brain-dead Arduino UNO R4 WiFi board. We need to make sure that the Arduino UNO R4 WiFi board's necessary libraries and board support packages are installed in the Arduino IDE. These libraries are essential for Arduino IDE to get to know about the hardware and communicate with it.\n\nI assume you already have exposure to Arduino IDE. So, I jump straight in to show and tell you how to install these libraries in the Arduino IDE.\n\nSTEP 1:  First open up the Arduino IDE software, then click on the “Tools” option, then click “Board” -> “Board Manager”\n\nSTEP 2:  After clicking the “Board Manager” option, it prompts you to search for the required board library. In the search field, search for “Arduino UNO R4 WiFi”; it will list out Arduino UNO R4 boards. Later, click on the “Install” option to install that board support package.\n\nSTEP 3: After installation gets completed successfully, it will show you “Arduino UNO R4 Boards” installed as shown in the below image.\n\nSTEP 4: After installation, go to the home page, click on the “Tools” option followed by “Boards” -> “Arduino Renesas UNO R4 Board” -> “Arduino UNO R4 WiFi” to verify that it appears on the “Board” option and select that board for later programming purposes.\n\nOk, now the Arduino IDE setup process is over. Next, we are going to discuss how to generate the SMS API from Circuit Digest Cloud.\n\n# Get Free SMS API Key from CircuitDigest Cloud\n\nHere we are going to see how to generate a free SMS API key from the Circuit Digest cloud website. I also show you ready-to-use SMS templates and how we are going to utilize those templates for our project. Let’s move on.\n\nSTEP 1: Visit their official website, “https://www.circuitdigest.cloud/”.After that, you can find their various API services. But we solely focus on SMS API alone. In order to create the SMS API, first we want to log in by clicking the login button.\n\nSTEP 2: After clicking the login button, it shows us both the register page and the login page. If you already have an account in Circuit Digest Cloud, just enter your login credentials to move on. If you don’t have an account, then create an account by filling out details on the Register page.\n\nSTEP 3: Before moving on to API key creation, we want to know about the prebuilt SMS template. Each SMS template has a unique template ID, template name, and template message format with user-customizable variables #var# and #var#. The main reason for this predefined template is to avoid misuse of this free SMS API for spam messaging purposes.\n\nI decided to use the “Service Reminder” SMS template for our project, whose template ID is 106. So I noted the template ID number and decided to assign “AQUA WATER DOCTOR” and “01/01/2024” to the #var# variables.\n\nSo the incoming SMS will look like this\n\nSTEP 4: After logging in, you will find this homepage. Here you can find the “My Account” option in the top right corner. Click on it.\n\nSTEP 5: After that, it shows an option to create an API key; for that we want to complete the captcha and click submit.\n\nSTEP 6: If the entered captcha is correct, it will create an API key for you with a usage limit of 100 SMS per month, and that API key is only valid for 1 month. After the one-month completion, the user needs to create another API key and should follow the below steps. Now we want to note down the currently generated SMS API for later use.\n\nSTEP 7: Next we want to link our phone number for getting an SMS alert. To do that, just scroll down the webpage, where we find an input field to enter our phone number. After entering the phone number and captcha, click on the “Get OTP” button. After that, the pop-up message will show that the OTP will be sent to XXXXXXXXXXX. Click Ok and enter the OTP.\n\nSTEP 8: After clicking OK on the pop-up message, it will ask you to enter the OTP that has been sent to your entered phone number.\n\nAt the same time, you find an OTP has been received on your phone. Just enter that OTP on the webpage and click Verify OTP.\n\nSTEP 9: Finally, we linked our phone number for SMS notification using SMS API. You can cross-verify whether your phone number is linked or not by looking at the linked phone numbers list.\n\nThat’s all, we now learned about how to generate the free SMS API key from the Circuit Digest cloud platform. Next, we are going to dive into the coding part.\n\n# Arduino code to send SMS via Internet\n\n# Overview of the code\n\nBasically, this code connects an Arduino UNO R4 WiFi board to an existing WiFi network using credentials. Later it sends an HTTP POST request to the Circuit Digest SMS API, which includes the user's phone number and SMS details in the JSON format. It then waits for the server’s response code to know whether the SMS was sent successfully or not via the serial monitor.\n\n# Header File\n\n```arduino\n#include \"WiFiS3.h\"\n```\n\n```arduino\n#include \"WiFiS3.h\"\n```\n\nThis header file is essential for enabling the WiFi connection on the Arduino UNO R4 WiFi Board. It includes necessary functions and definitions to interact with WiFi modules like connecting to a WiFi network, checking the WiFi status, and sending HTTP requests over the internet, etc…\n\n# Global Variables\n\n```arduino\n// WiFi credentials\nconst char *ssid = \"Semicon Media\";   // Your network SSID (from arduino_secrets.h)\nconst char *password = \"cracksen1605\";   // Your network password (from arduino_secrets.h)\nint status = WL_IDLE_STATUS; // Connection status\n// API credentials and SMS details\nconst char* apiKey = \"XXXXXXXX\";       // Replace with your API key\nconst char* templateID = \"106\";           // Replace with your template ID\nconst char* mobileNumber = \"XXXXXXXXXXX\"; // Replace with the recipient's mobile number with country code (eg : 91XXXXXXXXXX)\nconst char* var1 = \"AQUA WATER DOCTOR\";         // Replace with your custom variable\nconst char* var2 = \"01/01/2024\";                  // Replace with your custom variable\n```\n\n```arduino\n// WiFi credentials\nconst char *ssid = \"Semicon Media\";   // Your network SSID (from arduino_secrets.h)\nconst char *password = \"cracksen1605\";   // Your network password (from arduino_secrets.h)\nint status = WL_IDLE_STATUS; // Connection status\n// API credentials and SMS details\nconst char* apiKey = \"XXXXXXXX\";       // Replace with your API key\nconst char* templateID = \"106\";           // Replace with your template ID\nconst char* mobileNumber = \"XXXXXXXXXXX\"; // Replace with the recipient's mobile number with country code (eg : 91XXXXXXXXXX)\nconst char* var1 = \"AQUA WATER DOCTOR\";         // Replace with your custom variable\nconst char* var2 = \"01/01/2024\";                  // Replace with your custom variable\n```\n\nThis global variable section defines the necessary credentials for connecting to a WiFi network and SMS API access. It stores wifi credentials as well as the API Key, SMS template ID, recipient mobile number, and custom variables  (var1 and var2) for sending personalized SMS messages through API.\n\n# printWiFiStatus() Function\n\n```arduino\nvoid printWifiStatus() {\n // print the SSID of the network you're attached to:\n Serial.print(\"SSID: \");\n Serial.println(WiFi.SSID());\n // print your board's IP address:\n IPAddress ip = WiFi.localIP();\n Serial.print(\"IP Address: \");\n Serial.println(ip);\n // print the received signal strength:\n long rssi = WiFi.RSSI();\n Serial.print(\"signal strength (RSSI):\");\n Serial.print(rssi);\n Serial.println(\" dBm\");\n}\n```\n\n```arduino\nvoid printWifiStatus() {\n // print the SSID of the network you're attached to:\n Serial.print(\"SSID: \");\n Serial.println(WiFi.SSID());\n // print your board's IP address:\n IPAddress ip = WiFi.localIP();\n Serial.print(\"IP Address: \");\n Serial.println(ip);\n // print the received signal strength:\n long rssi = WiFi.RSSI();\n Serial.print(\"signal strength (RSSI):\");\n Serial.print(rssi);\n Serial.println(\" dBm\");\n}\n```\n\nThis function is used to print the WiFi connection details in the serial monitor. It prints the SSID of the connected network, the device’s local IP address, and signal strength in the decibels. This function is helpful for debugging, especially if the code is not working properly as we expected.\n\n# sendSMS() Function\n\n```arduino\nvoid sendSMS() {\n if (WiFi.status() == WL_CONNECTED) {\n   WiFiClient client; // Initialize WiFi client\n   \n   String apiUrl = \"/send_sms?ID=\" + String(templateID);\n   Serial.print(\"Connecting to server...\");\n   if (client.connect(\"www.circuitdigest.cloud\", 80)) { // Connect to the server\n     Serial.println(\"connected!\");\n     // Create the HTTP POST request\n     String payload = \"{\\\"mobiles\\\":\\\"\" + String(mobileNumber) + \n                      \"\\\",\\\"var1\\\":\\\"\" + String(var1) + \n                      \"\\\",\\\"var2\\\":\\\"\" + String(var2) + \"\\\"}\";\n     // Send HTTP request headers\n     client.println(\"POST \" + apiUrl + \" HTTP/1.1\");\n     client.println(\"Host: www.circuitdigest.cloud\");\n     client.println(\"Authorization: \" + String(apiKey));\n     client.println(\"Content-Type: application/json\");\n     client.println(\"Content-Length: \" + String(payload.length()));\n     client.println(); // End of headers\n     client.println(payload); // Send the JSON payload\n     // Wait for the response\n     int responseCode = -1; // Variable to store HTTP response code\n     while (client.connected() || client.available()) {\n       if (client.available()) {\n         String line = client.readStringUntil('\\n'); // Read a line from the response\n         Serial.println(line); // Print the response line (for debugging)\n         // Check for the HTTP response code\n         if (line.startsWith(\"HTTP/\")) {\n           responseCode = line.substring(9, 12).toInt(); // Extract response code (e.g., 200, 404)\n           Serial.print(\"HTTP Response Code: \");\n           Serial.println(responseCode);\n         }\n         // Stop reading headers once we reach an empty line\n         if (line == \"\\r\") {\n           break;\n         }\n       }\n     }\n     \n     // Check response\n     if (responseCode == 200) {\n       Serial.println(\"SMS sent successfully!\");\n     } else {\n       Serial.print(\"Failed to send SMS. Error code: \");\n       Serial.println(responseCode);\n     }\n     \n     \n     client.stop(); // Disconnect from the server\n   } else {\n     Serial.println(\"Connection to server failed!\");\n   }\n } else {\n   Serial.println(\"WiFi not connected!\");\n }\n}\n```\n\n```arduino\nvoid sendSMS() {\n if (WiFi.status() == WL_CONNECTED) {\n   WiFiClient client; // Initialize WiFi client\n   \n   String apiUrl = \"/send_sms?ID=\" + String(templateID);\n   Serial.print(\"Connecting to server...\");\n   if (client.connect(\"www.circuitdigest.cloud\", 80)) { // Connect to the server\n     Serial.println(\"connected!\");\n     // Create the HTTP POST request\n     String payload = \"{\\\"mobiles\\\":\\\"\" + String(mobileNumber) + \n                      \"\\\",\\\"var1\\\":\\\"\" + String(var1) + \n                      \"\\\",\\\"var2\\\":\\\"\" + String(var2) + \"\\\"}\";\n     // Send HTTP request headers\n     client.println(\"POST \" + apiUrl + \" HTTP/1.1\");\n     client.println(\"Host: www.circuitdigest.cloud\");\n     client.println(\"Authorization: \" + String(apiKey));\n     client.println(\"Content-Type: application/json\");\n     client.println(\"Content-Length: \" + String(payload.length()));\n     client.println(); // End of headers\n     client.println(payload); // Send the JSON payload\n     // Wait for the response\n     int responseCode = -1; // Variable to store HTTP response code\n     while (client.connected() || client.available()) {\n       if (client.available()) {\n         String line = client.readStringUntil('\\n'); // Read a line from the response\n         Serial.println(line); // Print the response line (for debugging)\n         // Check for the HTTP response code\n         if (line.startsWith(\"HTTP/\")) {\n           responseCode = line.substring(9, 12).toInt(); // Extract response code (e.g., 200, 404)\n           Serial.print(\"HTTP Response Code: \");\n           Serial.println(responseCode);\n         }\n         // Stop reading headers once we reach an empty line\n         if (line == \"\\r\") {\n           break;\n         }\n       }\n     }\n     \n     // Check response\n     if (responseCode == 200) {\n       Serial.println(\"SMS sent successfully!\");\n     } else {\n       Serial.print(\"Failed to send SMS. Error code: \");\n       Serial.println(responseCode);\n     }\n     \n     \n     client.stop(); // Disconnect from the server\n   } else {\n     Serial.println(\"Connection to server failed!\");\n   }\n } else {\n   Serial.println(\"WiFi not connected!\");\n }\n}\n```\n\nThe “sendSMS()” function first checks whether the WiFi is connected, then creates a WiFi client to establish a connection with the server. It constructs an HTTP POST request with necessary headers and JSON payload containing the SMS details. After sending the request, it waits for the server’s response code to determine the SMS sent status.\n\n# setup() function\n\n```arduino\nvoid setup() {\n //Initialize serial and wait for port to open:\n Serial.begin(9600);\n while (!Serial) {\n   ; // wait for serial port to connect. Needed for native USB port only\n }\n \n // check for the WiFi module:\n if (WiFi.status() == WL_NO_MODULE) {\n   Serial.println(\"Communication with WiFi module failed!\");\n   // don't continue\n   while (true);\n }\n \n String fv = WiFi.firmwareVersion();\n if (fv < WIFI_FIRMWARE_LATEST_VERSION) {\n   Serial.println(\"Please upgrade the firmware\");\n }\n \n // attempt to connect to WiFi network:\n while (status != WL_CONNECTED) {\n   Serial.print(\"Attempting to connect to SSID: \");\n   Serial.println(ssid);\n   // Connect to WPA/WPA2 network. Change this line if using open or WEP network:\n   status = WiFi.begin(ssid, password);\n    \n   // wait 1 seconds for connection:\n   delay(1000);\n }\n printWifiStatus();\n \n // Send the SMS\n sendSMS();\n}\n```\n\n```arduino\nvoid setup() {\n //Initialize serial and wait for port to open:\n Serial.begin(9600);\n while (!Serial) {\n   ; // wait for serial port to connect. Needed for native USB port only\n }\n \n // check for the WiFi module:\n if (WiFi.status() == WL_NO_MODULE) {\n   Serial.println(\"Communication with WiFi module failed!\");\n   // don't continue\n   while (true);\n }\n \n String fv = WiFi.firmwareVersion();\n if (fv < WIFI_FIRMWARE_LATEST_VERSION) {\n   Serial.println(\"Please upgrade the firmware\");\n }\n \n // attempt to connect to WiFi network:\n while (status != WL_CONNECTED) {\n   Serial.print(\"Attempting to connect to SSID: \");\n   Serial.println(ssid);\n   // Connect to WPA/WPA2 network. Change this line if using open or WEP network:\n   status = WiFi.begin(ssid, password);\n    \n   // wait 1 seconds for connection:\n   delay(1000);\n }\n printWifiStatus();\n \n // Send the SMS\n sendSMS();\n}\n```\n\nThis function is considered as the entry point of the program execution. This function first initializes the serial monitor at a baud rate of 9600 for debugging purposes. Later it checks for whether the Wi-Fi module is connected properly, if not, it will enter into an infinite loop. If the firmware is outdated, it prompts the user to upgrade it.\n\nAfter making the successful communication with the wifi module, it makes the Arduino connect to the wifi network using WiFi credentials. Once connected, it calls the “printWiFiStatus()” function to print connection details and calls the “sendSMS()” function to send SMS to the right phone number.\n\n# loop() function\n\n```arduino\nvoid loop() {\n // Nothing to do in the loop\n}\n```\n\n```arduino\nvoid loop() {\n // Nothing to do in the loop\n}\n```\n\nIt is a loop() function, which starts to execute after the setup() execution is finished. Here the loop() function is empty. But however, if you want to uplift this project by adding new functionality, definitely you will need this loop() function.\n\nThat’s all, I hope you understand this code very well. Let's compile and dump those binary to your Arduino UNO R4 WiFi board to turn it into a functional one.\n\n# Sending SMS with Arduino Using the Reset Button\n\nFinally, we make Arduino send text messages via the Internet without the need of expensive GSM modules. As I previously mentioned the above program makes Arduino send only one SMS during reset, after that it gets stuck on an infinite loop. However, we can able to send SMS whenever we want by just pressing the reset button.\n\nBelow you can able to see our actual hardware setup, which sends SMS to my phone after pressing the reset button of Arduino.\n\nYou will be able to see the SMS sent status in the serial monitor of our Arduino IDE.\n\nThat’s all, now we are able to send SMS to your phone by simply pressing the Push button (Reset button). But you can further improve this project by sending an SMS when a fire sensor or security system gets triggered.\n\n# GitHub Repository with Code and Circuit\n\n# Projects using Circuit Digest API\n\nCircuit Digest offers a variety of APIs that can be integrated into projects involving microcontrollers like Arduino, ESP32, and many more.\n\nHow to Send SMS from NodeMCU without Using GSM Module?\n\nLearn how to send SMS alerts from NodeMCU ESP8266 without a GSM module using the Circuit Digest Cloud API. This step-by-step guide covers hardware setup, API integration, and Arduino code.\n\nGPS Visualizer to Upload Data and Visualize GPS Maps for Arduino, ESP32 & other Embedded Devices\n\nLearn how to create a GPS Visualizer for IoT-based GPS tracking projects. This guide covers real-time location tracking, data visualization, and integration with Circuit Digest Cloud API.\n\nHow to scan QR Codes using ESP32-CAM module?\n\nLearn how to implement a Number Plate Recognition API for low-power embedded SoC boards. This guide covers API integration, image processing, and real-time license plate detection using Circuit Digest Cloud.\n\n# Complete Project Code\n\n```arduino\n//Arduino UNO R4 code to send SMS using the CircuitDigest Cloud API service\n#include \"WiFiS3.h\"\n// WiFi credentials\nconst char *ssid = \"Semicon Media\";   // Your network SSID (from arduino_secrets.h)\nconst char *password = \"cracksen1605\";   // Your network password (from arduino_secrets.h)\nint status = WL_IDLE_STATUS; // Connection status\n// API credentials and SMS details\nconst char* apiKey = \"XXXXXXXX\";       // Replace with your API key\nconst char* templateID = \"106\";           // Replace with your template ID\nconst char* mobileNumber = \"XXXXXXXXXXX\"; // Replace with the recipient's mobile number with country code (eg : 91XXXXXXXXXX)\nconst char* var1 = \"AQUA WATER DOCTOR\";         // Replace with your custom variable\nconst char* var2 = \"01/01/2024\";                  // Replace with your custom variable\nvoid printWifiStatus() {\n // print the SSID of the network you're attached to:\n Serial.print(\"SSID: \");\n Serial.println(WiFi.SSID());\n // print your board's IP address:\n IPAddress ip = WiFi.localIP();\n Serial.print(\"IP Address: \");\n Serial.println(ip);\n // print the received signal strength:\n long rssi = WiFi.RSSI();\n Serial.print(\"signal strength (RSSI):\");\n Serial.print(rssi);\n Serial.println(\" dBm\");\n}\n\nvoid sendSMS() {\n if (WiFi.status() == WL_CONNECTED) {\n   WiFiClient client; // Initialize WiFi client\n   \n   String apiUrl = \"/send_sms?ID=\" + String(templateID);\n   Serial.print(\"Connecting to server...\");\n   if (client.connect(\"www.circuitdigest.cloud\", 80)) { // Connect to the server\n     Serial.println(\"connected!\");\n     // Create the HTTP POST request\n     String payload = \"{\\\"mobiles\\\":\\\"\" + String(mobileNumber) + \n                      \"\\\",\\\"var1\\\":\\\"\" + String(var1) + \n                      \"\\\",\\\"var2\\\":\\\"\" + String(var2) + \"\\\"}\";\n     // Send HTTP request headers\n     client.println(\"POST \" + apiUrl + \" HTTP/1.1\");\n     client.println(\"Host: www.circuitdigest.cloud\");\n     client.println(\"Authorization: \" + String(apiKey));\n     client.println(\"Content-Type: application/json\");\n     client.println(\"Content-Length: \" + String(payload.length()));\n     client.println(); // End of headers\n     client.println(payload); // Send the JSON payload\n     // Wait for the response\n     int responseCode = -1; // Variable to store HTTP response code\n     while (client.connected() || client.available()) {\n       if (client.available()) {\n         String line = client.readStringUntil('\\n'); // Read a line from the response\n         Serial.println(line); // Print the response line (for debugging)\n         // Check for the HTTP response code\n         if (line.startsWith(\"HTTP/\")) {\n           responseCode = line.substring(9, 12).toInt(); // Extract response code (e.g., 200, 404)\n           Serial.print(\"HTTP Response Code: \");\n           Serial.println(responseCode);\n         }\n         // Stop reading headers once we reach an empty line\n         if (line == \"\\r\") {\n           break;\n         }\n       }\n     }\n     \n     // Check response\n     if (responseCode == 200) {\n       Serial.println(\"SMS sent successfully!\");\n     } else {\n       Serial.print(\"Failed to send SMS. Error code: \");\n       Serial.println(responseCode);\n     }\n     \n     \n     client.stop(); // Disconnect from the server\n   } else {\n     Serial.println(\"Connection to server failed!\");\n   }\n } else {\n   Serial.println(\"WiFi not connected!\");\n }\n}\n\nvoid setup() {\n //Initialize serial and wait for port to open:\n Serial.begin(9600);\n while (!Serial) {\n   ; // wait for serial port to connect. Needed for native USB port only\n }\n \n // check for the WiFi module:\n if (WiFi.status() == WL_NO_MODULE) {\n   Serial.println(\"Communication with WiFi module failed!\");\n   // don't continue\n   while (true);\n }\n \n String fv = WiFi.firmwareVersion();\n if (fv < WIFI_FIRMWARE_LATEST_VERSION) {\n   Serial.println(\"Please upgrade the firmware\");\n }\n \n // attempt to connect to WiFi network:\n while (status != WL_CONNECTED) {\n   Serial.print(\"Attempting to connect to SSID: \");\n   Serial.println(ssid);\n   // Connect to WPA/WPA2 network. Change this line if using open or WEP network:\n   status = WiFi.begin(ssid, password);\n    \n   // wait 1 seconds for connection:\n   delay(1000);\n }\n printWifiStatus();\n \n // Send the SMS\n sendSMS();\n}\nvoid loop() {\n // Nothing to do in the loop\n}\n```\n\n```arduino\n//Arduino UNO R4 code to send SMS using the CircuitDigest Cloud API service\n#include \"WiFiS3.h\"\n// WiFi credentials\nconst char *ssid = \"Semicon Media\";   // Your network SSID (from arduino_secrets.h)\nconst char *password = \"cracksen1605\";   // Your network password (from arduino_secrets.h)\nint status = WL_IDLE_STATUS; // Connection status\n// API credentials and SMS details\nconst char* apiKey = \"XXXXXXXX\";       // Replace with your API key\nconst char* templateID = \"106\";           // Replace with your template ID\nconst char* mobileNumber = \"XXXXXXXXXXX\"; // Replace with the recipient's mobile number with country code (eg : 91XXXXXXXXXX)\nconst char* var1 = \"AQUA WATER DOCTOR\";         // Replace with your custom variable\nconst char* var2 = \"01/01/2024\";                  // Replace with your custom variable\nvoid printWifiStatus() {\n // print the SSID of the network you're attached to:\n Serial.print(\"SSID: \");\n Serial.println(WiFi.SSID());\n // print your board's IP address:\n IPAddress ip = WiFi.localIP();\n Serial.print(\"IP Address: \");\n Serial.println(ip);\n // print the received signal strength:\n long rssi = WiFi.RSSI();\n Serial.print(\"signal strength (RSSI):\");\n Serial.print(rssi);\n Serial.println(\" dBm\");\n}\n\nvoid sendSMS() {\n if (WiFi.status() == WL_CONNECTED) {\n   WiFiClient client; // Initialize WiFi client\n   \n   String apiUrl = \"/send_sms?ID=\" + String(templateID);\n   Serial.print(\"Connecting to server...\");\n   if (client.connect(\"www.circuitdigest.cloud\", 80)) { // Connect to the server\n     Serial.println(\"connected!\");\n     // Create the HTTP POST request\n     String payload = \"{\\\"mobiles\\\":\\\"\" + String(mobileNumber) + \n                      \"\\\",\\\"var1\\\":\\\"\" + String(var1) + \n                      \"\\\",\\\"var2\\\":\\\"\" + String(var2) + \"\\\"}\";\n     // Send HTTP request headers\n     client.println(\"POST \" + apiUrl + \" HTTP/1.1\");\n     client.println(\"Host: www.circuitdigest.cloud\");\n     client.println(\"Authorization: \" + String(apiKey));\n     client.println(\"Content-Type: application/json\");\n     client.println(\"Content-Length: \" + String(payload.length()));\n     client.println(); // End of headers\n     client.println(payload); // Send the JSON payload\n     // Wait for the response\n     int responseCode = -1; // Variable to store HTTP response code\n     while (client.connected() || client.available()) {\n       if (client.available()) {\n         String line = client.readStringUntil('\\n'); // Read a line from the response\n         Serial.println(line); // Print the response line (for debugging)\n         // Check for the HTTP response code\n         if (line.startsWith(\"HTTP/\")) {\n           responseCode = line.substring(9, 12).toInt(); // Extract response code (e.g., 200, 404)\n           Serial.print(\"HTTP Response Code: \");\n           Serial.println(responseCode);\n         }\n         // Stop reading headers once we reach an empty line\n         if (line == \"\\r\") {\n           break;\n         }\n       }\n     }\n     \n     // Check response\n     if (responseCode == 200) {\n       Serial.println(\"SMS sent successfully!\");\n     } else {\n       Serial.print(\"Failed to send SMS. Error code: \");\n       Serial.println(responseCode);\n     }\n     \n     \n     client.stop(); // Disconnect from the server\n   } else {\n     Serial.println(\"Connection to server failed!\");\n   }\n } else {\n   Serial.println(\"WiFi not connected!\");\n }\n}\n\nvoid setup() {\n //Initialize serial and wait for port to open:\n Serial.begin(9600);\n while (!Serial) {\n   ; // wait for serial port to connect. Needed for native USB port only\n }\n \n // check for the WiFi module:\n if (WiFi.status() == WL_NO_MODULE) {\n   Serial.println(\"Communication with WiFi module failed!\");\n   // don't continue\n   while (true);\n }\n \n String fv = WiFi.firmwareVersion();\n if (fv < WIFI_FIRMWARE_LATEST_VERSION) {\n   Serial.println(\"Please upgrade the firmware\");\n }\n \n // attempt to connect to WiFi network:\n while (status != WL_CONNECTED) {\n   Serial.print(\"Attempting to connect to SSID: \");\n   Serial.println(ssid);\n   // Connect to WPA/WPA2 network. Change this line if using open or WEP network:\n   status = WiFi.begin(ssid, password);\n    \n   // wait 1 seconds for connection:\n   delay(1000);\n }\n printWifiStatus();\n \n // Send the SMS\n sendSMS();\n}\nvoid loop() {\n // Nothing to do in the loop\n}\n```\n\n# Start a Discussion on:\n\n# Add New Comment\n\nLog in or register to post comments"}
{"title":"How to build Blind Stick using Arduino Nano and Ultrasonic sensor","content":"Walking safely and confidently can be a challenging task for visually impaired individuals, but with the help of technology, we can make it easier for them. This DIY Blind Stick is an innovative yet simple solution that is designed to help users detect obstacles in their path. Using an Arduino Nano, ultrasonic sensor, and buzzer, it can sense objects in their way and provide an instant audible alert to them. So they can navigate independently.\n\nThe best part of this blind stick Arduino project is that it’s easy to build, affordable and products similar to this, like Torchit has even been featured on shark tank. The ultrasonic sensor acts like a third eye, helping to calculate the distance to objects. The Arduino keeps on processing the data from the ultrasonic sensor, and it quickly triggers the Audio alert when it detects something nearby.\n\nHere, you’ll learn how to interface the ultrasonic sensor with Arduino and how to write code that responds to nearby obstacles instantly with zero latency. This is crucial for the navigation of people with vision challenges. Let’s start building this Arduino blind stick and make life safer for those who need it! You can also check out our other Arduino Projects if you need more ideas for building projects using Arduino.\n\n# How does a Blind Stick using Arduino Work?\n\nThis Arduino walking stick is designed to help visually impaired people move around safely and independently. It works by detecting obstacles and warning the people through a buzzer beep alert. Here, I also added an LED alert to help people with partial vision loss. Ok, let’s see how this smart stick works step by step:\n\n# Detecting Obstacles\n\nThe heart of this stick is the ultrasonic sensor, which acts like the stick’s \"eyes\". It sends out ultrasonic waves (whenever the TRIG pin of the sensor gets triggered by Arduino) that bounce off objects and return to the sensor. Later, it measures the time it takes for the waves to come back and finally send out that measured time as a (timing pulse signal) to Arduino via ECHO pin.\n\nIf you are new in handling the Ultrasonic Sensor, feel free to check out this Arduino Ultrasonic sensor tutorial for a detailed explanation.\n\n# Data Reception and Distance Calculation\n\nThe Arduino acts as the brain of the walking stick. It takes the timing pulse signal from the ECHO pin of the Ultrasonic sensor for calculating the time taken by the wave to hit and bounce back from the object.\n\nAfter knowing the time taken in microseconds, the distance in centimeters is calculated using the formula below.\n\n{Distance = (Time taken by the signal to Hit and bounce back / 2)    /   29.1}\n\nFor example, let’s say the signal takes 500 microseconds to hit and bounce back, then\n\nDistance = (500 / 2) / 29.1   => 8.59 cm\n\nThe object is approximately 8.59 cm away from the sensor.\n\n# Audio Based Obstacle Detection and Alerts Using Arduino\n\nWhen an obstacle is detected within the safety range(50 cm), the Arduino triggers two alert systems:\n\nBuzzer: It makes a sound to warn the user of the nearby object. The closer the object, the faster the buzzer can beep to give the sense that the object is nearing them.\n\nBuzzer: It makes a sound to warn the user of the nearby object. The closer the object, the faster the buzzer can beep to give the sense that the object is nearing them.\n\nLED Light: A light flashes to provide a visual alert for those with partial vision. It also increase it flash rate when the object is nearing them.\n\nLED Light: A light flashes to provide a visual alert for those with partial vision. It also increase it flash rate when the object is nearing them.\n\nThat’s all about the working of our Arduino Blind Man walking stick. Let's know what are the things do we need to build it.\n\n# Components Required for The Smart Blind Stick\n\nHere is the simple list of components, which is needed to build a Blind Stick project using Arduino.\n\nArduino Nano\n\nArduino Nano\n\nHC-SR04 Ultrasonic Sensor\n\nHC-SR04 Ultrasonic Sensor\n\n5V Active Buzzer\n\n5V Active Buzzer\n\nLight-Emitting Diode\n\nLight-Emitting Diode\n\nCurrent Limiting Resistor\n\nCurrent Limiting Resistor\n\n9V Battery\n\n9V Battery\n\nSlidder switch / on-off switch\n\nSlidder switch / on-off switch\n\nBreadboard\n\nBreadboard\n\nConnecting wires\n\nConnecting wires\n\nPVC Pipe\n\nPVC Pipe\n\nUp next, we’ll take a look at the block diagram of this Smart Walking Stick using Arduino, giving a clear overview of how its components work together.\n\n# Block Diagram Representation of Arduino-Based Blind Stick\n\nThe following block diagram shows the topology of a smart blind stick using Arduino Nano, showing how each component is related to others.\n\nI hope you understand the complete system overview. Let’s start to design the circuit diagram for our Smart Blind Stick.\n\n# Smart Blind Stick using Arduino Circuit Diagram\n\nThe below circuit diagram shows the complete hardware wiring setup of the Arduino-based Smart Walking Stick for the Blind people, detailing how the Arduino Nano, Ultrasonic sensors, Buzzer, and Led lights are secured together to form a functional blind stick hardware unit.\n\nFor the power supply, I decided to use a 9V battery, but in reality, it better to use the rechargeable 9V battery. Here, you can find that i am powering the ultrasonic sensor directly from the Arduino GPIO pins to avoid connection complexity, especially in Smaller breadboards.\n\nNote that the ultrasonic sensor generally consumes only 15mA, which is enough to power it directly from Arduino GPIO.\n\n# Hardware Connections of Obstacle Detection Stick for the Blind\n\nBelow is the actual hardware setup used to build our ultrasonic blind walking stick using arduino, utilizing Arduino and Ultrasonic sensors. This setup is constructed based on the previously discussed circuit diagram, demonstrating the practical assembly of the system.\n\nThat’s all about the hardware wiring connection part, it’s time to bring back life to our actual hardware by coding software for it. Let's move on to the coding part.\n\n# Blind Stick using Arduino Code\n\nThe complete Arduino Code to build a smart blind stick using Arduino nano and an Ultrasonic sensor is given at the bottom of this page. This is the code for the Smart blind stick using Arduino and Ultrasonic sensor. It continuously calculates the distance of the object using the ultrasonic sensor and keeps on checking whether the distance is <= 50 && >=0. If the distance is within the range, it triggers the alerts. Also, increases the alert rate when the distance decreases.\n\nHere, in this code, I use millis() to do multitasking for both led blink and buzzer beep tasks. If you are hearing multitasking in Arduino newly, I recommended you to check out this Arduino Multitaking tutorial for an in-depth explanation.\n\n# Pin Definitions using Macros\n\n```arduino\n/* ========================== Pin Definitions ========================== */\n// Ultrasonic Sensor Pins\n#define vccPin 4       // Ultrasonic sensor VCC pin\n#define trigPin 5      // Ultrasonic sensor Trigger pin\n#define echoPin 6      // Ultrasonic sensor Echo pin\n#define gndPin 7       // Ultrasonic sensor GND pin\n// Output Signal Pins\n#define ledPin 9       // LED signal pin\n#define buzzerPin 2  // Buzzer signal pin\n```\n\n```arduino\n/* ========================== Pin Definitions ========================== */\n// Ultrasonic Sensor Pins\n#define vccPin 4       // Ultrasonic sensor VCC pin\n#define trigPin 5      // Ultrasonic sensor Trigger pin\n#define echoPin 6      // Ultrasonic sensor Echo pin\n#define gndPin 7       // Ultrasonic sensor GND pin\n// Output Signal Pins\n#define ledPin 9       // LED signal pin\n#define buzzerPin 2  // Buzzer signal pin\n```\n\nThis section defines the pin connection details of the ultrasonic sensor, led, and active buzzer. Which is going to be connected to the Arduino GPIO pins.\n\n# Global Variables for Holding Important Data\n\n```arduino\n/* ========================== Ultrasonic Sensor Data ========================== */\nlong duration = 0;     // Duration of ultrasonic signal bounce-back (in microseconds)\nint distance = 0;      // Calculated distance between the object and sensor (in cm)\n```\n\n```arduino\n/* ========================== Ultrasonic Sensor Data ========================== */\nlong duration = 0;     // Duration of ultrasonic signal bounce-back (in microseconds)\nint distance = 0;      // Calculated distance between the object and sensor (in cm)\n```\n\nThese variables are used to store relevant data from the ultrasonic sensor. Here, “duration” holds the time taken for the ultrasonic signal to bounce back, and “distance” stores the calculated distance value.\n\n```arduino\n/* ========================== Timing Variables ========================== */\n// Stores the last time LED and Buzzer states were updated\nunsigned long previousLedMillis = 0;\nunsigned long previousBuzzerMillis = 0;\n```\n\n```arduino\n/* ========================== Timing Variables ========================== */\n// Stores the last time LED and Buzzer states were updated\nunsigned long previousLedMillis = 0;\nunsigned long previousBuzzerMillis = 0;\n```\n\nHere, these variable contains the previousMillis value for the Led and Buzzer, and it initially set down to zero, to make it work properly in the first trigger of both  LED and Buzzer alerts.\n\n```arduino\n/* ========================== Multitasking Interval Variables ========================== */\n// Determines the interval between LED blinks and buzzer beeps (in milliseconds)\nint ledInterval = 0;        // LED blink interval — varies based on object distance\nint buzzerInterval = 0;     // Buzzer beep interval — varies based on object distance\n```\n\n```arduino\n/* ========================== Multitasking Interval Variables ========================== */\n// Determines the interval between LED blinks and buzzer beeps (in milliseconds)\nint ledInterval = 0;        // LED blink interval — varies based on object distance\nint buzzerInterval = 0;     // Buzzer beep interval — varies based on object distance\n```\n\nThese variables are essential for multitasking, that is, varying the LED blink rate and buzzer beep rate independently without disturbing each other. In simpler words, it defines the rate at which the buzzer and LED can blink. Initially, it was set down to zero. But while executing it, get updated based on the distance variable.\n\n```arduino\n/* ========================== State Variables ========================== */\n// Tracks the current state of LED and Buzzer\nbool ledState = LOW;        // LED state (ON or OFF)\nbool buzzerState = LOW;     // Buzzer state (ON or OFF)\n```\n\n```arduino\n/* ========================== State Variables ========================== */\n// Tracks the current state of LED and Buzzer\nbool ledState = LOW;        // LED state (ON or OFF)\nbool buzzerState = LOW;     // Buzzer state (ON or OFF)\n```\n\nThese state variables are used to hold and track the current state of the LED and buzzer, whether in the ON or OFF state.\n\n```arduino\n/* ========================== Current Time Variable ========================== */\n// Holds the current time in milliseconds\nunsigned long currentMillis = 0;\n```\n\n```arduino\n/* ========================== Current Time Variable ========================== */\n// Holds the current time in milliseconds\nunsigned long currentMillis = 0;\n```\n\nThese currenrMillis variable is used to track the timer value, after the time get start to run. This holding value is crucial to multitasking both the led flash rate and buzzer beep rate independently without blocking each other.\n\n# measureDistance() function\n\n```arduino\n/* ========================== Measure Distance ========================== */\n/**\n* Triggers the ultrasonic sensor and calculates the distance to the nearest object.\n*/\nvoid measureDistance() {\n // Send a 10µs pulse to the trigger pin to start the measurement\n digitalWrite(trigPin, LOW);\n delayMicroseconds(2);\n digitalWrite(trigPin, HIGH);\n delayMicroseconds(10);\n digitalWrite(trigPin, LOW);\n // Measure the duration of the pulse on the echo pin\n duration = pulseIn(echoPin, HIGH);\n // Calculate the distance in centimeters (speed of sound: 343 m/s)\n distance = (duration / 2) / 29.1;\n // Output the distance measurement to the Serial Monitor\n Serial.print(\"Distance: \");\n Serial.print(distance);\n Serial.println(\" cm\");\n}\n```\n\n```arduino\n/* ========================== Measure Distance ========================== */\n/**\n* Triggers the ultrasonic sensor and calculates the distance to the nearest object.\n*/\nvoid measureDistance() {\n // Send a 10µs pulse to the trigger pin to start the measurement\n digitalWrite(trigPin, LOW);\n delayMicroseconds(2);\n digitalWrite(trigPin, HIGH);\n delayMicroseconds(10);\n digitalWrite(trigPin, LOW);\n // Measure the duration of the pulse on the echo pin\n duration = pulseIn(echoPin, HIGH);\n // Calculate the distance in centimeters (speed of sound: 343 m/s)\n distance = (duration / 2) / 29.1;\n // Output the distance measurement to the Serial Monitor\n Serial.print(\"Distance: \");\n Serial.print(distance);\n Serial.println(\" cm\");\n}\n```\n\nThe function actually triggers the ultrasonic sensor by sending the sequence of low and high pulses to the TRIG pin. It makes ultrasonic sonic sensors to send a sound wave. It invokes the pulseIn() function to look for an echo signal from the ECHO pin of the sensor to measure the time taken by the signal to bounce back.\n\nAfter getting time, it uses a simple formula, which I mentioned previously, to calculate the distance from the object in centimeters. Finally, it makes that distance value to get printed on the serial monitor.\n\n# task_triggerBuzzer()\n\n```arduino\n/* ========================== Task: Trigger Buzzer ========================== */\n/**\n* Controls the buzzer beep rate based on object proximity.\n* Buzzer beeps faster when the object is closer.\n*/\nvoid task_triggerBuzzer() {\n // Map the distance to a buzzer interval (30ms when close, 100ms when far)\n buzzerInterval = map(distance, 0, 50, 30, 100);\n // Toggle the buzzer state when the interval has passed\n if (currentMillis - previousBuzzerMillis >= buzzerInterval) {\n   previousBuzzerMillis = currentMillis;      // Update the last buzzer time\n   buzzerState = !buzzerState;                // Toggle the buzzer state\n   digitalWrite(buzzerPin, buzzerState);      // Apply the new state to the pin\n }\n}\n```\n\n```arduino\n/* ========================== Task: Trigger Buzzer ========================== */\n/**\n* Controls the buzzer beep rate based on object proximity.\n* Buzzer beeps faster when the object is closer.\n*/\nvoid task_triggerBuzzer() {\n // Map the distance to a buzzer interval (30ms when close, 100ms when far)\n buzzerInterval = map(distance, 0, 50, 30, 100);\n // Toggle the buzzer state when the interval has passed\n if (currentMillis - previousBuzzerMillis >= buzzerInterval) {\n   previousBuzzerMillis = currentMillis;      // Update the last buzzer time\n   buzzerState = !buzzerState;                // Toggle the buzzer state\n   digitalWrite(buzzerPin, buzzerState);      // Apply the new state to the pin\n }\n}\n```\n\nThis function, task_triggerBuzzer(), controls how fast the buzzer beeps based on the object’s distance. Here, it keeps on mapping the buzzerInterval value based on the object’s distance. Which in turn affects the buzzer beep rate accordingly.\n\nHere, you can find the map(distance, 0, 50, 30, 100); it means mapping gets done based on distance value from 0cm to 30cm and time interval from 30ms to 100ms. i.e, at 0cm, the buzzer beeps at every 30ms once, and at 50 cm, the buzzer beeps at every 100ms once.\n\n# task_triggerLed()\n\n```arduino\n/* ========================== Task: Trigger LED ========================== */\n/**\n* Controls the LED blink rate based on object proximity.\n* LED blinks faster when the object is closer.\n*/\nvoid task_triggerLed() {\n // Map the distance to an LED interval (150ms when close, 1000ms when far)\n ledInterval = map(distance, 0, 50, 150, 1000);\n // Toggle the LED state when the interval has passed\n if (currentMillis - previousLedMillis >= ledInterval) {\n   previousLedMillis = currentMillis;         // Update the last LED time\n   ledState = !ledState;                      // Toggle the LED state\n   digitalWrite(ledPin, ledState);            // Apply the new state to the pin\n }\n}\n```\n\n```arduino\n/* ========================== Task: Trigger LED ========================== */\n/**\n* Controls the LED blink rate based on object proximity.\n* LED blinks faster when the object is closer.\n*/\nvoid task_triggerLed() {\n // Map the distance to an LED interval (150ms when close, 1000ms when far)\n ledInterval = map(distance, 0, 50, 150, 1000);\n // Toggle the LED state when the interval has passed\n if (currentMillis - previousLedMillis >= ledInterval) {\n   previousLedMillis = currentMillis;         // Update the last LED time\n   ledState = !ledState;                      // Toggle the LED state\n   digitalWrite(ledPin, ledState);            // Apply the new state to the pin\n }\n}\n```\n\nThis function, task_triggerLed() controls how fast the led can flash based on the object’s distance. Here, it keeps on mapping the ledInterval value based on the object’s distance. Which in turn affects the led flash rate accordingly.\n\nHere, you can find map(distance, 0, 50, 150, 1000); it means mapping gets done based on distance value from 0cm to 30cm and time interval from 150ms to 1000ms.\n\ni.e, at 0cm, the led flashes at every 150ms once, and at 30 cm, the led flashes at every 1000ms once.\n\n# stopAlert()\n\n```arduino\n/* ========================== Stop Alerts ========================== */\n/**\n* Deactivates the LED and buzzer when no object is within range.\n*/\nvoid stopAlerts() {\n digitalWrite(buzzerPin, LOW);                // Turn off the buzzer\n digitalWrite(ledPin, LOW);                   // Turn off the LED\n ledState = LOW;                              // Reset LED state\n buzzerState = LOW;                           // Reset buzzer state\n}\n```\n\n```arduino\n/* ========================== Stop Alerts ========================== */\n/**\n* Deactivates the LED and buzzer when no object is within range.\n*/\nvoid stopAlerts() {\n digitalWrite(buzzerPin, LOW);                // Turn off the buzzer\n digitalWrite(ledPin, LOW);                   // Turn off the LED\n ledState = LOW;                              // Reset LED state\n buzzerState = LOW;                           // Reset buzzer state\n}\n```\n\nThis stopAlert() function is used to stop the buzzer beep alert and led flash alert by making them low using the digitalWrite() function.\n\n# setup()\n\n```arduino\n/* ========================== Setup Function ========================== */\n/**\n* Initializes hardware components, configures I/O pins, and stabilizes the sensor.\n*/\nvoid setup() {\n // Configure Ultrasonic Sensor Pins\n pinMode(vccPin, OUTPUT);\n pinMode(trigPin, OUTPUT);\n pinMode(echoPin, INPUT);\n pinMode(gndPin, OUTPUT);\n // Configure Output Signal Pins\n pinMode(ledPin, OUTPUT);\n pinMode(buzzerPin, OUTPUT);\n // Power up the Ultrasonic Sensor\n digitalWrite(vccPin, HIGH);  // Provide 5V power\n digitalWrite(gndPin, LOW);   // Connect GND to 0V\n // Ensure all signals are in their default LOW state\n digitalWrite(ledPin, LOW);\n digitalWrite(buzzerPin, LOW);\n digitalWrite(trigPin, LOW);\n // Initialize Serial Monitor for debugging\n Serial.begin(9600);\n // Stabilize the ultrasonic sensor after powering up\n delay(1000);\n}\n```\n\n```arduino\n/* ========================== Setup Function ========================== */\n/**\n* Initializes hardware components, configures I/O pins, and stabilizes the sensor.\n*/\nvoid setup() {\n // Configure Ultrasonic Sensor Pins\n pinMode(vccPin, OUTPUT);\n pinMode(trigPin, OUTPUT);\n pinMode(echoPin, INPUT);\n pinMode(gndPin, OUTPUT);\n // Configure Output Signal Pins\n pinMode(ledPin, OUTPUT);\n pinMode(buzzerPin, OUTPUT);\n // Power up the Ultrasonic Sensor\n digitalWrite(vccPin, HIGH);  // Provide 5V power\n digitalWrite(gndPin, LOW);   // Connect GND to 0V\n // Ensure all signals are in their default LOW state\n digitalWrite(ledPin, LOW);\n digitalWrite(buzzerPin, LOW);\n digitalWrite(trigPin, LOW);\n // Initialize Serial Monitor for debugging\n Serial.begin(9600);\n // Stabilize the ultrasonic sensor after powering up\n delay(1000);\n}\n```\n\nThis setup() function makes sure that all hardware pins get initialised correctly, like setting the appropriate pin as INPUTS and OUTPUTS. It also makes initialisation of the serial monitor at 9600 baud rate. Later, it uses some delay to stabilise the ultrasonic sensor initially after powering up.\n\n# loop()\n\n```arduino\n/* ========================== Main Loop ========================== */\n/**\n* Continuously checks distance and triggers LED and buzzer alerts based on proximity.\n*/\nvoid loop() {\n // Capture the current time in milliseconds\n currentMillis = millis();\n // Measure the distance from the ultrasonic sensor\n measureDistance();\n // Activate LED and buzzer alerts if object is within 30cm range\n if (distance >= 0 && distance <= 50) {\n   task_triggerBuzzer();\n   task_triggerLed();\n } else {\n   // Stop alerts if the object is out of range\n   stopAlerts();\n }\n}\n```\n\n```arduino\n/* ========================== Main Loop ========================== */\n/**\n* Continuously checks distance and triggers LED and buzzer alerts based on proximity.\n*/\nvoid loop() {\n // Capture the current time in milliseconds\n currentMillis = millis();\n // Measure the distance from the ultrasonic sensor\n measureDistance();\n // Activate LED and buzzer alerts if object is within 30cm range\n if (distance >= 0 && distance <= 50) {\n   task_triggerBuzzer();\n   task_triggerLed();\n } else {\n   // Stop alerts if the object is out of range\n   stopAlerts();\n }\n}\n```\n\nThis loop function continuously checks for distance and triggers the buzzer task and led task whenever the distance is >= 0 and <= 50, otherwise, it stops the alert by calling the stopAlerts() function. Here, the currenrMillis captures the current time of the timer. This timer is essential for running the buzzer_beep task and led_flash task simultaneously without disturbing each other.\n\n# Upload code to Arduino\n\nI hope you understand the logic behind the program. Ok, now it’s time to bring back the new life to our loveable Arduino by injecting binary into its memory. For that, we want to open up our Arduino IDE and make sure the Arduino Nano Board is selected properly.\n\nUnlike other Arduino boards, Arduino Nano comes in two different processor families, namely ATmega328p and ATmega168. In my case, Arduino Nano comes with ATmega328p processor chipset, so i choose Arduino328p.\n\nAfter that, we want to select the respective USB associated with our Arduino Nano.\n\nFinally, flash the code into our Arduino Nano by clicking the upload button found on the Arduino IDE.\n\nOk, now the coding part is over. Now, let’s assemble our hardware in a PVC pipe to build an actual walking stick for visually impaired individuals.\n\n# Assembling Blind Stick Circuit on a PVC Pipe\n\nIn the image below, you can find how I assembled our hardware circuit in the PVC pipe. I used ZIP-Tags to attach the breadboard firmly to the PVC pipe. Here, I attached the battery to the bottom side of the breadboard using double-sided tape\n\nLater, I ensured that the complete breadboard setup was attached near the bottom end of the PVC Pipe so that we could detect the objects or humans before hitting them with a stick.\n\n# Final Working Demonstration\n\nIf everything went right, after turning on the Arduino Smart Stick. It starts to work perfectly, as shown in below GIF.\n\nIn the demonstration clip, you can find that this smart stick detects objects and alerts walkers through audible alerts as well as through visual alerts before hitting the obstacle. The frequency of those alerts increases when the distance from the object decreases so that walkers can get a feel of a third sense when the object is approaching them closely.\n\n# GitHub Repository with Code and Circuit\n\nThe full code for this Smart Blind Stick using Arduino project and Ultrasonic sensor is provided below. You can also access the source code in our GitHub repository through the link below.\n\n# Similar Arduino-Based Smart Blind Stick Projects\n\nDiscover a range of Arduino-based smart blind stick projects designed to assist visually impaired individuals. These projects integrate ultrasonic sensors, Arduino, Buzzers along with voice alert feedback features to enhance mobility and safety.\n\nVoice Alert based Smart Blind Stick Using Arduino Nano and Ultrasonic Sensors\n\nThis project details the creation of a smart blind stick that uses an Arduino Nano and ultrasonic sensors to detect obstacles and provide voice alerts, enhancing navigation for visually impaired individuals.\n\nBuilding a Smart Blind Stick using Arduino - Inspired by Shark Tank Torchit\n\nInspired by the Torchit blind stick featured on Shark Tank, this project guides you through building a similar device using an Arduino Pro Mini and ultrasonic sensors to detect obstacles and alert the user via vibrations.\n\nSmart Blind Stick using Arduino\n\nThis project focuses on developing a smart blind stick equipped with ultrasonic sensors to detect obstacles and provide feedback through vibrations or sound, aiding visually impaired individuals in navigation.\n\n# Complete Project Code\n\n```arduino\n/*************************************************************\nSmart blind stick system Arduino Code\nMore details : https://circuitdigest.com/microcontroller-projects\n************************************************************/\n\n/* ========================== Pin Definitions ========================== */\n// Ultrasonic Sensor Pins\n#define vccPin 4       // Ultrasonic sensor VCC pin\n#define trigPin 5      // Ultrasonic sensor Trigger pin\n#define echoPin 6      // Ultrasonic sensor Echo pin\n#define gndPin 7       // Ultrasonic sensor GND pin\n// Output Signal Pins\n#define ledPin 9       // LED signal pin\n#define buzzerPin 2  // Buzzer signal pin\n\n/* ========================== Ultrasonic Sensor Data ========================== */\nlong duration = 0;     // Duration of ultrasonic signal bounce-back (in microseconds)\nint distance = 0;      // Calculated distance between the object and sensor (in cm)\n\n/* ========================== Timing Variables ========================== */\n// Stores the last time LED and Buzzer states were updated\nunsigned long previousLedMillis = 0;\nunsigned long previousBuzzerMillis = 0;\n\n/* ========================== Multitasking Interval Variables ========================== */\n// Determines the interval between LED blinks and buzzer beeps (in milliseconds)\nint ledInterval = 0;        // LED blink interval — varies based on object distance\nint buzzerInterval = 0;     // Buzzer beep interval — varies based on object distance\n\n/* ========================== State Variables ========================== */\n// Tracks the current state of LED and Buzzer\nbool ledState = LOW;        // LED state (ON or OFF)\nbool buzzerState = LOW;     // Buzzer state (ON or OFF)\n\n/* ========================== Current Time Variable ========================== */\n// Holds the current time in milliseconds\nunsigned long currentMillis = 0;\n\n/* ========================== Setup Function ========================== */\n/**\n* Initializes hardware components, configures I/O pins, and stabilizes the sensor.\n*/\nvoid setup() {\n // Configure Ultrasonic Sensor Pins\n pinMode(vccPin, OUTPUT);\n pinMode(trigPin, OUTPUT);\n pinMode(echoPin, INPUT);\n pinMode(gndPin, OUTPUT);\n // Configure Output Signal Pins\n pinMode(ledPin, OUTPUT);\n pinMode(buzzerPin, OUTPUT);\n // Power up the Ultrasonic Sensor\n digitalWrite(vccPin, HIGH);  // Provide 5V power\n digitalWrite(gndPin, LOW);   // Connect GND to 0V\n // Ensure all signals are in their default LOW state\n digitalWrite(ledPin, LOW);\n digitalWrite(buzzerPin, LOW);\n digitalWrite(trigPin, LOW);\n // Initialize Serial Monitor for debugging\n Serial.begin(9600);\n // Stabilize the ultrasonic sensor after powering up\n delay(1000);\n}\n\n/* ========================== Main Loop ========================== */\n/**\n* Continuously checks distance and triggers LED and buzzer alerts based on proximity.\n*/\nvoid loop() {\n // Capture the current time in milliseconds\n currentMillis = millis();\n // Measure the distance from the ultrasonic sensor\n measureDistance();\n // Activate LED and buzzer alerts if object is within 30cm range\n if (distance >= 0 && distance <= 30) {\n   task_triggerBuzzer();\n   task_triggerLed();\n } else {\n   // Stop alerts if the object is out of range\n   stopAlerts();\n }\n}\n\n/* ========================== Task: Trigger Buzzer ========================== */\n/**\n* Controls the buzzer beep rate based on object proximity.\n* Buzzer beeps faster when the object is closer.\n*/\nvoid task_triggerBuzzer() {\n // Map the distance to a buzzer interval (30ms when close, 100ms when far)\n buzzerInterval = map(distance, 0, 30, 30, 100);\n // Toggle the buzzer state when the interval has passed\n if (currentMillis - previousBuzzerMillis >= buzzerInterval) {\n   previousBuzzerMillis = currentMillis;      // Update the last buzzer time\n   buzzerState = !buzzerState;                // Toggle the buzzer state\n   digitalWrite(buzzerPin, buzzerState);      // Apply the new state to the pin\n }\n}\n\n/* ========================== Task: Trigger LED ========================== */\n/**\n* Controls the LED blink rate based on object proximity.\n* LED blinks faster when the object is closer.\n*/\nvoid task_triggerLed() {\n // Map the distance to an LED interval (50ms when close, 100ms when far)\n ledInterval = map(distance, 0, 30, 50, 100);\n // Toggle the LED state when the interval has passed\n if (currentMillis - previousLedMillis >= ledInterval) {\n   previousLedMillis = currentMillis;         // Update the last LED time\n   ledState = !ledState;                      // Toggle the LED state\n   digitalWrite(ledPin, ledState);            // Apply the new state to the pin\n }\n}\n\n/* ========================== Stop Alerts ========================== */\n/**\n* Deactivates the LED and buzzer when no object is within range.\n*/\nvoid stopAlerts() {\n digitalWrite(buzzerPin, LOW);                // Turn off the buzzer\n digitalWrite(ledPin, LOW);                   // Turn off the LED\n ledState = LOW;                              // Reset LED state\n buzzerState = LOW;                           // Reset buzzer state\n}\n\n/* ========================== Measure Distance ========================== */\n/**\n* Triggers the ultrasonic sensor and calculates the distance to the nearest object.\n*/\nvoid measureDistance() {\n // Send a 10µs pulse to the trigger pin to start the measurement\n digitalWrite(trigPin, LOW);\n delayMicroseconds(2);\n digitalWrite(trigPin, HIGH);\n delayMicroseconds(10);\n digitalWrite(trigPin, LOW);\n // Measure the duration of the pulse on the echo pin\n duration = pulseIn(echoPin, HIGH);\n // Calculate the distance in centimeters (speed of sound: 343 m/s)\n distance = (duration / 2) / 29.1;\n // Output the distance measurement to the Serial Monitor\n Serial.print(\"Distance: \");\n Serial.print(distance);\n Serial.println(\" cm\");\n}\n```\n\n```arduino\n/*************************************************************\nSmart blind stick system Arduino Code\nMore details : https://circuitdigest.com/microcontroller-projects\n************************************************************/\n\n/* ========================== Pin Definitions ========================== */\n// Ultrasonic Sensor Pins\n#define vccPin 4       // Ultrasonic sensor VCC pin\n#define trigPin 5      // Ultrasonic sensor Trigger pin\n#define echoPin 6      // Ultrasonic sensor Echo pin\n#define gndPin 7       // Ultrasonic sensor GND pin\n// Output Signal Pins\n#define ledPin 9       // LED signal pin\n#define buzzerPin 2  // Buzzer signal pin\n\n/* ========================== Ultrasonic Sensor Data ========================== */\nlong duration = 0;     // Duration of ultrasonic signal bounce-back (in microseconds)\nint distance = 0;      // Calculated distance between the object and sensor (in cm)\n\n/* ========================== Timing Variables ========================== */\n// Stores the last time LED and Buzzer states were updated\nunsigned long previousLedMillis = 0;\nunsigned long previousBuzzerMillis = 0;\n\n/* ========================== Multitasking Interval Variables ========================== */\n// Determines the interval between LED blinks and buzzer beeps (in milliseconds)\nint ledInterval = 0;        // LED blink interval — varies based on object distance\nint buzzerInterval = 0;     // Buzzer beep interval — varies based on object distance\n\n/* ========================== State Variables ========================== */\n// Tracks the current state of LED and Buzzer\nbool ledState = LOW;        // LED state (ON or OFF)\nbool buzzerState = LOW;     // Buzzer state (ON or OFF)\n\n/* ========================== Current Time Variable ========================== */\n// Holds the current time in milliseconds\nunsigned long currentMillis = 0;\n\n/* ========================== Setup Function ========================== */\n/**\n* Initializes hardware components, configures I/O pins, and stabilizes the sensor.\n*/\nvoid setup() {\n // Configure Ultrasonic Sensor Pins\n pinMode(vccPin, OUTPUT);\n pinMode(trigPin, OUTPUT);\n pinMode(echoPin, INPUT);\n pinMode(gndPin, OUTPUT);\n // Configure Output Signal Pins\n pinMode(ledPin, OUTPUT);\n pinMode(buzzerPin, OUTPUT);\n // Power up the Ultrasonic Sensor\n digitalWrite(vccPin, HIGH);  // Provide 5V power\n digitalWrite(gndPin, LOW);   // Connect GND to 0V\n // Ensure all signals are in their default LOW state\n digitalWrite(ledPin, LOW);\n digitalWrite(buzzerPin, LOW);\n digitalWrite(trigPin, LOW);\n // Initialize Serial Monitor for debugging\n Serial.begin(9600);\n // Stabilize the ultrasonic sensor after powering up\n delay(1000);\n}\n\n/* ========================== Main Loop ========================== */\n/**\n* Continuously checks distance and triggers LED and buzzer alerts based on proximity.\n*/\nvoid loop() {\n // Capture the current time in milliseconds\n currentMillis = millis();\n // Measure the distance from the ultrasonic sensor\n measureDistance();\n // Activate LED and buzzer alerts if object is within 30cm range\n if (distance >= 0 && distance <= 30) {\n   task_triggerBuzzer();\n   task_triggerLed();\n } else {\n   // Stop alerts if the object is out of range\n   stopAlerts();\n }\n}\n\n/* ========================== Task: Trigger Buzzer ========================== */\n/**\n* Controls the buzzer beep rate based on object proximity.\n* Buzzer beeps faster when the object is closer.\n*/\nvoid task_triggerBuzzer() {\n // Map the distance to a buzzer interval (30ms when close, 100ms when far)\n buzzerInterval = map(distance, 0, 30, 30, 100);\n // Toggle the buzzer state when the interval has passed\n if (currentMillis - previousBuzzerMillis >= buzzerInterval) {\n   previousBuzzerMillis = currentMillis;      // Update the last buzzer time\n   buzzerState = !buzzerState;                // Toggle the buzzer state\n   digitalWrite(buzzerPin, buzzerState);      // Apply the new state to the pin\n }\n}\n\n/* ========================== Task: Trigger LED ========================== */\n/**\n* Controls the LED blink rate based on object proximity.\n* LED blinks faster when the object is closer.\n*/\nvoid task_triggerLed() {\n // Map the distance to an LED interval (50ms when close, 100ms when far)\n ledInterval = map(distance, 0, 30, 50, 100);\n // Toggle the LED state when the interval has passed\n if (currentMillis - previousLedMillis >= ledInterval) {\n   previousLedMillis = currentMillis;         // Update the last LED time\n   ledState = !ledState;                      // Toggle the LED state\n   digitalWrite(ledPin, ledState);            // Apply the new state to the pin\n }\n}\n\n/* ========================== Stop Alerts ========================== */\n/**\n* Deactivates the LED and buzzer when no object is within range.\n*/\nvoid stopAlerts() {\n digitalWrite(buzzerPin, LOW);                // Turn off the buzzer\n digitalWrite(ledPin, LOW);                   // Turn off the LED\n ledState = LOW;                              // Reset LED state\n buzzerState = LOW;                           // Reset buzzer state\n}\n\n/* ========================== Measure Distance ========================== */\n/**\n* Triggers the ultrasonic sensor and calculates the distance to the nearest object.\n*/\nvoid measureDistance() {\n // Send a 10µs pulse to the trigger pin to start the measurement\n digitalWrite(trigPin, LOW);\n delayMicroseconds(2);\n digitalWrite(trigPin, HIGH);\n delayMicroseconds(10);\n digitalWrite(trigPin, LOW);\n // Measure the duration of the pulse on the echo pin\n duration = pulseIn(echoPin, HIGH);\n // Calculate the distance in centimeters (speed of sound: 343 m/s)\n distance = (duration / 2) / 29.1;\n // Output the distance measurement to the Serial Monitor\n Serial.print(\"Distance: \");\n Serial.print(distance);\n Serial.println(\" cm\");\n}\n```\n\n# Start a Discussion on:\n\n# Add New Comment\n\nLog in or register to post comments"}
{"title":"How to Make an RFID Door Lock System using Arduino?","content":"Are you tired of searching for keys whenever you need to open a door? How about building a smart locking system where you can simply swipe a card to open the door? In this article, we will learn how to build an RFID door lock system using Arduino. It’s a fun and secure way to unlock the door.\n\nRadio Frequency Identification is widely used in contactless payment cards, National Highway Tollgate systems, and in security passes. By integrating an RFID reader with an Arduino, you will be able to create a system that automatically opens the door, when an authorized RFID card or tag is scanned. This project is perfect for anyone who wants to make their home or office a little smarter. You can also check out our other Arduino Projects and Home Automation Projects if you want to explore more DIY Arduino projects.\n\n# How do Arduino based RFID Door Lock Work?\n\nThis Arduino RFID Door lock system consists of an Arduino Development Board (Arduino UNO, Arduino Nano or other), an RFID reader module and an actuator like servo motor or solenoid lock to lock and unclock the door. All we need to do is swipe or place an authorized RFID card in front of the RFID reader. Here, Arduino handles data processing activities to decide whether the RFID card is valid or not. If the card gets recognized, the Arduino sends a signal to the relay to unlock the solenoid door lock for 10 seconds, Later, it locks the door automatically.\n\nTo make it more user-friendly, I decided to use a 16x2 I2C-based LCD display to show door status and to provide important feedback messages to the door opener like Access Granted or Access Denied.\n\n# Components Required\n\nTo build an RFID Door lock system, we will need a few essential components. Here is a simple list of what you will need to start.\n\nArduino UNO R3 Development Board\n\nArduino UNO R3 Development Board\n\nRC522 RFID Reader\n\nRC522 RFID Reader\n\nRFID Cards or Tags\n\nRFID Cards or Tags\n\nSolenoid Door Lock\n\nSolenoid Door Lock\n\nSingle Channel Relay Module\n\nSingle Channel Relay Module\n\n16x2 LCD Display along with I2C Expansion Module\n\n16x2 LCD Display along with I2C Expansion Module\n\nJumper Wires\n\nJumper Wires\n\nPower Supply Adaptor\n\nPower Supply Adaptor\n\nIn the next section, we will see the circuit diagram for the Arduino-based RFID Door Lock System.\n\n# RFID Door Lock System using Arduino Circuit Diagram\n\nThe below RFID Door Lock System circuit diagram represents how an Arduino, RFID Module, Relay module, Solenoid Lock, and LCD display are connected to create a secure and automated door lock system.\n\nThis setup makes our Door to unlock only when an authorized RFID tag or RFID card gets scanned. Below you can find our actual hardware setup of the Arduino RFID Door Lock System developed by using Circuit Diagram and Pin Connection Details as a reference. We have built a lot of RFID based projects previously, if you are completely new RFID and would like to understand the basics of RFID and how it works with Arduino you can read our Arduino RFID tutorial before proceeding with this project.\n\nAs you can see the hardware connections are pretty easy and straightforward. We have the Arduino UNO board which acts as the main brain of this project. The RC522 RFID reader module is used to read the RFID cards and the 16x2 LCD is used to display the status information. The 12V solenoid lock is connected through a relay module to our Arduino UNO board. The set-up is powered buy a 12V lithium battery pack making the project portable and easy to install, you can also use 12V adapter with Arduino UNO if you do not have a battery.\n\nTo make the hardware connection easy to understadn we have given a table below which explains the connection between your Arduino board and the RFID, LCD and Relay modules.\n\n# Connection Between Arduino and RFID Reader\n\n# Connection Between Arduino and I2C LCD Display\n\n# Connection Between Arduino and Relay Module\n\nNow that the hardware is ready lets move on to the programming section of our rfid door locking system. But before we do that its important to understadn that the Arduino code for this project is split into two sections, this is because each RFID card or Tag will have a unique ID number and it is important to know this unique ID of you RFID card to be able to grant access to it. So in the first section of code we will place your RFID card on a reader and read this unique ID and int he second section of code we will use this unique ID to build our rfid door locking system.\n\n# Arduino Code to Read RFID Card UID\n\nTo know your Authorized RFID card UID, just compile and dump the below code in Arduino. Note, for this you can keep your hardware setup as it is without any modifications.\n\nHeader files download links:\nMFRC522.h \nLiquidCrystal_I2C.h\n\nAfter downloading, you can install it through the Arduino IDE, by going to Sketch -> Include Library -> Add ZIP Library and selecting the downloaded .ZIP file,\n\n```arduino\n#include <LiquidCrystal_I2C.h>\n#include <MFRC522.h>\n// Define RC522 RFID module pins\n#define RST_PIN 9   // Reset pin\n#define SS_PIN 10   // Slave Select pin\n// Initialize MFRC522 instance\nMFRC522 rfid(SS_PIN, RST_PIN);\n// Initialize the I2C LCD (set the I2C address, usually 0x27 or 0x3F)\nLiquidCrystal_I2C lcd(0x27, 16, 2);\nvoid setup() {\n // Initialize SPI and RC522 module\n Serial.begin(9600);\n SPI.begin();\n rfid.PCD_Init();\n // Initialize the LCD\n lcd.init();\n lcd.backlight();\n lcd.setCursor(0, 0);\n lcd.print(\"Scan RFID Card\");\n Serial.println(\"Scan RFID Card\");\n}\nvoid loop() {\n // Check if a new RFID card is present\n if (!rfid.PICC_IsNewCardPresent()) {\n   return;\n }\n // Check if the RFID card can be read\n if (!rfid.PICC_ReadCardSerial()) {\n   return;\n }\n // Clear LCD and display the UID\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Card UID:\");\n Serial.print(\"Card UID: \");\n // Print the UID on the LCD\n lcd.setCursor(0, 1);\n for (byte i = 0; i < rfid.uid.size; i++) {\n   if (rfid.uid.uidByte[i] < 0x10) {\n     lcd.print(\"0\"); // Add leading 0 for single-digit hex\n     Serial.print(\"0x0\");\n   }\n   lcd.print(rfid.uid.uidByte[i], HEX); // Print UID byte in HEX format\n   Serial.print(\"0x\");\n   Serial.print(rfid.uid.uidByte[i], HEX);\n   if (i < rfid.uid.size - 1) {\n     lcd.print(\" \"); // Add space between bytes\n     Serial.print(\", \");\n   }\n   delay(1000);\n }\n // Halt communication with the card\n rfid.PICC_HaltA();\n // Wait for 10 seconds before clearing the LCD\n delay(10000);\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Scan RFID Card\");\n Serial.println(\"\\n\");\n Serial.println(\"Scan RFID Card\");\n}\n```\n\n```arduino\n#include <LiquidCrystal_I2C.h>\n#include <MFRC522.h>\n// Define RC522 RFID module pins\n#define RST_PIN 9   // Reset pin\n#define SS_PIN 10   // Slave Select pin\n// Initialize MFRC522 instance\nMFRC522 rfid(SS_PIN, RST_PIN);\n// Initialize the I2C LCD (set the I2C address, usually 0x27 or 0x3F)\nLiquidCrystal_I2C lcd(0x27, 16, 2);\nvoid setup() {\n // Initialize SPI and RC522 module\n Serial.begin(9600);\n SPI.begin();\n rfid.PCD_Init();\n // Initialize the LCD\n lcd.init();\n lcd.backlight();\n lcd.setCursor(0, 0);\n lcd.print(\"Scan RFID Card\");\n Serial.println(\"Scan RFID Card\");\n}\nvoid loop() {\n // Check if a new RFID card is present\n if (!rfid.PICC_IsNewCardPresent()) {\n   return;\n }\n // Check if the RFID card can be read\n if (!rfid.PICC_ReadCardSerial()) {\n   return;\n }\n // Clear LCD and display the UID\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Card UID:\");\n Serial.print(\"Card UID: \");\n // Print the UID on the LCD\n lcd.setCursor(0, 1);\n for (byte i = 0; i < rfid.uid.size; i++) {\n   if (rfid.uid.uidByte[i] < 0x10) {\n     lcd.print(\"0\"); // Add leading 0 for single-digit hex\n     Serial.print(\"0x0\");\n   }\n   lcd.print(rfid.uid.uidByte[i], HEX); // Print UID byte in HEX format\n   Serial.print(\"0x\");\n   Serial.print(rfid.uid.uidByte[i], HEX);\n   if (i < rfid.uid.size - 1) {\n     lcd.print(\" \"); // Add space between bytes\n     Serial.print(\", \");\n   }\n   delay(1000);\n }\n // Halt communication with the card\n rfid.PICC_HaltA();\n // Wait for 10 seconds before clearing the LCD\n delay(10000);\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Scan RFID Card\");\n Serial.println(\"\\n\");\n Serial.println(\"Scan RFID Card\");\n}\n```\n\n# Upload the UID Scan Code\n\nAfter dumping the code into Arduino, it will ask you to scan the RFID Card.\n\nAfter scanning, you can able to see the scanned RFID card UID details in the serial monitor at the baud rate of 9600, as shown in the below image.\n\nAt the same time, You can also able to see the UID on the display as well.\n\nNote down the RFID card UID, which later gets used in the code of the RFID Door lock system.\n\n# Code for RFID Door Lock System using Arduino\n\nThis code is for an RFID door lock system using an Arduino. It reads the UID of the RFID card and compares it to a predefined authorized UID. If the RFID card UID matches the predefined UID details, then it unlocks the door for 10 seconds with the help of a relay and solenoid door lock, meanwhile, it displays the door status on LCD display.\n\n```arduino\n#include <MFRC522.h>\n#include <LiquidCrystal_I2C.h>\n// Define RC522 pins\n#define RST_PIN 9\n#define SS_PIN 10\n// Relay pin\n#define RELAY_PIN 8\n// Initialize MFRC522 instance\nMFRC522 rfid(SS_PIN, RST_PIN);\n// Initialize LCD (address 0x27 may vary)\nLiquidCrystal_I2C lcd(0x27, 16, 2);\n// Authorized UID (replace with your tag's UID)\nbyte authorizedUID[] = {0x69, 0xA9, 0x81, 0x5A};\n// Door status\nbool doorLocked = true;\nvoid setup() {\n // Initialize SPI and RC522\n SPI.begin();\n rfid.PCD_Init();\n // Initialize LCD\n lcd.init();\n lcd.backlight();\n // Set up relay pin\n pinMode(RELAY_PIN, OUTPUT);\n // Display startup message\n lcd.setCursor(0, 0);\n lcd.print(\"RFID Door Lock\");\n delay(2000);\n lcd.clear();\n lockDoor(); // Start with door locked\n}\nvoid loop() {\n // Check if a new RFID card is present\n if (!rfid.PICC_IsNewCardPresent()) {\n   return;\n }\n // Check if the RFID card can be read\n if (!rfid.PICC_ReadCardSerial()) {\n   return;\n }\n // Display scanned UID\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Scanning...\");\n delay(2000);\n // Compare scanned UID with authorized UID\n if (isAuthorized(rfid.uid.uidByte, rfid.uid.size)) {\n   lcd.setCursor(0, 1);\n   lcd.print(\"Access Granted!\");\n   delay(2000);\n   unlockDoor(); // Lock or unlock the door\n } else {\n   lcd.setCursor(0, 1);\n   lcd.print(\"Access Denied!\");\n   delay(2000);\n   lockDoor();\n }\n // Halt communication with the card\n rfid.PICC_HaltA();\n}\n// Function to check if UID matches authorized UID\nbool isAuthorized(byte *uid, byte size) {\n if (size != sizeof(authorizedUID)) {\n   return false;\n }\n for (byte i = 0; i < size; i++) {\n   if (uid[i] != authorizedUID[i]) {\n     return false;\n   }\n }\n return true;\n}\n// Function to lock the door\nvoid lockDoor() {\n digitalWrite(RELAY_PIN, LOW); // Turn OFF relay (lock engaged)\n doorLocked = true;\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Door Locked\");\n delay(2000);\n}\n// Function to unlock the door\nvoid unlockDoor() {\n digitalWrite(RELAY_PIN, HIGH); // Turn ON relay (unlock door)\n doorLocked = false;\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Door Unlocked\");\n delay(10000); // Keep door unlocked for 5 seconds\n lockDoor();  // Auto-lock after 5 seconds\n}\n```\n\n```arduino\n#include <MFRC522.h>\n#include <LiquidCrystal_I2C.h>\n// Define RC522 pins\n#define RST_PIN 9\n#define SS_PIN 10\n// Relay pin\n#define RELAY_PIN 8\n// Initialize MFRC522 instance\nMFRC522 rfid(SS_PIN, RST_PIN);\n// Initialize LCD (address 0x27 may vary)\nLiquidCrystal_I2C lcd(0x27, 16, 2);\n// Authorized UID (replace with your tag's UID)\nbyte authorizedUID[] = {0x69, 0xA9, 0x81, 0x5A};\n// Door status\nbool doorLocked = true;\nvoid setup() {\n // Initialize SPI and RC522\n SPI.begin();\n rfid.PCD_Init();\n // Initialize LCD\n lcd.init();\n lcd.backlight();\n // Set up relay pin\n pinMode(RELAY_PIN, OUTPUT);\n // Display startup message\n lcd.setCursor(0, 0);\n lcd.print(\"RFID Door Lock\");\n delay(2000);\n lcd.clear();\n lockDoor(); // Start with door locked\n}\nvoid loop() {\n // Check if a new RFID card is present\n if (!rfid.PICC_IsNewCardPresent()) {\n   return;\n }\n // Check if the RFID card can be read\n if (!rfid.PICC_ReadCardSerial()) {\n   return;\n }\n // Display scanned UID\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Scanning...\");\n delay(2000);\n // Compare scanned UID with authorized UID\n if (isAuthorized(rfid.uid.uidByte, rfid.uid.size)) {\n   lcd.setCursor(0, 1);\n   lcd.print(\"Access Granted!\");\n   delay(2000);\n   unlockDoor(); // Lock or unlock the door\n } else {\n   lcd.setCursor(0, 1);\n   lcd.print(\"Access Denied!\");\n   delay(2000);\n   lockDoor();\n }\n // Halt communication with the card\n rfid.PICC_HaltA();\n}\n// Function to check if UID matches authorized UID\nbool isAuthorized(byte *uid, byte size) {\n if (size != sizeof(authorizedUID)) {\n   return false;\n }\n for (byte i = 0; i < size; i++) {\n   if (uid[i] != authorizedUID[i]) {\n     return false;\n   }\n }\n return true;\n}\n// Function to lock the door\nvoid lockDoor() {\n digitalWrite(RELAY_PIN, LOW); // Turn OFF relay (lock engaged)\n doorLocked = true;\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Door Locked\");\n delay(2000);\n}\n// Function to unlock the door\nvoid unlockDoor() {\n digitalWrite(RELAY_PIN, HIGH); // Turn ON relay (unlock door)\n doorLocked = false;\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Door Unlocked\");\n delay(10000); // Keep door unlocked for 5 seconds\n lockDoor();  // Auto-lock after 5 seconds\n}\n```\n\nHere,\n\nMFRC522.h               -   it is used for interfacing with the RC522 RFID reader module.\n\nMFRC522.h               -   it is used for interfacing with the RC522 RFID reader module.\n\nLiquidCrystal_I2C.h   -   used for controlling the I2C-based LCD display.\n\nLiquidCrystal_I2C.h   -   used for controlling the I2C-based LCD display.\n\nYou can easily get this library by clicking the appropriate header file name.\n\nAfter downloading the ZIP file from the GitHub repo, you can install it either through the Arduino IDE, by going to Sketch -> Include Library -> Add ZIP Library and selecting the downloaded .ZIP file, or by just simply extracting the Zip file into the Arduino library folder.\n\n# Defining Macros for Pins\n\n```arduino\n#define RST_PIN 9 \n#define SS_PIN 10\n#define RELAY_PIN 8\n```\n\n```arduino\n#define RST_PIN 9 \n#define SS_PIN 10\n#define RELAY_PIN 8\n```\n\nHere, I am defining the macros of the Reset pin and  Slave Select pin for the RFID module and Relay signal pin for the relay module.\n\n# Creating the Objects for RFID and Display Module\n\n```arduino\nMFRC522 rfid(SS_PIN, RST_PIN); \nLiquidCrystal_I2C lcd(0x27, 16, 2);\n```\n\n```arduino\nMFRC522 rfid(SS_PIN, RST_PIN); \nLiquidCrystal_I2C lcd(0x27, 16, 2);\n```\n\nIn the above code, I am creating the objects for the RC522 RFID and the I2C LCD module for proper initialization purposes.\n\n# Storing the Authorized RFID card UID\n\nbyte authorizedUID[] = {0x69, 0xA9, 0x81, 0x5A};\n\nThis array holds the unique UID of the authorized RFID card. Replace these values with your authorized RFID tag’s UID.\n\n# Tracking Doorlock status\n\n```arduino\nbool doorLocked = true;\n```\n\n```arduino\nbool doorLocked = true;\n```\n\nHere the doorLocked variable is used as the status flag to know about whether the door is locked or opened.\n\n# Setup() Function\n\n```arduino\nvoid setup() {\n Serial.begin(9600);\n // Initialize SPI and RC522\n SPI.begin();\n rfid.PCD_Init();\n // Initialize LCD\n lcd.init();\n lcd.backlight();\n // Set up relay pin\n pinMode(RELAY_PIN, OUTPUT);\n // Display startup message\n lcd.setCursor(0, 0);\n lcd.print(\"RFID Door Lock\");\n delay(2000);\n lcd.clear();\n lockDoor(); // Start with door locked\n}\n```\n\n```arduino\nvoid setup() {\n Serial.begin(9600);\n // Initialize SPI and RC522\n SPI.begin();\n rfid.PCD_Init();\n // Initialize LCD\n lcd.init();\n lcd.backlight();\n // Set up relay pin\n pinMode(RELAY_PIN, OUTPUT);\n // Display startup message\n lcd.setCursor(0, 0);\n lcd.print(\"RFID Door Lock\");\n delay(2000);\n lcd.clear();\n lockDoor(); // Start with door locked\n}\n```\n\nThis setup() function essential for setting up the hardware configurations, in this setup I use SPI.begin() function to initialize the SPI communication for the RFID reader module. Then I make a call rfid.PCD_Init() function to configure the RFID reader.\n\nLater I used the lcd predefined function to make initialize the I2C lcd module. Finally, i make a call on lockDoor() function to make sure the door is locked initially.\n\n# Loop() Function\n\n```arduino\nvoid loop() {\n// Check if a new RFID card is present\n if (!rfid.PICC_IsNewCardPresent()) {\n   return;\n }\n // Check if the RFID card can be read\n if (!rfid.PICC_ReadCardSerial()) {\n   return;\n }\n // Display scanned UID\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Scanning...\");\n delay(2000);\n // Compare scanned UID with authorized UID\n if (isAuthorized(rfid.uid.uidByte, rfid.uid.size)) {\n   lcd.setCursor(0, 1);\n   lcd.print(\"Access Granted!\");\n   delay(2000);\n   unlockDoor(); // Lock or unlock the door\n } else {\n   lcd.setCursor(0, 1);\n   lcd.print(\"Access Denied!\");\n   delay(2000);\n   lockDoor();\n }\n // Halt communication with the card\n rfid.PICC_HaltA();\n}\n```\n\n```arduino\nvoid loop() {\n// Check if a new RFID card is present\n if (!rfid.PICC_IsNewCardPresent()) {\n   return;\n }\n // Check if the RFID card can be read\n if (!rfid.PICC_ReadCardSerial()) {\n   return;\n }\n // Display scanned UID\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Scanning...\");\n delay(2000);\n // Compare scanned UID with authorized UID\n if (isAuthorized(rfid.uid.uidByte, rfid.uid.size)) {\n   lcd.setCursor(0, 1);\n   lcd.print(\"Access Granted!\");\n   delay(2000);\n   unlockDoor(); // Lock or unlock the door\n } else {\n   lcd.setCursor(0, 1);\n   lcd.print(\"Access Denied!\");\n   delay(2000);\n   lockDoor();\n }\n // Halt communication with the card\n rfid.PICC_HaltA();\n}\n```\n\nThis loop() function keeps on checking for new cards using rfid.PICC_IsNewCardPresent() and read its UID using rfid.PICC_ReadCardSerial() function. After reading the UID card, it compares that UID with the predefined authorized UID using isAuthorized() function.\n\nIf the UID matches, it prints Access Granted on the lcd display and makes a call to UnlockDoor() to Unlock the door, otherwise, it prints Access Denied on the lcd display and makes a call to the lockDoor() function to lock the door.\n\nFinally, it makes a call on rfid.PICC_HaltA() to halt communication with the currently scanned RFID card.\n\n# Look for Authorized RFID card UID\n\n```arduino\nbool isAuthorized(byte *uid, byte size) {\n if (size != sizeof(authorizedUID)) {\n   return false;\n }\n for (byte i = 0; i < size; i++) {\n   if (uid[i] != authorizedUID[i]) {\n     return false;\n   }\n }\n return true;\n}\n```\n\n```arduino\nbool isAuthorized(byte *uid, byte size) {\n if (size != sizeof(authorizedUID)) {\n   return false;\n }\n for (byte i = 0; i < size; i++) {\n   if (uid[i] != authorizedUID[i]) {\n     return false;\n   }\n }\n return true;\n}\n```\n\nThe above isAuthorized() is used to check whether the scanned RFID card UID matches with the predefined authorized UID value. If it matches the UID, it returns true else it returns false.\n\n# Locking and Unlocking Door\n\nLocks the Door:\n\n```arduino\nvoid lockDoor() {\n digitalWrite(RELAY_PIN, LOW); // Turn OFF relay (lock engaged)\n doorLocked = true;\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Door Locked\");\n delay(2000);\n}\n```\n\n```arduino\nvoid lockDoor() {\n digitalWrite(RELAY_PIN, LOW); // Turn OFF relay (lock engaged)\n doorLocked = true;\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Door Locked\");\n delay(2000);\n}\n```\n\nThis lockDoor() function is used to lock the solenoid door lock by providing a low signal to the relay module. After that, it prints “Door Locked” on the lcd display.\n\n# Unlocks the Door\n\n```arduino\nvoid unlockDoor() {\n digitalWrite(RELAY_PIN, HIGH); // Turn ON relay (unlock door)\n doorLocked = false;\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Door Unlocked\");\n delay(5000); // Keep door unlocked for 5 seconds\n lockDoor();  // Auto-lock after 5 seconds\n}\n```\n\n```arduino\nvoid unlockDoor() {\n digitalWrite(RELAY_PIN, HIGH); // Turn ON relay (unlock door)\n doorLocked = false;\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Door Unlocked\");\n delay(5000); // Keep door unlocked for 5 seconds\n lockDoor();  // Auto-lock after 5 seconds\n}\n```\n\nThis unlocksDoor() function is used to unlock the solenoid door lock by providing a high signal to the relay module for 5 seconds, after that, it again locks the door by calling lockDoor() function. It also prints door status like “Door Unlocked” on the lcd display.\n\n# Upload the code of the RFID Door Locking System\n\nBefore uploading the code, make sure the board is selected properly, in our case it is Arduino Uno.\n\nAfter selecting the board, select the USB port of our Arduino UNO board. Through that USB port only the program file gets flashed into Arduino UNO.\n\nThen finally, click the upload button to dump the RFID Door lock system code into an Arduino.\n\n# Final Testing of our RFID Door Lock System\n\nAt last, we've entered the most exciting phase, i.e final testing of our RFID Door Lock System using Arduino! For every electronics hobbyist, the most priceless moment is seeing their project work as expected. This phase ensures that our system reliably authenticates RFID tags to open the Door. It’s time to witness our hard work.\n\nYou can see that, After scanning the Authorized RFID Tag, It granted access and made the Solenoid Door to get Unlocked.\n\nWith this, we have come to a conclusion of our RFID door lock system using the Arduino project. Hope you have learned something useful and have enjoyed building the project on your own. If you have any questions or need help you can reach us through the comment section below or though our forms.\n\n# Projects Using RFID for Security and Automation\n\nRFID technology is widely used in security and automation projects for access control, authentication, and tracking systems. We have previously used RFID in various projects, if you want to explore more on these topics, check out the links below.\n\nArduino Solenoid Door Lock using RFID\n\nThis project involves creating an RFID-based door lock system using an Arduino. It provides detailed instructions on setting up the hardware and software components to control access via RFID tags.\n\nDigital Keypad Security Door Lock using Arduino\n\nThis project demonstrates how to build a password-protected door lock system using a digital keypad and Arduino. It provides a step-by-step guide to setting up the hardware and programming the Arduino to control a servo motor for locking and unlocking.\n\nFingerprint based Car Ignition System using Arduino and RFID\n\nDemonstrates a Fingerprint-Based Car Ignition System using Arduino and RFID, ensuring only authorized users can start the vehicle. Learn how to integrate a fingerprint sensor and RFID module with Arduino to create a secure ignition system.\n\nRFID Based Door Lock System using Raspberry Pi\n\nLearn how to build an RFID-Based Door Lock System using Raspberry Pi and an RC522 RFID module for secure access control. It allows entry only to registered RFID tags while triggering an alarm and sending email notifications for unauthorized attempts.\n\n# Complete Project Code\n\n```arduino\n#include <LiquidCrystal_I2C.h>\n#include <MFRC522.h>\n// Define RC522 RFID module pins\n#define RST_PIN 9   // Reset pin\n#define SS_PIN 10   // Slave Select pin\n// Initialize MFRC522 instance\nMFRC522 rfid(SS_PIN, RST_PIN);\n// Initialize the I2C LCD (set the I2C address, usually 0x27 or 0x3F)\nLiquidCrystal_I2C lcd(0x27, 16, 2);\nvoid setup() {\n // Initialize SPI and RC522 module\n Serial.begin(9600);\n SPI.begin();\n rfid.PCD_Init();\n // Initialize the LCD\n lcd.init();\n lcd.backlight();\n lcd.setCursor(0, 0);\n lcd.print(\"Scan RFID Card\");\n Serial.println(\"Scan RFID Card\");\n}\nvoid loop() {\n // Check if a new RFID card is present\n if (!rfid.PICC_IsNewCardPresent()) {\n   return;\n }\n // Check if the RFID card can be read\n if (!rfid.PICC_ReadCardSerial()) {\n   return;\n }\n // Clear LCD and display the UID\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Card UID:\");\n Serial.print(\"Card UID: \");\n // Print the UID on the LCD\n lcd.setCursor(0, 1);\n for (byte i = 0; i < rfid.uid.size; i++) {\n   if (rfid.uid.uidByte[i] < 0x10) {\n     lcd.print(\"0\"); // Add leading 0 for single-digit hex\n     Serial.print(\"0x0\");\n   }\n   lcd.print(rfid.uid.uidByte[i], HEX); // Print UID byte in HEX format\n   Serial.print(\"0x\");\n   Serial.print(rfid.uid.uidByte[i], HEX);\n   if (i < rfid.uid.size - 1) {\n     lcd.print(\" \"); // Add space between bytes\n     Serial.print(\", \");\n   }\n   delay(1000);\n }\n // Halt communication with the card\n rfid.PICC_HaltA();\n // Wait for 10 seconds before clearing the LCD\n delay(10000);\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Scan RFID Card\");\n Serial.println(\"\\n\");\n Serial.println(\"Scan RFID Card\");\n}\n#include <MFRC522.h>\n#include <LiquidCrystal_I2C.h>\n// Define RC522 pins\n#define RST_PIN 9\n#define SS_PIN 10\n// Relay pin\n#define RELAY_PIN 8\n// Initialize MFRC522 instance\nMFRC522 rfid(SS_PIN, RST_PIN);\n// Initialize LCD (address 0x27 may vary)\nLiquidCrystal_I2C lcd(0x27, 16, 2);\n\n// Authorized UID (replace with your tag's UID)\nbyte authorizedUID[] = {0x69, 0xA9, 0x81, 0x5A};\n// Door status\nbool doorLocked = true;\nvoid setup() {\n // Initialize SPI and RC522\n SPI.begin();\n rfid.PCD_Init();\n // Initialize LCD\n lcd.init();\n lcd.backlight();\n // Set up relay pin\n pinMode(RELAY_PIN, OUTPUT);\n // Display startup message\n lcd.setCursor(0, 0);\n lcd.print(\"RFID Door Lock\");\n delay(2000);\n lcd.clear();\n lockDoor(); // Start with door locked\n}\nvoid loop() {\n // Check if a new RFID card is present\n if (!rfid.PICC_IsNewCardPresent()) {\n   return;\n }\n // Check if the RFID card can be read\n if (!rfid.PICC_ReadCardSerial()) {\n   return;\n }\n // Display scanned UID\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Scanning...\");\n delay(2000);\n // Compare scanned UID with authorized UID\n if (isAuthorized(rfid.uid.uidByte, rfid.uid.size)) {\n   lcd.setCursor(0, 1);\n   lcd.print(\"Access Granted!\");\n   delay(2000);\n   unlockDoor(); // Lock or unlock the door\n } else {\n   lcd.setCursor(0, 1);\n   lcd.print(\"Access Denied!\");\n   delay(2000);\n   lockDoor();\n }\n // Halt communication with the card\n rfid.PICC_HaltA();\n}\n// Function to check if UID matches authorized UID\nbool isAuthorized(byte *uid, byte size) {\n if (size != sizeof(authorizedUID)) {\n   return false;\n }\n for (byte i = 0; i < size; i++) {\n   if (uid[i] != authorizedUID[i]) {\n     return false;\n   }\n }\n return true;\n}\n// Function to lock the door\nvoid lockDoor() {\n digitalWrite(RELAY_PIN, LOW); // Turn OFF relay (lock engaged)\n doorLocked = true;\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Door Locked\");\n delay(2000);\n}\n// Function to unlock the door\nvoid unlockDoor() {\n digitalWrite(RELAY_PIN, HIGH); // Turn ON relay (unlock door)\n doorLocked = false;\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Door Unlocked\");\n delay(10000); // Keep door unlocked for 5 seconds\n lockDoor();  // Auto-lock after 5 seconds\n}\n```\n\n```arduino\n#include <LiquidCrystal_I2C.h>\n#include <MFRC522.h>\n// Define RC522 RFID module pins\n#define RST_PIN 9   // Reset pin\n#define SS_PIN 10   // Slave Select pin\n// Initialize MFRC522 instance\nMFRC522 rfid(SS_PIN, RST_PIN);\n// Initialize the I2C LCD (set the I2C address, usually 0x27 or 0x3F)\nLiquidCrystal_I2C lcd(0x27, 16, 2);\nvoid setup() {\n // Initialize SPI and RC522 module\n Serial.begin(9600);\n SPI.begin();\n rfid.PCD_Init();\n // Initialize the LCD\n lcd.init();\n lcd.backlight();\n lcd.setCursor(0, 0);\n lcd.print(\"Scan RFID Card\");\n Serial.println(\"Scan RFID Card\");\n}\nvoid loop() {\n // Check if a new RFID card is present\n if (!rfid.PICC_IsNewCardPresent()) {\n   return;\n }\n // Check if the RFID card can be read\n if (!rfid.PICC_ReadCardSerial()) {\n   return;\n }\n // Clear LCD and display the UID\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Card UID:\");\n Serial.print(\"Card UID: \");\n // Print the UID on the LCD\n lcd.setCursor(0, 1);\n for (byte i = 0; i < rfid.uid.size; i++) {\n   if (rfid.uid.uidByte[i] < 0x10) {\n     lcd.print(\"0\"); // Add leading 0 for single-digit hex\n     Serial.print(\"0x0\");\n   }\n   lcd.print(rfid.uid.uidByte[i], HEX); // Print UID byte in HEX format\n   Serial.print(\"0x\");\n   Serial.print(rfid.uid.uidByte[i], HEX);\n   if (i < rfid.uid.size - 1) {\n     lcd.print(\" \"); // Add space between bytes\n     Serial.print(\", \");\n   }\n   delay(1000);\n }\n // Halt communication with the card\n rfid.PICC_HaltA();\n // Wait for 10 seconds before clearing the LCD\n delay(10000);\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Scan RFID Card\");\n Serial.println(\"\\n\");\n Serial.println(\"Scan RFID Card\");\n}\n#include <MFRC522.h>\n#include <LiquidCrystal_I2C.h>\n// Define RC522 pins\n#define RST_PIN 9\n#define SS_PIN 10\n// Relay pin\n#define RELAY_PIN 8\n// Initialize MFRC522 instance\nMFRC522 rfid(SS_PIN, RST_PIN);\n// Initialize LCD (address 0x27 may vary)\nLiquidCrystal_I2C lcd(0x27, 16, 2);\n\n// Authorized UID (replace with your tag's UID)\nbyte authorizedUID[] = {0x69, 0xA9, 0x81, 0x5A};\n// Door status\nbool doorLocked = true;\nvoid setup() {\n // Initialize SPI and RC522\n SPI.begin();\n rfid.PCD_Init();\n // Initialize LCD\n lcd.init();\n lcd.backlight();\n // Set up relay pin\n pinMode(RELAY_PIN, OUTPUT);\n // Display startup message\n lcd.setCursor(0, 0);\n lcd.print(\"RFID Door Lock\");\n delay(2000);\n lcd.clear();\n lockDoor(); // Start with door locked\n}\nvoid loop() {\n // Check if a new RFID card is present\n if (!rfid.PICC_IsNewCardPresent()) {\n   return;\n }\n // Check if the RFID card can be read\n if (!rfid.PICC_ReadCardSerial()) {\n   return;\n }\n // Display scanned UID\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Scanning...\");\n delay(2000);\n // Compare scanned UID with authorized UID\n if (isAuthorized(rfid.uid.uidByte, rfid.uid.size)) {\n   lcd.setCursor(0, 1);\n   lcd.print(\"Access Granted!\");\n   delay(2000);\n   unlockDoor(); // Lock or unlock the door\n } else {\n   lcd.setCursor(0, 1);\n   lcd.print(\"Access Denied!\");\n   delay(2000);\n   lockDoor();\n }\n // Halt communication with the card\n rfid.PICC_HaltA();\n}\n// Function to check if UID matches authorized UID\nbool isAuthorized(byte *uid, byte size) {\n if (size != sizeof(authorizedUID)) {\n   return false;\n }\n for (byte i = 0; i < size; i++) {\n   if (uid[i] != authorizedUID[i]) {\n     return false;\n   }\n }\n return true;\n}\n// Function to lock the door\nvoid lockDoor() {\n digitalWrite(RELAY_PIN, LOW); // Turn OFF relay (lock engaged)\n doorLocked = true;\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Door Locked\");\n delay(2000);\n}\n// Function to unlock the door\nvoid unlockDoor() {\n digitalWrite(RELAY_PIN, HIGH); // Turn ON relay (unlock door)\n doorLocked = false;\n lcd.clear();\n lcd.setCursor(0, 0);\n lcd.print(\"Door Unlocked\");\n delay(10000); // Keep door unlocked for 5 seconds\n lockDoor();  // Auto-lock after 5 seconds\n}\n```\n\n# Start a Discussion on:\n\n# Add New Comment\n\nLog in or register to post comments"}
{"title":"How to Build a Maze Solving Robot Using Arduino","content":"Building a maze-solving robot is an intresting way to get into the world of robotics and autonomous systems. Imagine creating a small device that can intelligently navigate through complex mazes, making decisions at every turn. This step-by-step guide will show you how to build your own maze-solving robot using Arduino UNO, three IR sensors, and basic components that you can easily find in your local electronics shop.\n\nWhether you're a student, hobbyist, or robotics enthusiast, this maze-solving robot project will help you understand the fundamental concepts of programming and electronics with hands-on experience. And the best part is you don't need advanced engineering knowledge or components to build and have fun with this robot. In fact, if you have already built a line following robot or a obstacle avoiding robot then you can easily build this project without needing any additional components.\n\n# What is a Maze Solving Robot?\n\nA maze-solving robot is a robot designed to navigate through a maze and find the exit autonomously. It uses sensors such as ultrasonic, infrared, or cameras to detect obstacles and map the surroundings. The robot then employs various algorithms like Depth First Search (DFS), Breadth First Search (BFS), or Wall-Following to map the maze and choose the optimal path. It typically moves based on real-time feedback and makes decisions to avoid walls and reach the destination.\n\nIn this tutorial, we will be building a simple arduino maze solving robot . The robot uses IR sensor to detect the maze and employs an algorithm called hand on wall rule to navigate through the maze and find the exit. Please note we have used lines to create the maze instead of building walls as shown in the GIF above, this way we can easily create multiple maze patterns and test the robot. These types of maze solving robots following a line are also called line follower maze solving robot.\n\n# Maze Solving Robot Algorithm\n\nOne of the most critical aspects of building a maze-solving robot is selecting an appropriate algorithm for the type of maze you’re tackling. Different maze types require tailored approaches to ensure efficient navigation. For this project’s simple line-based maze, we’ll use the “Hand on Wall Rule” algorithm, also known as the Left-Hand Rule or Right-Hand Rule.\n\nThis algorithm works well in mazes with connected wall-mazes where a solution path exists as a continuous boundary. Below is an example of such a maze:\n\nWithout color differentiation (like orange and green), the maze can appear confusing. However, with clear paths highlighted, the navigation becomes straightforward. The Hand-on-Wall Rule algorithm is particularly useful for mazes with well-defined boundaries and continuous walls. It’s also ideal for robots with limited computational power or memory because it doesn’t require the robot to “remember” its path.\n\nThis approach mimics human behavior when navigating dark or unknown spaces, where touching a wall provides direction and a sense of boundaries. Simple, effective, and ingenious!\n\nHope you have understood the core concept of this algorithm.\n\n# Working\n\nIn the GIF video below, you can see our robot navigating the maze using the Left-Hand Rule. This choice was made because, in this particular maze, applying the Right-Hand Rule would cause the robot to fail to reach the destination. Instead, it would endlessly loop around the track.\n\nThis limitation arises because the robot uses only three sensors. With more sensors, it would be possible to successfully navigate the maze using the Right-Hand Rule as well. However, for simplicity, we’ve chosen a design with just three sensors.\n\nBy keeping the sensor count to three, the robot requires only a small set of possible decisions, making the design and programming simpler and more accessible. Below, we’ll examine the truth table used in this robot to determine its behavior in various scenarios.\n\nNow, lets start building the maze-solving Robot.\n\n# Components Required\n\nFor building a basic robot like this one, the components are quite flexible, and you can always scale up or down depending on your needs. Below are the components, that I used in this project:\n\nArduino UNO - 1\n\nArduino UNO - 1\n\nMotor Shield of Arduino UNO - 1\n\nMotor Shield of Arduino UNO - 1\n\nIR Obstacle Detection sensor - 3\n\nIR Obstacle Detection sensor - 3\n\nTwo Wheel Drive Car Chassis - 1\n\nTwo Wheel Drive Car Chassis - 1\n\nCastor Wheel - 1\n\nCastor Wheel - 1\n\nBo Motors with appropriate wheel - 2\n\nBo Motors with appropriate wheel - 2\n\n2s Lithium ion battery pack with BMS - 1\n\n2s Lithium ion battery pack with BMS - 1\n\nConnecting wires - Required\n\nConnecting wires - Required\n\nScrews, Nuts and Spacers - Required\n\nScrews, Nuts and Spacers - Required\n\n# Power Supply\n\nWhile the power supply is flexible, it’s recommended to use a voltage source between 5V and 12V. A 9V battery would also work, but anything above 5V and below 12V is ideal for ensuring a steady power supply, especially for the motors. A higher voltage ensures that even if the motors draw significant power, the voltage drop won’t affect the Arduino's functionality (which could cause a restart).\n\n# Chassis\n\nFor the chassis, you can use a pre-built one, or even opt for a cardboard chassis as a quick and low-cost alternative. The rest of the components are straightforward and commonly found in robotics kits.\n\nWith these components, you’re all set to start building your robot!\n\n# Maze Solving Robot Circuit Diagram\n\nAs we are using the Arduino motor shield, the circuit diagram becomes simpler because no special connection is needed between the motor shield and the Arduino UNO.\n\nAbove, you can see the circuit diagram of this maze-solving robot. It is self-explanatory, as we have provided a clear diagram with all the components marked. For added clarity, I am detailing the circuit below:\n\nSince we are using the motor shield v1, we are limited to using the analog pins. Therefore, I am using A0, A1, and A2 as digital inputs for the left, front, and right sensors. These are the only pins exposed with individual pads, making soldering easier. The left and right motors are connected to the M1 and M2 motor outputs of the motor shield. While coding, you can check the motor direction. If any changes are needed, you can simply reverse the polarity of the motors.\n\nFinally, we have the power supply, which is crucial. We are using an old 2S battery pack that provides an output voltage of 5.6V to 8.4V. This is more than enough for our project. If you choose a different motor, you might need to upgrade the power source.\n\nAdditionally, you need to ensure the connection to the PWR pins of the motor driver module, as shown in the image above. These pins are responsible for connecting the battery input to the Vin pin of the Arduino. If this connection is missing, the Arduino UNO will not be powered.\n\nNow that we have completed the circuit diagram explanation, let’s assemble the components according to the circuit diagram.\n\n# How to Make Maze Solving Robot?\n\nFor assembling the robot, if you are using the same components as I did, there will be no major hurdles in the process. However, if you are upgrading the components, there might be slight modifications required.\n\nAnother major area to focus on is the distance between each sensor and its position. Incorrect placement may result in improper movements. Additionally, some calibration will be necessary to ensure the robot runs properly.\n\nAbove, you can see the assembled robot. The assembly process is straightforward and simple. The sensors are placed at the correct distance and verified through test runs. The sensors are connected using wires that are soldered to the motor driver module.\n\n# Maze Solving Robot Arduino Code\n\nThe maze-solving robot uses IR sensors to detect obstacles and employs a logical decision-making algorithm to navigate through a maze. The robot’s movement is controlled via DC motors interfaced with the Arduino Motor Shield V1. Below is a detailed breakdown of the code. Pleas note that this code is written to only find the exit of the maze it will not find the shortest path. But you can implement your own algorithm to find shortest path if you are intrested.\n\n# Libraries Used\n\nAFMotor: This library controls the DC motors using the Arduino Motor Shield V1. It simplifies motor control with functions like setSpeed() and run().\n\n```arduino\n#include <AFMotor.h> \nAF_DCMotor motorA(1); \nAF_DCMotor motorB(2);\n```\n\n```arduino\n#include <AFMotor.h> \nAF_DCMotor motorA(1); \nAF_DCMotor motorB(2);\n```\n\nConstants and variables\n\nThe IR sensors are assigned to analog pins A0, A1, and A2, which correspond to the left, front, and right sensors, respectively. Motor speeds and turning delays are also defined using constants for precise movement control.\n\nconst int leftSensor = A0;\nconst int frontSensor = A1;\nconst int rightSensor = A2;\nconst int forwardSpeed = 120;\nconst int TurningSpeed = 115;\nconst int turnDelay = 25;\nconst int uTurnDelay = 50;\n\n# Constants and variables\n\nThe IR sensors are assigned to analog pins A0, A1, and A2, which correspond to the left, front, and right sensors, respectively. Motor speeds and turning delays are also defined using constants for precise movement control.\n\n```arduino\nconst int leftSensor = A0;\nconst int frontSensor = A1;\nconst int rightSensor = A2;\nconst int forwardSpeed = 120;\nconst int TurningSpeed = 115;\nconst int turnDelay = 25;\nconst int uTurnDelay = 50;\n```\n\n```arduino\nconst int leftSensor = A0;\nconst int frontSensor = A1;\nconst int rightSensor = A2;\nconst int forwardSpeed = 120;\nconst int TurningSpeed = 115;\nconst int turnDelay = 25;\nconst int uTurnDelay = 50;\n```\n\nSetup Function\n\nThe setup() function initializes the IR sensors as input devices to detect obstacles and sets up serial communication for debugging purposes.\n\nvoid setup() {\n  pinMode(leftSensor, INPUT);\n  pinMode(frontSensor, INPUT);\n  pinMode(rightSensor, INPUT);\n  Serial.begin(9600);\n}\n\n# Setup Function\n\nThe setup() function initializes the IR sensors as input devices to detect obstacles and sets up serial communication for debugging purposes.\n\n```arduino\nvoid setup() {\n  pinMode(leftSensor, INPUT);\n  pinMode(frontSensor, INPUT);\n  pinMode(rightSensor, INPUT);\n  Serial.begin(9600);\n}\n```\n\n```arduino\nvoid setup() {\n  pinMode(leftSensor, INPUT);\n  pinMode(frontSensor, INPUT);\n  pinMode(rightSensor, INPUT);\n  Serial.begin(9600);\n}\n```\n\nMain Loop\n\nThe loop() function continuously reads data from the IR sensors and determines the robot’s movements using a switch-case logic. The sensor values (0 or 1) are combined into a binary representation to identify the current maze state (e.g., path available ahead, left, right, or no path). Based on the state, specific movement functions like moveForward(), turnLeft(), turnRight(), or uTurn() are called.\n\nvoid loop() {\n  int leftValue = digitalRead(leftSensor);\n  int frontValue = digitalRead(frontSensor);\n  int rightValue = digitalRead(rightSensor);\n  int sensorState = (leftValue << 2) | (frontValue << 1) | rightValue;\n  switch (sensorState) {\n    case 0b000:uTurn();break;\n    case 0b010:moveForward();break;\n    case 0b111:turnLeft();break;\n    case 0b100:turnLeft(); break;\n    case 0b110:turnLeft();break;\n    case 0b001:turnRight();break;\n    case 0b011:turnRight();break;\n    case 0b101:stopMotors();break;\n    default:stopMotors();break;\n  }\n}\n\n# Main Loop\n\nThe loop() function continuously reads data from the IR sensors and determines the robot’s movements using a switch-case logic. The sensor values (0 or 1) are combined into a binary representation to identify the current maze state (e.g., path available ahead, left, right, or no path). Based on the state, specific movement functions like moveForward(), turnLeft(), turnRight(), or uTurn() are called.\n\n```arduino\nvoid loop() {\n  int leftValue = digitalRead(leftSensor);\n  int frontValue = digitalRead(frontSensor);\n  int rightValue = digitalRead(rightSensor);\n  int sensorState = (leftValue << 2) | (frontValue << 1) | rightValue;\n  switch (sensorState) {\n    case 0b000:uTurn();break;\n    case 0b010:moveForward();break;\n    case 0b111:turnLeft();break;\n    case 0b100:turnLeft(); break;\n    case 0b110:turnLeft();break;\n    case 0b001:turnRight();break;\n    case 0b011:turnRight();break;\n    case 0b101:stopMotors();break;\n    default:stopMotors();break;\n  }\n}\n```\n\n```arduino\nvoid loop() {\n  int leftValue = digitalRead(leftSensor);\n  int frontValue = digitalRead(frontSensor);\n  int rightValue = digitalRead(rightSensor);\n  int sensorState = (leftValue << 2) | (frontValue << 1) | rightValue;\n  switch (sensorState) {\n    case 0b000:uTurn();break;\n    case 0b010:moveForward();break;\n    case 0b111:turnLeft();break;\n    case 0b100:turnLeft(); break;\n    case 0b110:turnLeft();break;\n    case 0b001:turnRight();break;\n    case 0b011:turnRight();break;\n    case 0b101:stopMotors();break;\n    default:stopMotors();break;\n  }\n}\n```\n\nThe complete code is provided at the end of this article, along with proper comments for better understanding.\n\n# Working of Maze Solving Robot\n\nOnce the code is uploaded to the assembled robot via the Arduino IDE, it’s time for testing. We have shown the complete working video of this maze-solving robot at the bottom of this page. But to understand what is happening let's look into it step-by-step.\n\nStep 1: Starting Position\n\nThe robot starts at the entrance of the maze.\n\nIt follows the Left-Hand Rule, meaning it will always keep its left sensor or side against the wall.\n\nStep 2: Decision at Junction\n\nThe first junction is a three-way intersection.\n\nAs per the algorithm, the robot chooses the left path.\n\nIf the junction offers only right and left paths, priority is always given to the left side.\n\nStep 3: Turning at Corners\n\nNext, the robot encounters two right-turn corners.\n\nSince both corners bend right, the robot moves right as expected.\n\nStep 4: Decision at the Second Junction\n\nThe next junction is another three-way intersection, but this time, the paths are straight and left.\n\nSince the Left-Hand Rule is followed, the robot turns left.\n\nStep 5: Corner Turn\n\nAs like the previous corners the robot will turn in the corner in right direction.\n\nStep 6: Final Movement\n\nThe final junction resembles the first one, offering right and left paths.\n\nAs expected, the robot chooses the left path, leading to the destination.\n\nDuring the test, you'll notice that the robot does not travel in a perfectly straight line. This issue arises due to uneven speeds between the left and right motors. To address this, you can opt for the 4-wheel drive method for better balance and stability.\n\nYou can cross-check the robot's movement with the truth table provided in the code. The robot performs as expected, successfully navigating the maze.\n\n# GitHub Repo with Code and Circuit\n\nThe complete code for this maze-solving robot project is given at the bottom of this page. Further more here is also a link to our GitHub repo, where you'll find the source code for this project.\n\n# Conclusion and Future Improvements\n\nIf you have come this far, give yourself a pat on the back, for you have successfully built a basic maze-solving robot. But the best thing about this project is you can easily scale it and experiment with complex algorithms. Take a break and play with this robot build different maze patterns and see how your robot solves them. You will soon understand that this robot is not able to solve complex maze patterns and is definitely not the fastest maze solving robot out there. Now, you can wear your programming hat and code this robot to solve the maze faster and even find the shortest path, this will you will also be able to participate in maze-solving robot competitions where you can challenge yourself and your robot to solve complex mazes and compete with fellow engineers.\n\n# Projects Similar to maze-solving Robot\n\nPreviously we have built many interesting Arduino Projects. If you have successfully completed building this maze solving robot project here are a few other interesting projects that we have built previously. All the projects have detailed explanations on how to build along with code and circuit diagrams for you to learn and explore. You can also check our complete robotics projects if you want to explore more options.\n\nLine Follower Robot using Arduino UNO: How to Build (Step-by-Step Guide)\n\nThis comprehensive guide demonstrates how to build a line follower robot using an Arduino UNO, covering hardware interfacing, sensor calibration, and motor control fundamentals.\n\nLine Follower Robot using PIC Microcontroller\n\nThis tutorial explains how to build a line follower robot using the PIC16F877A microcontroller, detailing the working principles and construction process.\n\nLine Follower Robot using 8051 Microcontroller\n\nThis guide provides instructions on designing a line follower robot with an 8051 microcontroller, including PCB layout and programming details.\n\nLine Follower Robot using Raspberry Pi\n\nBuild a line-following robot powered by Raspberry Pi. This project integrates Python programming and GPIO control for precise navigation.\n\nRaspberry Pi Pico based Line Follower Robot\n\nThis project involves creating a line-following robot using the Raspberry Pi Pico, demonstrating the robot's ability to track lines and reach destinations automatically.\n\nHow to Make Line Following Robot without using Microcontroller\n\nThis tutorial demonstrates how to design and build a basic line-following robot using IR sensors and a motor control circuit. A beginner-friendly project to explore robotics and circuit design concepts.\n\nLine Follower Robot Using MSP430 LaunchPad\n\nLearn how to create a line-following robot using Texas Instruments' MSP430 LaunchPad, IR sensors, and motor drivers. This project is perfect for understanding embedded systems and robotics with MSP430.\n\n# Complete Project Code\n\n```arduino\n//Arduino Code for Maze Solving Robot Project \n#include <AFMotor.h>  // Include the Adafruit Motor Shield library for motor control\n// Motor Definitions\nAF_DCMotor motorA(1);  // Motor A connected to terminal M1 on the motor shield\nAF_DCMotor motorB(2);  // Motor B connected to terminal M2 on the motor shield\n// Sensor Pin Definitions\nconst int leftSensor = A0;   // Left IR sensor pin\nconst int frontSensor = A1;  // Front IR sensor pin\nconst int rightSensor = A2;  // Right IR sensor pin\n// Movement Parameters\nconst int forwardSpeed = 120;  // Speed for forward movement\nconst int TurningSpeed = 115;  // Speed for turning movements\nconst int turnDelay = 25;      // Delay for completing a turn\nconst int uTurnDelay = 50;    // Delay for completing a U-turn\nvoid setup() {\n // Configure sensor pins as input\n pinMode(leftSensor, INPUT);\n pinMode(frontSensor, INPUT);\n pinMode(rightSensor, INPUT);\n // Initialize serial communication for debugging\n Serial.begin(9600);\n}\nvoid loop() {\n // Read sensor values (0 or 1)\n int leftValue = digitalRead(leftSensor);\n int frontValue = digitalRead(frontSensor);\n int rightValue = digitalRead(rightSensor);\n // Combine sensor states into a single value for switch-case logic\n int sensorState = (leftValue << 2) | (frontValue << 1) | rightValue;\n // Decision-making based on sensor states\n switch (sensorState) {\n   case 0b000:  // No sensors detect a wall\n     uTurn();   // Perform a U-turn\n     Serial.println(\"Stop\");\n     break;\n   case 0b010:       // Only the front sensor detects a wall\n     moveForward();  // Move forward\n     Serial.println(\"Move Forward\");\n     break;\n   case 0b111:    // All sensors detect walls\n     turnLeft();  // Turn left\n     Serial.println(\"Turn Left\");\n     break;\n   case 0b100:    // Only the left sensor detects a wall\n     turnLeft();  // Turn left\n     Serial.println(\"Turn Left\");\n     break;\n   case 0b110:    // Front and left sensors detect walls\n     turnLeft();  // Turn left\n     Serial.println(\"Turn Left\");\n     break;\n   case 0b001:     // Only the right sensor detects a wall\n     turnRight();  // Turn right\n     Serial.println(\"Turn Right\");\n     break;\n   case 0b011:     // Front and right sensors detect walls\n     turnRight();  // Turn right\n     Serial.println(\"Turn Right\");\n     break;\n   case 0b101:      // Left and right sensors detect walls\n     stopMotors();  // Stop the motors\n     Serial.println(\"Turn Left\");\n     break;\n   default:         // Unknown sensor state\n     stopMotors();  // Stop the motors as a safety measure\n     Serial.println(\"Unknown State\");\n     break;\n }\n}\n// Function to move forward\nvoid moveForward() {\n motorA.setSpeed(forwardSpeed);  // Set speed for motor A\n motorB.setSpeed(forwardSpeed);  // Set speed for motor B\n motorA.run(FORWARD);            // Move motor A forward\n motorB.run(FORWARD);            // Move motor B forward\n}\n// Function to turn left\nvoid turnLeft() {\n motorA.setSpeed(TurningSpeed - 20);  // Reduce speed of motor A for smoother turn\n motorB.setSpeed(TurningSpeed);       // Set speed for motor B\n motorA.run(BACKWARD);                // Move motor A backward\n motorB.run(FORWARD);                 // Move motor B forward\n delay(turnDelay);                    // Delay to complete the turn\n}\n// Function to turn right\nvoid turnRight() {\n motorA.setSpeed(TurningSpeed);       // Set speed for motor A\n motorB.setSpeed(TurningSpeed - 20);  // Reduce speed of motor B for smoother turn\n motorA.run(FORWARD);                 // Move motor A forward\n motorB.run(BACKWARD);                // Move motor B backward\n delay(turnDelay);                    // Delay to complete the turn\n}\n// Function to stop the motors\nvoid stopMotors() {\n motorA.run(RELEASE);  // Release motor A\n motorB.run(RELEASE);  // Release motor B\n}\n// Function to perform a U-turn\nvoid uTurn() {\n motorA.setSpeed(TurningSpeed);  // Set speed for motor A\n motorB.setSpeed(TurningSpeed);  // Set speed for motor B\n motorA.run(FORWARD);            // Move motor A forward\n motorB.run(BACKWARD);           // Move motor B backward\n delay(uTurnDelay);              // Delay to complete the U-turn\n}\n```\n\n```arduino\n//Arduino Code for Maze Solving Robot Project \n#include <AFMotor.h>  // Include the Adafruit Motor Shield library for motor control\n// Motor Definitions\nAF_DCMotor motorA(1);  // Motor A connected to terminal M1 on the motor shield\nAF_DCMotor motorB(2);  // Motor B connected to terminal M2 on the motor shield\n// Sensor Pin Definitions\nconst int leftSensor = A0;   // Left IR sensor pin\nconst int frontSensor = A1;  // Front IR sensor pin\nconst int rightSensor = A2;  // Right IR sensor pin\n// Movement Parameters\nconst int forwardSpeed = 120;  // Speed for forward movement\nconst int TurningSpeed = 115;  // Speed for turning movements\nconst int turnDelay = 25;      // Delay for completing a turn\nconst int uTurnDelay = 50;    // Delay for completing a U-turn\nvoid setup() {\n // Configure sensor pins as input\n pinMode(leftSensor, INPUT);\n pinMode(frontSensor, INPUT);\n pinMode(rightSensor, INPUT);\n // Initialize serial communication for debugging\n Serial.begin(9600);\n}\nvoid loop() {\n // Read sensor values (0 or 1)\n int leftValue = digitalRead(leftSensor);\n int frontValue = digitalRead(frontSensor);\n int rightValue = digitalRead(rightSensor);\n // Combine sensor states into a single value for switch-case logic\n int sensorState = (leftValue << 2) | (frontValue << 1) | rightValue;\n // Decision-making based on sensor states\n switch (sensorState) {\n   case 0b000:  // No sensors detect a wall\n     uTurn();   // Perform a U-turn\n     Serial.println(\"Stop\");\n     break;\n   case 0b010:       // Only the front sensor detects a wall\n     moveForward();  // Move forward\n     Serial.println(\"Move Forward\");\n     break;\n   case 0b111:    // All sensors detect walls\n     turnLeft();  // Turn left\n     Serial.println(\"Turn Left\");\n     break;\n   case 0b100:    // Only the left sensor detects a wall\n     turnLeft();  // Turn left\n     Serial.println(\"Turn Left\");\n     break;\n   case 0b110:    // Front and left sensors detect walls\n     turnLeft();  // Turn left\n     Serial.println(\"Turn Left\");\n     break;\n   case 0b001:     // Only the right sensor detects a wall\n     turnRight();  // Turn right\n     Serial.println(\"Turn Right\");\n     break;\n   case 0b011:     // Front and right sensors detect walls\n     turnRight();  // Turn right\n     Serial.println(\"Turn Right\");\n     break;\n   case 0b101:      // Left and right sensors detect walls\n     stopMotors();  // Stop the motors\n     Serial.println(\"Turn Left\");\n     break;\n   default:         // Unknown sensor state\n     stopMotors();  // Stop the motors as a safety measure\n     Serial.println(\"Unknown State\");\n     break;\n }\n}\n// Function to move forward\nvoid moveForward() {\n motorA.setSpeed(forwardSpeed);  // Set speed for motor A\n motorB.setSpeed(forwardSpeed);  // Set speed for motor B\n motorA.run(FORWARD);            // Move motor A forward\n motorB.run(FORWARD);            // Move motor B forward\n}\n// Function to turn left\nvoid turnLeft() {\n motorA.setSpeed(TurningSpeed - 20);  // Reduce speed of motor A for smoother turn\n motorB.setSpeed(TurningSpeed);       // Set speed for motor B\n motorA.run(BACKWARD);                // Move motor A backward\n motorB.run(FORWARD);                 // Move motor B forward\n delay(turnDelay);                    // Delay to complete the turn\n}\n// Function to turn right\nvoid turnRight() {\n motorA.setSpeed(TurningSpeed);       // Set speed for motor A\n motorB.setSpeed(TurningSpeed - 20);  // Reduce speed of motor B for smoother turn\n motorA.run(FORWARD);                 // Move motor A forward\n motorB.run(BACKWARD);                // Move motor B backward\n delay(turnDelay);                    // Delay to complete the turn\n}\n// Function to stop the motors\nvoid stopMotors() {\n motorA.run(RELEASE);  // Release motor A\n motorB.run(RELEASE);  // Release motor B\n}\n// Function to perform a U-turn\nvoid uTurn() {\n motorA.setSpeed(TurningSpeed);  // Set speed for motor A\n motorB.setSpeed(TurningSpeed);  // Set speed for motor B\n motorA.run(FORWARD);            // Move motor A forward\n motorB.run(BACKWARD);           // Move motor B backward\n delay(uTurnDelay);              // Delay to complete the U-turn\n}\n```\n\n# Start a Discussion on:\n\n# Add New Comment\n\nLog in or register to post comments"}
{"title":"How to Build a Speed Sensor using Arduino?","content":"Have you ever wondered how speed guns measure the speed of moving vehicles or how an athlete's sprint speed is recorded? Normally these speed sensors work with radar or laser technology to bounce back radio waves or IR light from objects and calculate speed based on time taken for the light or wave to reflect. In this article, we will learn how to similar speed sensor using Arduino and IR sensor.\n\nBy setting up the two IR sensors at a fixed distance from each other, we can track the time it takes for the object to travel between them. With the recorded time and the known distance between them, we can accurately calculate the object's speed using a formula.\n\nWhat makes this project even more interesting is its applicability. Not only we can measure the speed of moving cars or other objects, but we can also utilize this Arduino based speed sensor in scientific experiments to study motion, acceleration, or friction by measuring the speed of different objects in a controlled environments. So let's get started\n\n# What do you need to build an Arduino Speed Sensor\n\nBuilding an Arduino speed detector using IR technology to measure the speed of a moving object is much more cost-effective, and it is also very simple to build. All you need are a few basic parts, which are listed below.\n\nArduino UNO R3 development board\n\nArduino UNO R3 development board\n\nTwo IR Sensors\n\nTwo IR Sensors\n\n16x2 LCD Display with I2C module.\n\n16x2 LCD Display with I2C module.\n\nBreadboard\n\nBreadboard\n\nConnecting Wires\n\nConnecting Wires\n\n12V Power Adaptor with DC Barrel Jack\n\n12V Power Adaptor with DC Barrel Jack\n\nThese simple components are essential for us to get started on building our own Arduino speed sensor system.\n\n# Arduino Speed Detector Circuit Diagram\n\nA simple breadboard based circuit diagram is shown below to help you with making the connections. As you can see the circuit is very simple and only consists of two IR sensors, an Arduino Uno, LCD display and a breadboard.\n\nAlso note that, to power this circuit you will need an external 12V power adapter. Because this setup consumes more current, and ordinary PC USB ports can’t deliver it. The power adapter simply has to be connected to Arduino UNO and is not shown in the above circuit diagram.\n\nIn the below image, you can see the actual hardware setup developed by using our Arduino sensor circuit diagram as a reference. Here you can see that I am powering this whole setup from the external power adapter through a 12V DC jack. We have also marled the parts to make the connections easy to understand. Also note that we have covered the IR LEDs on the sensor with a black tape to make it point only forward, we will discuss more about that later. If you are completely new to IR sensors and wish to learn more you can check our Arduino IR sensor tutorial, where we have explained the basic working of the IR sensor module and how to use it with Arduino.\n\nYou can see our main controller, the “Arduino UNO R3”, is responsible for handling signals from IR sensors and doing some computation to calculate the speed of the object.\n\nHere in the below picture, you can find our 16x2 LCD display unit, where users can able to see the speed of the moving object on it. If you are completely new to 16x2 LCD and wish to learn more about it you can check out our tutorial on Arduino 16x2 LCD display to understand the basic pinout layout and working of the 16x2 LCD display.\n\nThe below image shows the bottom view of our display unit, where you can see it uses an I2C IO Expansion module. It means we don’t need to rely on complex parallel communication; we can simply control the display through the I2C serial protocol.\n\nBy using this kind of display, we can totally avoid the wiring complexity. This kind of I2C expansion boards for 16x2 LCD display is easily available in any electronics hardware store. It is recommended to use one to make the building processes easy.\n\n# How to Place the IR Sensor in the Right Position to Measure Speed\n\nNext we want to ensure that the distance between the two IR sensors is in multiples of 10 or in such a way that the microcontroller does the division operation without any errors. Because in general, the Arduino UNO R3 doesn’t have sophisticated hardware support for floating-point operation. For that, I decided to keep a 10 cm spacing between two IR sensors.\n\nwe can also make sure the spacing between the actual IR sensor should be bigger than the actual moving object’s size as shown in the below image. It’s not mandatory, but it helps in making our system work precisely.\n\nIn the next section, we are going to see some hardware hacks to overcome the IR sensor false trigger due to environmental factors.\n\n# Minimizing External Disturbance to IR sensor using Black Tape:\n\nAs we know, IR sensors are sensitive to external environmental conditions such as sunlight, room light, etc., which can significantly affect their accuracy and cause false triggers. To minimize that, I came up with an idea to cover the IR sensor’s LED using black tape by leaving its focus point alone uncovered.\n\nThis precautionary measure makes our speed sensor work properly in ambient light conditions without any problem.\n\n# How to Use IR Sensor Modules to Measure Speed?\n\nWhen measuring the speed of a moving object using two IR sensors, the process is based on calculating the time taken for a moving object to travel between those IR sensors. Later, speed can be calculated by dividing the distance traveled by the object by the time taken.\n\n# Basic Principle Behind IR Sensor Setup:\n\nThe two IR sensors are placed at a known distance apart from each other. When an object moves, it needs to pass the first IR sensor. While the object passes this first IR sensor, the first IR sensor signals Arduino to start the timer.\n\nLater the object passes the second IR sensor, and while passing the second IR sensor signals Arduino to stop the timer; this finally helps us to calculate the time taken by the object to pass between the two IR sensors.\n\n# Moving Object Actual Speed Calculation:\n\nWe already know the existing distance between the two IR sensors. After calculating the time taken by the objects to pass between the IR sensors, we can easily able to calculate the speed of the moving object using the “Speed Formula.”.\n\n# Speed Calculation Formula:\n\nThe formula for calculating speed is given below.\n\nSpeed = Distance between Two IR sensors   /   Time taken by the object to travel between two IR sensors\n\nFor example, if the distance between the two IR sensors is 1 meter and the object takes 0.5 seconds to travel between them, then the speed would be\n\nSpeed = 1 meter /  0.4 seconds   =>   2.5 m/s\n\n# Arduino Code for Speed Sensor\n\nIn general, the following code makes Arduino to measure the speed of the moving object using two IR sensors and display the object speed in the I2C 16x2 LCD display. When the object triggers the first and second sensors, the respective sensor interrupts the Arduino to record the time for each event.\n\nAfter that, Arduino calculates the speed using the distance between the two IR sensors and the time difference between the two IR sensors triggered time intervals. Later it displays the speed on the I2C LCD display.\n\n```arduino\n#include <Wire.h>\n#include <LiquidCrystal_I2C.h>\n```\n\n```arduino\n#include <Wire.h>\n#include <LiquidCrystal_I2C.h>\n```\n\nHere “Wire.h” and “LiquidCrystal_I2C.h” are included to make the Arduino UNO R3 board communicate with the I2C 16x2 LCD display and to control it easily without the need of writing complex hardware-specific libraries.\n\n```arduino\n// Initialize the I2C LCD with the default address (usually 0x27 or 0x3F)\nLiquidCrystal_I2C lcd(0x27, 16, 2);\n```\n\n```arduino\n// Initialize the I2C LCD with the default address (usually 0x27 or 0x3F)\nLiquidCrystal_I2C lcd(0x27, 16, 2);\n```\n\nThis line sets the LCD object to communicate with a 16x2 LCD display module using the I2C protocol. Once initialized, we can use its object “lcd” object to interact with the display, such as showing text, clearing the screen, or adjusting the backlight, etc.\n\n```arduino\n#define SENSOR_1_PIN 2 // Pin for first IR sensor (INT0)\n#define SENSOR_2_PIN 3 // Pin for second IR sensor (INT1)\n```\n\n```arduino\n#define SENSOR_1_PIN 2 // Pin for first IR sensor (INT0)\n#define SENSOR_2_PIN 3 // Pin for second IR sensor (INT1)\n```\n\nThis line defines “SENSOR_1_PIN” as pin 2 and “SENSOR_2_PIN” as pin 3 on the Arduino board, where the two IR sensor signal pins get connected. Here Arduino’s pin 2 is associated with the external interrupt INT0, and pin 3 corresponds with the external interrupt INT1. By defining the pins using the macros instead of the variable, we can save certain memory space.\n\n```arduino\nvolatile unsigned long timeSensor1 = 0;\nvolatile unsigned long timeSensor2 = 0;\nvolatile bool sensor1Triggered = false;\nvolatile bool sensor2Triggered = false;\nconst float distanceBetweenSensors = 0.1; // Distance between sensors in meters\nfloat speed = 0; // Speed in meters per second (m/s)\n```\n\n```arduino\nvolatile unsigned long timeSensor1 = 0;\nvolatile unsigned long timeSensor2 = 0;\nvolatile bool sensor1Triggered = false;\nvolatile bool sensor2Triggered = false;\nconst float distanceBetweenSensors = 0.1; // Distance between sensors in meters\nfloat speed = 0; // Speed in meters per second (m/s)\n```\n\nThese variables store the timestamps when the IR sensors are triggered “timeSensor1” and “timeSensor2”. The variables “sensor1Triggered” and “sensor2Triggered” are used as a flag to track the sensor triggering status. The fixed distance between the two IR sensors is stored in the constant variable “distanceBetweenSensors,” and the calculated speed of the moving object gets stored in the “speed” variable.\n\n```arduino\nvoid sensor1ISR() {\n if (!sensor1Triggered) { // Ensure only the first trigger is recorded\n   timeSensor1 = micros(); // Record the time of sensor 1 trigger\n   sensor1Triggered = true;\n }\n}\nvoid sensor2ISR() {\n if (!sensor2Triggered) { // Ensure only the first trigger is recorded\n   timeSensor2 = micros(); // Record the time of sensor 2 trigger\n   sensor2Triggered = true;\n }\n}\n```\n\n```arduino\nvoid sensor1ISR() {\n if (!sensor1Triggered) { // Ensure only the first trigger is recorded\n   timeSensor1 = micros(); // Record the time of sensor 1 trigger\n   sensor1Triggered = true;\n }\n}\nvoid sensor2ISR() {\n if (!sensor2Triggered) { // Ensure only the first trigger is recorded\n   timeSensor2 = micros(); // Record the time of sensor 2 trigger\n   sensor2Triggered = true;\n }\n}\n```\n\nThis void sensor1ISR() and void sensor2ISR() both function as the interrupt service routines of the first IR sensor and the second IR sensor, respectively. These ISRs handle the detection of the IR sensor’s triggers. When an object crosses a sensor, the ISR records the time using the micros() function and sets a flag to avoid the multiple triggers getting processed.\n\n```arduino\nvoid setup() {\n // Initialize the LCD\n lcd.init();\n lcd.backlight();\n lcd.setCursor(0, 0);\n lcd.print(\"Speed Gun\");\n delay(2000); // Show the title for 2 seconds\n lcd.clear();\n pinMode(SENSOR_1_PIN, INPUT);\n pinMode(SENSOR_2_PIN, INPUT);\n // Attach interrupt for sensor 1 (INT0) and sensor 2 (INT1)\n attachInterrupt(digitalPinToInterrupt(SENSOR_1_PIN), sensor1ISR, RISING);\n attachInterrupt(digitalPinToInterrupt(SENSOR_2_PIN), sensor2ISR, RISING);\n}\n```\n\n```arduino\nvoid setup() {\n // Initialize the LCD\n lcd.init();\n lcd.backlight();\n lcd.setCursor(0, 0);\n lcd.print(\"Speed Gun\");\n delay(2000); // Show the title for 2 seconds\n lcd.clear();\n pinMode(SENSOR_1_PIN, INPUT);\n pinMode(SENSOR_2_PIN, INPUT);\n // Attach interrupt for sensor 1 (INT0) and sensor 2 (INT1)\n attachInterrupt(digitalPinToInterrupt(SENSOR_1_PIN), sensor1ISR, RISING);\n attachInterrupt(digitalPinToInterrupt(SENSOR_2_PIN), sensor2ISR, RISING);\n}\n```\n\nIn this setup() function, the LCD gets initialized and displays the message “Speed Gun” for two seconds, then clears the screen using the predefined LCD libraries. The first and second sensor pins are set as inputs using the pinMode() function.\n\nLater hardware interrupts are configured on the sensor pins using the “attachInterrupt()” function, so when a rising edge signal (IR sensor object detection signal) occurs, the respective interrupt service routine functions, namely “sensor1ISR()” and “sensor2ISR(),” are invoked. This setup() function ensures the system is ready to detect the object while it passes through both IR sensors without any latency in response time.\n\n```arduino\nvoid loop() {\n if (sensor1Triggered && sensor2Triggered) {\n   sensor1Triggered = false;\n   sensor2Triggered = false;\n   unsigned long timeDifference = abs(timeSensor2 - timeSensor1); // Time in microseconds\n   lcd.clear();\n   if (timeDifference > 0) {\n     speed = distanceBetweenSensors / (timeDifference / 1000000.0); // Convert µs to seconds\n     lcd.setCursor(0, 0);\n     lcd.print(\"Speed:\");\n     lcd.setCursor(0, 1);\n     lcd.print(speed, 2); // Display speed with 2 decimal places\n     lcd.print(\" m/s\");\n   } else {\n     lcd.setCursor(0, 0);\n     lcd.print(\"Invalid Reading!\");\n   }\n }\n}\n```\n\n```arduino\nvoid loop() {\n if (sensor1Triggered && sensor2Triggered) {\n   sensor1Triggered = false;\n   sensor2Triggered = false;\n   unsigned long timeDifference = abs(timeSensor2 - timeSensor1); // Time in microseconds\n   lcd.clear();\n   if (timeDifference > 0) {\n     speed = distanceBetweenSensors / (timeDifference / 1000000.0); // Convert µs to seconds\n     lcd.setCursor(0, 0);\n     lcd.print(\"Speed:\");\n     lcd.setCursor(0, 1);\n     lcd.print(speed, 2); // Display speed with 2 decimal places\n     lcd.print(\" m/s\");\n   } else {\n     lcd.setCursor(0, 0);\n     lcd.print(\"Invalid Reading!\");\n   }\n }\n}\n```\n\nIn this loop() function, the code checks both IR sensors triggered flag status to know whether the object passes through it. If yes, then it starts to calculate the time difference using both IR sensors triggered time, and it computes the speed of the moving object using the known variables distanceBetweenSensors and timeDifference.\n\nAfter that, the calculated speed is made to be displayed on the LCD screen with the two decimal places. If the time difference is invalid, it will print “Invalid Reading” on the display. The above process is repeated as long as both sensors are triggered.\n\nThat’s all about Arduino code. Let's feed this compiled binary code to the Arduino UNO R3 for converting the ordinary Arduino to a moving object speed-measuring device.\n\n# Car Speed Detector using Arduino and IR Sensor\n\nThat’s all; now we are in the final stage of testing our Arduino Speed Sensor project to measure the speed of moving objects. In the GIF below, you can see our project’s actual working.\n\n# Working Video\n\nYou can also find the complete project demonstration by clicking the video link below.\n\n# Other Arduino Projects Related to Speed Measuring\n\nPreviously we have built many Arduino Projects, I have listed a few projects that are related to measuring speed using Arduino. You can check them out if you want to build something similar next, all projects are well documented with circuit diagram and code for you to learn and build easily.\n\nAnalog Speedometer Using Arduino and IR Sensor\n\nThis project uses an IR sensor to measure the speed or RPM of a moving object, such as a motor or vehicle wheel. The speed is displayed in both analog and digital formats, making it useful for various applications.\n\nSpeed, Distance and Angle Measurement for Mobile Robots using Arduino and LM393 Speed Sensor (H206) Primary tabs View Revisions\n\nThis project utilizes an LM393 speed sensor module to track a robot’s speed, distance traveled, and turning angle. It helps in developing precise navigation systems for mobile robots.\n\nDIY GPS Speedometer using Arduino and OLED\n\nUsing a GPS module, this project measures the speed of a moving vehicle and displays it on an OLED screen. It provides an easy way to create a digital speedometer without mechanical sensors.\n\nDIY Speedometer using Arduino and Processing Android App\n\nThis project combines an Arduino, a hall sensor, and an Android app to measure and display vehicle speed. The data is sent to the app via Bluetooth, offering a modern and wireless speed monitoring solution.\n\n# Complete Project Code\n\n```arduino\n#include <Wire.h>\n#include <LiquidCrystal_I2C.h>\n// Initialize the I2C LCD with the default address (usually 0x27 or 0x3F)\nLiquidCrystal_I2C lcd(0x27, 16, 2);\n#define SENSOR_1_PIN 2 // Pin for first IR sensor (INT0)\n#define SENSOR_2_PIN 3 // Pin for second IR sensor (INT1)\nvolatile unsigned long timeSensor1 = 0;\nvolatile unsigned long timeSensor2 = 0;\nvolatile bool sensor1Triggered = false;\nvolatile bool sensor2Triggered = false;\nconst float distanceBetweenSensors = 0.1; // Distance between sensors in meters\nfloat speed = 0; // Speed in meters per second (m/s)\nvoid setup() {\n // Initialize the LCD\n lcd.init();\n lcd.backlight();\n lcd.setCursor(0, 0);\n lcd.print(\"Speed Gun\");\n delay(2000); // Show the title for 2 seconds\n lcd.clear();\n pinMode(SENSOR_1_PIN, INPUT);\n pinMode(SENSOR_2_PIN, INPUT);\n // Attach interrupt for sensor 1 (INT0) and sensor 2 (INT1)\n attachInterrupt(digitalPinToInterrupt(SENSOR_1_PIN), sensor1ISR, RISING);\n attachInterrupt(digitalPinToInterrupt(SENSOR_2_PIN), sensor2ISR, RISING);\n}\nvoid loop() {\n if (sensor1Triggered && sensor2Triggered) {\n   sensor1Triggered = false;\n   sensor2Triggered = false;\n   unsigned long timeDifference = abs(timeSensor2 - timeSensor1); // Time in microseconds\n   lcd.clear();\n   if (timeDifference > 0) {\n     speed = distanceBetweenSensors / (timeDifference / 1000000.0); // Convert µs to seconds\n     lcd.setCursor(0, 0);\n     lcd.print(\"Speed:\");\n     lcd.setCursor(0, 1);\n     lcd.print(speed, 2); // Display speed with 2 decimal places\n     lcd.print(\" m/s\");\n   } else {\n     lcd.setCursor(0, 0);\n     lcd.print(\"Invalid Reading!\");\n   }\n }\n}\nvoid sensor1ISR() {\n if (!sensor1Triggered) { // Ensure only the first trigger is recorded\n   timeSensor1 = micros(); // Record the time of sensor 1 trigger\n   sensor1Triggered = true;\n }\n}\nvoid sensor2ISR() {\n if (!sensor2Triggered) { // Ensure only the first trigger is recorded\n   timeSensor2 = micros(); // Record the time of sensor 2 trigger\n   sensor2Triggered = true;\n }\n}\n```\n\n```arduino\n#include <Wire.h>\n#include <LiquidCrystal_I2C.h>\n// Initialize the I2C LCD with the default address (usually 0x27 or 0x3F)\nLiquidCrystal_I2C lcd(0x27, 16, 2);\n#define SENSOR_1_PIN 2 // Pin for first IR sensor (INT0)\n#define SENSOR_2_PIN 3 // Pin for second IR sensor (INT1)\nvolatile unsigned long timeSensor1 = 0;\nvolatile unsigned long timeSensor2 = 0;\nvolatile bool sensor1Triggered = false;\nvolatile bool sensor2Triggered = false;\nconst float distanceBetweenSensors = 0.1; // Distance between sensors in meters\nfloat speed = 0; // Speed in meters per second (m/s)\nvoid setup() {\n // Initialize the LCD\n lcd.init();\n lcd.backlight();\n lcd.setCursor(0, 0);\n lcd.print(\"Speed Gun\");\n delay(2000); // Show the title for 2 seconds\n lcd.clear();\n pinMode(SENSOR_1_PIN, INPUT);\n pinMode(SENSOR_2_PIN, INPUT);\n // Attach interrupt for sensor 1 (INT0) and sensor 2 (INT1)\n attachInterrupt(digitalPinToInterrupt(SENSOR_1_PIN), sensor1ISR, RISING);\n attachInterrupt(digitalPinToInterrupt(SENSOR_2_PIN), sensor2ISR, RISING);\n}\nvoid loop() {\n if (sensor1Triggered && sensor2Triggered) {\n   sensor1Triggered = false;\n   sensor2Triggered = false;\n   unsigned long timeDifference = abs(timeSensor2 - timeSensor1); // Time in microseconds\n   lcd.clear();\n   if (timeDifference > 0) {\n     speed = distanceBetweenSensors / (timeDifference / 1000000.0); // Convert µs to seconds\n     lcd.setCursor(0, 0);\n     lcd.print(\"Speed:\");\n     lcd.setCursor(0, 1);\n     lcd.print(speed, 2); // Display speed with 2 decimal places\n     lcd.print(\" m/s\");\n   } else {\n     lcd.setCursor(0, 0);\n     lcd.print(\"Invalid Reading!\");\n   }\n }\n}\nvoid sensor1ISR() {\n if (!sensor1Triggered) { // Ensure only the first trigger is recorded\n   timeSensor1 = micros(); // Record the time of sensor 1 trigger\n   sensor1Triggered = true;\n }\n}\nvoid sensor2ISR() {\n if (!sensor2Triggered) { // Ensure only the first trigger is recorded\n   timeSensor2 = micros(); // Record the time of sensor 2 trigger\n   sensor2Triggered = true;\n }\n}\n```\n\n# Start a Discussion on:\n\n# Add New Comment\n\nLog in or register to post comments"}
{"title":"Smart Dustbin using Arduino and Ultrasonic Sensor","content":"Smart Dustbin as its name represents its work smartly or we can say that it is an automatic dustbin. Smart Dustbin is a very good project from the Arduino. We can say that It is a decent gadget to make your home clean and attractive. kids spread trash to a great extent by paper, rappers and numerous different things at home. They will have fun with this dustbin they play with the dustbin and in the play of them, they clean your home as well because every time they use the smart Dustbin and it attracts the kids. They generally will be utilized to throw all trash and waste into this smart dustbin. if your hands are full of trash or junk and you're unable to open it manually this can be used. As it opens automatically without touching, this can help to control the spread of Coronavirus and even mosquitoes will not move around it so that it helps from preventing the spread of new diseases. Previously, We have also built IoT Based Dumpster Monitoring using ESP8266 and IoT Smart Dustbin using NodeMCU.\n\n# Component Requirement for Arduino Based Dustbin\n\nThe following are the components required to build a smart dustbin using Arduino.\n\nProject Used Hardware\n\nArduino UNO,\n\nArduino UNO,\n\nJumper Wires,\n\nJumper Wires,\n\nServo Motor,\n\nServo Motor,\n\nUltrasonic Sensor\n\nUltrasonic Sensor\n\nProject Used Software\n\nArduino IDE\n\nArduino IDE\n\n# Project Hardware Software Selection\n\nArduino UNO: As you know that Arduino is a microcontroller-based open source electronic prototyping board that can be programmed with an easy-to-use Arduino IDE. The UNO is one of the most popular boards in Arduino family and a great choice for beginners.\n\nUltrasonic Sensor: These are the sensor that use ultrasonic waves to detect objects or to measure the distance between themselves and the object\n\nServo Motor: This is an electrical device that can push or pull and also rotate an object with great precision. if you want to rotate an object at some specific angles or distance, then you use servo motor. It is made up of a simple motor that runs through a servo mechanism. We can get a very high torque servo motor in a small and light weight packages.\n\n# Block Diagram\n\nThe working of this Arduino smart dustbin is very simple. The ultrasonic sensor acts as the input and the servo motor acts as the output, the Arduino UNO microcontroller is the main brain behind the project. The block diagram for Arduino smart dustbin is shown below\n\nAs shown in the block diagram, the Arduino microcontroller constantly monitors the values from the ultrasonic sensor which is placed outside the dustbin. When a person comes near the dustbin the values from the sensor change, this change is noticed by the microcontroller, and it then turns the servo motor to open the dustbin. After some time the controller turns the servo again in the opposite direction to close the dustbin, then the whole process is reapted again.\n\n# Circuit Diagram\n\nThe image below shows the Arduino circuit diagram for building a smart bin. As you can see it is very simple, it just has an ultrasonic sensor and a servo motor connected to the Arduino UNO, and the whole setup is powered by a 9V battery.\n\nYou can make the connections as shown in the circuit diagram, if you have any doubts you can also follow the connection diagram below\n\n# Smart Dustbin Arduino Code Explanation\n\nThe code for the Arduino Smart Dustbin is very simple and straightforward. The complete code for this project can be found at the bottom of this page. But now let's break the code into small segments to understand how the code works. Starting with library and variable declaration\n\n```arduino\n#include <Servo.h>   //servo library\nServo servo;    \nint trigPin = 5;   \nint echoPin = 6;  \nint servoPin = 7;\nint led= 10;\nlong duration, dist, average;  \nlong aver[3];   //array for average\n```\n\n```arduino\n#include <Servo.h>   //servo library\nServo servo;    \nint trigPin = 5;   \nint echoPin = 6;  \nint servoPin = 7;\nint led= 10;\nlong duration, dist, average;  \nlong aver[3];   //array for average\n```\n\nWe have used the Servo.h library to control the servo motor using Arduino. This library is already pre-installed in Arduino and is very easy to use. If you are completely new to servo motors and Arduino, you can read our article on how to use servo motor with Arduino. Next, we have mentioned to which pins our ultrasonic sensor and servo motor is connected to, in this case trigger pin is connected to pin5, echo pin is connected to pin 6 and servo signal pin is connected to pin 7 of Arduino UNO.\n\n```arduino\nvoid setup() {      \n   Serial.begin(9600);\n   servo.attach(servoPin); \n   pinMode(trigPin, OUTPUT); \n   pinMode(echoPin, INPUT); \n   servo.write(0);         //close cap on power on\n   delay(100);\n   servo.detach();\n}\n```\n\n```arduino\nvoid setup() {      \n   Serial.begin(9600);\n   servo.attach(servoPin); \n   pinMode(trigPin, OUTPUT); \n   pinMode(echoPin, INPUT); \n   servo.write(0);         //close cap on power on\n   delay(100);\n   servo.detach();\n}\n```\n\nInside the void setup function, we start the serial monitor at 9600 baud rate which will be useful for debugging. And then initialize the servo motor and declare trigger pin as output pin and echo pin as input pin. We are also moving the servo motor position to 0, to make sure the dustbin is closed during power on.\n\n```arduino\nvoid measure() { \ndigitalWrite(10,HIGH);\ndigitalWrite(trigPin, LOW);\ndelayMicroseconds(5);\ndigitalWrite(trigPin, HIGH);\ndelayMicroseconds(15);\ndigitalWrite(trigPin, LOW);\npinMode(echoPin, INPUT);\nduration = pulseIn(echoPin, HIGH);\ndist = (duration/2) / 29.1;    //obtain distance\n}\n```\n\n```arduino\nvoid measure() { \ndigitalWrite(10,HIGH);\ndigitalWrite(trigPin, LOW);\ndelayMicroseconds(5);\ndigitalWrite(trigPin, HIGH);\ndelayMicroseconds(15);\ndigitalWrite(trigPin, LOW);\npinMode(echoPin, INPUT);\nduration = pulseIn(echoPin, HIGH);\ndist = (duration/2) / 29.1;    //obtain distance\n}\n```\n\nThe above function called measure(), is used to measure the distance between an the dustbin and the object in front of it. First we turn on the trig pin and wait for 15 microseconds and then turn it off, this will send the ultrasonic waves out of this sensor which will get deflected back to the sensor after hitting on the object in front. We will read these ultrasonic waves again using the sensor by using the echo pin as input. Then calculate the duration and distance using the above formulae. If you can also read how to use ultrasonic sensors with Arduino if you are completely new to ultrasonic sensors.\n\n```arduino\nvoid loop() {\n for (int i=0;i<=2;i++) {   //average distance\n   measure();              \n  aver[i]=dist;           \n   delay(10);              //delay between measurements\n }\ndist=(aver[0]+aver[1]+aver[2])/3;   \nif ( dist<50 ) {\n//Change distance as per your need\nservo.attach(servoPin);\n delay(1);\nservo.write(0); \ndelay(3000);      \nservo.write(150);   \ndelay(1000);\nservo.detach();     \n}\nSerial.print(dist);\n}\n```\n\n```arduino\nvoid loop() {\n for (int i=0;i<=2;i++) {   //average distance\n   measure();              \n  aver[i]=dist;           \n   delay(10);              //delay between measurements\n }\ndist=(aver[0]+aver[1]+aver[2])/3;   \nif ( dist<50 ) {\n//Change distance as per your need\nservo.attach(servoPin);\n delay(1);\nservo.write(0); \ndelay(3000);      \nservo.write(150);   \ndelay(1000);\nservo.detach();     \n}\nSerial.print(dist);\n}\n```\n\nInside the void loop function, we will implement the main logic of our arduino smart dustbin project. First we use a for loop to measure the distance between the sensor and the object using the measure function we discussed earlier, this is done three times  and all the results are stored in an array called aver. We then take the average of all three values to calculate the distance. If this measured distance is less than 50 we will open the dustbin by controlling the servo motor. After opening we will wait for 3 seconds and then close the dustbin automatically using the servo motor again. In the code the servo position 0 is used to open the dustbin and position 150 is used to close the dustbin.\n\n# Other Smart Dustbin Projects\n\nNow that you have learnt how to build a simple smart dustbin project using Arduino UNO, you can checkout the below smart dustbin projects which you can use to enhance your project and add more features. All projects have clear circuit diagram and code for anyone to easily rebuild.\n\nIoT based Smart Dustbin Management System using NodeMCU\n\nIt gives a real time indicator of the garbage level in a trashcan at any given time. Using that data, we can then optimize waste collection routes and ultimately reduce fuel consumption. It allows trash collectors to plan their daily/weekly pick up schedule. The level of dustbin filled or not is done by using an Ultrasonic sensor or IR sensor. Through an internet app or web page, every truck driver knew the real time data easily.\n\nSmart Dustbin using Arduino\n\nThe core objective of the Arduino Smart Dustbin is to detect the presence and open the dustbin, later after the trash is put we have to close it.We have put Ultrasonic sensor on top of the dustbin's cover. So, when the sensor sees something like a person's hand, it tells the Arduino to open the lid.\n\nIoT Based Smart Bin\n\nIoT-Based Smart Bin project features a custom-built IoT system and Firebase database, using the Arduino Uno R4 WiFi. Dual ultrasonic sensors handle motion and fill-level monitoring, with an automated lid synced to a Firebase dashboard built on Vite+React for real-time updates. This solution uniquely integrates our own IoT network for efficient waste management. We’re moving forward with multi-node testing to enhance scalability and user experience.\n\n# Complete Project Code\n\n```arduino\n//Smart Dustbin using Arduino Code\n//More info: https://circuitdigest.com/microcontroller-projects/how-to-make-smart-dustbin-using-arduino\n#include <Servo.h>   //servo library\nServo servo;    \nint trigPin = 5;   \nint echoPin = 6;  \nint servoPin = 7;\nint led= 10;\nlong duration, dist, average;  \nlong aver[3];   //array for average\nvoid setup() {      \n    Serial.begin(9600);\n    servo.attach(servoPin); \n    pinMode(trigPin, OUTPUT); \n    pinMode(echoPin, INPUT); \n    servo.write(0);         //close cap on power on\n    delay(100);\n    servo.detach();\n}\nvoid measure() { \n digitalWrite(10,HIGH);\ndigitalWrite(trigPin, LOW);\ndelayMicroseconds(5);\ndigitalWrite(trigPin, HIGH);\ndelayMicroseconds(15);\ndigitalWrite(trigPin, LOW);\npinMode(echoPin, INPUT);\nduration = pulseIn(echoPin, HIGH);\ndist = (duration/2) / 29.1;    //obtain distance\n}\nvoid loop() {\n  for (int i=0;i<=2;i++) {   //average distance\n    measure();              \n   aver[i]=dist;           \n    delay(10);              //delay between measurements\n  }\n dist=(aver[0]+aver[1]+aver[2])/3;   \nif ( dist<50 ) {\n//Change distance as per your need\n servo.attach(servoPin);\n  delay(1);\n servo.write(0); \n delay(3000);      \n servo.write(150);   \n delay(1000);\n servo.detach();     \n}\nSerial.print(dist);\n}\n```\n\n```arduino\n//Smart Dustbin using Arduino Code\n//More info: https://circuitdigest.com/microcontroller-projects/how-to-make-smart-dustbin-using-arduino\n#include <Servo.h>   //servo library\nServo servo;    \nint trigPin = 5;   \nint echoPin = 6;  \nint servoPin = 7;\nint led= 10;\nlong duration, dist, average;  \nlong aver[3];   //array for average\nvoid setup() {      \n    Serial.begin(9600);\n    servo.attach(servoPin); \n    pinMode(trigPin, OUTPUT); \n    pinMode(echoPin, INPUT); \n    servo.write(0);         //close cap on power on\n    delay(100);\n    servo.detach();\n}\nvoid measure() { \n digitalWrite(10,HIGH);\ndigitalWrite(trigPin, LOW);\ndelayMicroseconds(5);\ndigitalWrite(trigPin, HIGH);\ndelayMicroseconds(15);\ndigitalWrite(trigPin, LOW);\npinMode(echoPin, INPUT);\nduration = pulseIn(echoPin, HIGH);\ndist = (duration/2) / 29.1;    //obtain distance\n}\nvoid loop() {\n  for (int i=0;i<=2;i++) {   //average distance\n    measure();              \n   aver[i]=dist;           \n    delay(10);              //delay between measurements\n  }\n dist=(aver[0]+aver[1]+aver[2])/3;   \nif ( dist<50 ) {\n//Change distance as per your need\n servo.attach(servoPin);\n  delay(1);\n servo.write(0); \n delay(3000);      \n servo.write(150);   \n delay(1000);\n servo.detach();     \n}\nSerial.print(dist);\n}\n```\n\n```arduino\n//Smart Dustbin using Arduino Code\n//More info: https://circuitdigest.com/microcontroller-projects/how-to-make-smart-dustbin-using-arduino\n#include <Servo.h>   //servo library\nServo servo;    \nint trigPin = 5;   \nint echoPin = 6;  \nint servoPin = 7;\nint led= 10;\nlong duration, dist, average;  \nlong aver[3];   //array for average\nvoid setup() {      \n    Serial.begin(9600);\n    servo.attach(servoPin); \n    pinMode(trigPin, OUTPUT); \n    pinMode(echoPin, INPUT); \n    servo.write(0);         //close cap on power on\n    delay(100);\n    servo.detach();\n}\nvoid measure() { \n digitalWrite(10,HIGH);\ndigitalWrite(trigPin, LOW);\ndelayMicroseconds(5);\ndigitalWrite(trigPin, HIGH);\ndelayMicroseconds(15);\ndigitalWrite(trigPin, LOW);\npinMode(echoPin, INPUT);\nduration = pulseIn(echoPin, HIGH);\ndist = (duration/2) / 29.1;    //obtain distance\n}\nvoid loop() {\n  for (int i=0;i<=2;i++) {   //average distance\n    measure();              \n   aver[i]=dist;           \n    delay(10);              //delay between measurements\n  }\n dist=(aver[0]+aver[1]+aver[2])/3;   \nif ( dist<50 ) {\n//Change distance as per your need\n servo.attach(servoPin);\n  delay(1);\n servo.write(0); \n delay(3000);      \n servo.write(150);   \n delay(1000);\n servo.detach();     \n}\nSerial.print(dist);\n}\n```\n\n# Start a Discussion on:\n\n# Add New Comment\n\nLog in or register to post comments"}
{"title":"Build a Simple Automatic Plant Watering System using Arduino","content":"Building an automatic plant watering system is becoming increasingly popular among gardening enthusiasts and IoT hobbyists. This DIY automatic plant watering system project helps solve the common problem of forgetting to water plants while away from home. In this complete guide, we'll show you how to make an automatic plant watering system with soil moisture sensing and mobile app control capabilities.\n\n# What is an Automatic Plant Watering System?\n\nAn Automatic Plant watering system is a device (or setup) that uses sensors to monitor the soil moisture and if the moisture is low it will automatically water the plants, typically using a water pump and a microcontroller. This system saves time, reduces water consumption and also ensures plants get the right amount of water when needed. In this project, we will build such a system, but additionally, we will also include some IoT features to water the plants remotely and get SMS alerts if soil moisture is low.\n\n# How to make an Automatic Plant Watering System?\n\nAfter brainstorming and surfing the internet, I found that building an automatic plant watering system is easy. So first, I created a checklist to determine what things I needed for this project. Most obviously, I need an electric pump to water the plants, and to control the pump, I need a microcontroller. I decided to pick the Arduino UNO R4 for the microcontroller because it has the most powerful RA4M1 microprocessor from Renesas with the ESP32-S3 from Espressif. With its Wi-Fi capability, we can provide internet access to the microcontroller, which is mandatory to access the microcontroller remotely. This microcontroller also has an inbuilt 12x8 LED matrix, so I was able to display the plant expressions on it. Finally, I need an analog soil moisture sensor so that I can monitor the soil moisture, and based on that, I can switch on/off the water pump remotely through the Blynk app.\n\n# Components Required\n\nBelow, is the detailed list of the components that I am going to use in this project:\n\nArduino UNO R4 WIFI - 1 NOS\n\nArduino UNO R4 WIFI - 1 NOS\n\n5V single-channel relay module - 1 NOS\n\n5V single-channel relay module - 1 NOS\n\n5V water pump - 1NOS\n\n5V water pump - 1NOS\n\nFC-28 soil moisture sensor with sensor module - 1 NOS\n\nFC-28 soil moisture sensor with sensor module - 1 NOS\n\nConnecting jumper wires - REQUIRED NOS\n\nConnecting jumper wires - REQUIRED NOS\n\n12V DC jack power adapter/5V USB-C power adapter\n\n12V DC jack power adapter/5V USB-C power adapter\n\nMobile phone & Personal computer with active internet connection\n\nMobile phone & Personal computer with active internet connection\n\n# Automatic Plant Watering System Block Diagram\n\nThe below block diagram gives us a clear view of how this automatic plant watering system will work. Basically we have the Arduino Uno R4 which will read the soil moisture level using the soil moisture sensor. If the moisture is low it will automatically turn on the water pump via the relay module.\n\nApart from this, we have also used the Blynk IoT cloud platform, to remotely monitor the soil moisture sensor values and turn on the water pump through our mobile application. So the Arduino Uno R4 sends the soil moisture data to the blynk cloud and if a button is pressed on the blynk mobile app it is sent to the Arduino Uno via the Blynk Cloud Application.\n\n# Automatic Plant Watering System Circuit Diagram\n\nThe below circuit diagram uses Arduino UNO R4 WiFi as a main controller, but you can use any other microcontroller by swapping it and making little modifications to the code. Here I decided to use Arduino UNO R4 because it has an in-built LED matrix for mimicking plant facial expressions.\n\nWe must ensure the components are connected correctly as per the above circuit diagram. Note that we can't directly drive the water pump from the Arduino UNO R4 Wi-Fi peripheral pins. For that, we need either a motor driver module or a relay module. For simplicity, I opt for a relay module with an external power source.\n\nFor the power supply, we can use either an external 12V adapter for powering Arduino through a DC jack or we can also provide a 5V supply through a USB-C port. For the water pump, we can either power it through an external source or we can use a 5 V power pin from Arduino (only while Arduino is powered by USB-C).\n\nNext, we are going to make our hands dirty. Yes, you are going to build an actual hardware setup by using a circuit diagram as a reference. Before that, carefully read the below hardware setup guidelines, especially when choosing a power source for the water pump.\n\n# Hardware Setup Guide\n\nIn the below image, you can find the actual hardware setup to build an automatic plant watering system using a soil moisture sensor. In this setup, you can find that I am powering the Arduino UNO R4 Wi-Fi through a Type C USB port. So I don't need to provide an external power supply; I am able to provide a power supply to the water pump from the Arduino 5V pin itself.\n\nWhile we power Arduino through a USB port, it bypasses the voltage regulator present on the Arduino Uno R4 Wi-Fi board, so we can consume current up to 2 mA from the 5V pin, which is enough for driving all these things. In the below image, you can see that I am using a 5V water pump motor and a single-channel 5V relay module, which has 3 pins on the input side and 3 pins on the output side. On the input side, it has three pins, namely VCC, GND, and Signal (IN) pin. We can control the relay output using a signal pin by providing either 0V or 5V.\n\nOn the other hand, it has three output pins, namely Normally Open (NO), Normally Closed (NC), and Common (COM). But here we use only two relay output pins NO and COM pin for controlling the water pump motor. We utilize the Normally Open pin to make the motor off if the Signal pin is low and vice versa.\n\nYou can also find the soil moisture sensor with a sensor module, where this module has 4 pins namely VCC, GND, A0 (analog output pin), and D0 (digital output pin). But in our project, we use an Analog pin (A0) for getting the analog sensor value. On the other hand, it has two pins, which are usually used for connecting the sensor. It doesn't have a polarity, so no matter how we connect the sensor, it works fine. If you are completely new to soil moisture sensors you can check out our detailed guilde on how to use soil moisture sensor with Arduino to understand the basics of the sensor and how it works.\n\nThe above image shows the working of a soil moisture sensor, notice how the output voltage of the module decreases from 5V to 0V based ont he water content in the soil. Next, we move on to the microcontroller coding part. But before that, let's discuss how to generate the Blynk auth token and Blynk template ID through a PC, which is crucial for the microcontroller to communicate with Blynk Cloud.\n\n# Blynk Auth Code and Template ID Generation:\n\nSTEP 1: Visit https://blynk.io/ If you don't have a Blynk account, click on signup to create a new account. If you already have an account, then click login and enter your credentials to access the Blynk portal.\n\nSTEP 2: After logging in/signup, you will see this webpage. To create a template and generate the code, you need to be in developer mode. To check whether you are in developer mode or not, click the profile menu as shown in the image. Then make sure the \"developer mode\" is enabled and reload the webpage.\n\nSTEP 3: After enabling the developer mode option, select the \"Developer zone option\" present on the top left corner side, then click on the \"new template\" present on the top right corner side. It will prompt you to fill in template details. Fill in the details as I mentioned in the image\n\nSTEP 4: After filling out the template details, click done. It will move you to the custom template configuration page, where we can customize our template. But our goal is to monitor and control the watering system through the phone; for that, we want to use the \"Blynk Mobile app\" to customize the template. Anyway, in order to get the template ID and auth code, we need to follow this method on PC, wherein mobile is not possible.\n\nHere you can find the template ID and name; just copy and save it. So that we can include it in our microcontroller code. After copying, just click save to save the template.\n\nSTEP 5: Still, we need the Blynk auth code, to obtain the auth code, we need to create a device, which is going to utilize this template. For that, we need to click on the \"Devices\" option, then click on \"New Device\" to create a new device.\n\nSTEP 6: After clicking \"New device\" it will ask in which way to create a device. Click the option \"From template.\"\n\nThen it will ask for the device name and which template it is going to use. For the template, use our previously created template, \"Remote Watering System.\" Here I use \"Arduino Wifi\" as a device name. After filling out the details, click Create.\n\nSTEP 7: After clicking Create, the new device will be created. In the top right corner, you can find the Blynk auth code and the previously noted template details. Just copy and save it for microcontroller coding usage.\n\nThat's all, finally, we generated the Blynk auth code and template details. Here you can see our newly created device and template\n\n# Template Widget Customization on Blynk Mobile App:\n\nPreviously, we discussed how to generate the Blynk auth code and template ID through PC. Now here we are moving on to how to customize the template widget in mobile phones for monitoring the soil moisture level and controlling the water pump.\n\nSTEP 1: Install the latest \"Blynk IoT\" mobile app from your respective mobile app store.\n\nSTEP 2: After installing, just open the app. It asks you to log in/sign up. We already created a Blynk account for Auth code and template ID generation. so use that account credential for logging in.\n\nSTEP 3: After logging in, you can find our previously created device on the app home page.\n\nSTEP 4: To customize our template, we want to ensure that we are in developer mode. To find out, just click the line symbol in the left corner. It will show you many options; on that, click the \"My Profile\" option. It will show you the \"Developer zone\" status. If it is off, just turn it on\n\nSTEP 5: After that, click on the \"spanner symbol\" on the top side of the home page. You can find our previously created template. Click our template to customize the widgets. Click on the \"+\" symbol for importing the required widgets.\n\nSTEP 6: Generally, we need only two widgets: a button for controlling the water pump and a Radial gauge for monitoring the soil moisture. After importing the two widgets, we need to place those widgets properly and adjust their size for an enhanced user experience. After widget placement, we want to create virtual pins for those widgets.\n\nTo create the virtual pin for the radial gauge, we want to single-tap that widget. Later, it asks us to create a data stream as shown in the below image.\n\nSTEP 7: After clicking “Choose datastream”, create a virtual data stream pin for the Radial gauge. By clicking the create virtual pin datastream button, enter the virtual PIN. After following the steps as shown in the image, we can create a virtual pin V0 for the Radial gauge.\n\nWhile creating a virtual datastream pin, we chose the data type as double to get precise data and also used the 0 to 100 range to display the percentage value.\n\nSTEP 8: We created the virtual pin for the radial gauge. Now we want to create a new virtual pin for the Button widget by clicking \"create new\" and following the steps shown in the below image because the V0 pin is specifically for radial gauge\n\nHere we choose V1 data as an integer, and it has only two states, either 0 or 1. It sends data \"1\" in on state and \"0\" in off state.\n\nSTEP 9: At last, we created the virtual pin datastream pins for both widgets. Later, we can also customize widgets' visuals, like how they should appear in the phone's dark and light modes. We can also give a Title to each of the widgets\n\nTo modify the widgets visually, we need to single-tap the widgets present on our template. After tapping, we can find the \"Design\" symbol present on the bottom. Click that \"Design\" symbol, and now you can explore widget visual customization options\n\nSTEP 10: After widget visual customization, you can see its exact user interface by clicking your device that found on the app's home page\n\nNote: it's not necessary to use the same widgets for your application. However, make sure that the virtual pins mapped in the app template and in the microcontroller code are the same.\n\n# Automatic Plant Watering System Arduino Code\n\nFirst of all, that code allows the microcontroller to access the internet by connecting to the available known Wi-Fi hotspot. After accessing the internet, the controller can access the Blynk cloud by using the Blynk auth token. Here Blynk Cloud acts as a datastreamer between the microcontroller and Blynk app.\n\nAfter Blynk authorization, the code makes the microcontroller keep on fetching soil moisture data from the sensor, and based on that data, it drives the onboard LED matrix to bring out different expressions like sad, normal, and happy.\n\nAt the same time, it also forwards moisture data to the Blynk cloud and continuously polls for any incoming pump on/off command from the Blynk cloud. Based on the incoming command, it makes the microcontroller turn on/off the water pump.\n\nHere you can find the source code with an explanation for each section The below header files are critical for accessing the Blynk cloud server\n\n```arduino\n#define BLYNK_TEMPLATE_ID \"XXXXXXXXXXX\"\n#define BLYNK_TEMPLATE_NAME \"XXXXXXXXXXXX\"\n#define BLYNK_AUTH_TOKEN \"XXXXXXXXXXXXX\"\n```\n\n```arduino\n#define BLYNK_TEMPLATE_ID \"XXXXXXXXXXX\"\n#define BLYNK_TEMPLATE_NAME \"XXXXXXXXXXXX\"\n#define BLYNK_AUTH_TOKEN \"XXXXXXXXXXXXX\"\n```\n\nThese are the necessary header files needed while using predefined functions\n\n```arduino\n#include <SPI.h>\n#include <WiFiS3.h>\n#include <BlynkSimpleWifi.h>\n#include \"Arduino_LED_Matrix.h\"\n#include <EEPROM.h>\n```\n\n```arduino\n#include <SPI.h>\n#include <WiFiS3.h>\n#include <BlynkSimpleWifi.h>\n#include \"Arduino_LED_Matrix.h\"\n#include <EEPROM.h>\n```\n\nHere we define the soil moisture sensor pin and relay module signal pin\n\n```arduino\n#define moisture_sensor A0\n#define relay 7\n```\n\n```arduino\n#define moisture_sensor A0\n#define relay 7\n```\n\nThese are the necessary objects for blynk and led matrix predefined functions\n\n```arduino\nBlynkTimer timer;\nArduinoLEDMatrix matrix;\n```\n\n```arduino\nBlynkTimer timer;\nArduinoLEDMatrix matrix;\n```\n\nHere user wants to enter our Wi-Fi username and password for providing internet access to the microcontroller\n\n```arduino\nchar ssid[] = \"XXXXXXXXX\";                 //WIFI NAME\nchar pass[] = \"XXXXXXXXXXX\";          //WIFI PASSWORD\n```\n\n```arduino\nchar ssid[] = \"XXXXXXXXX\";                 //WIFI NAME\nchar pass[] = \"XXXXXXXXXXX\";          //WIFI PASSWORD\n```\n\nThese are important variables for storing the sensor data, EEPROM address, and reading the water pump status from the Blynk cloud\n\n```arduino\nint eeprom_addr = 0;                                  //eeprom address\nint sensorValue = 0;                                  // variable to store the value coming from the sensor\nint  pump_status = 0;\nint prev_pump_status = 0;\nfloat moist_percent = 0.00;\n```\n\n```arduino\nint eeprom_addr = 0;                                  //eeprom address\nint sensorValue = 0;                                  // variable to store the value coming from the sensor\nint  pump_status = 0;\nint prev_pump_status = 0;\nfloat moist_percent = 0.00;\n```\n\nUsed for bringing sad, happy, and normal facial expressions on LED matrix\n\n```arduino\nconst uint32_t HAPPY_LED[] = {\n   0x3fc48a95,\n   0x58019fd9,\n   0x5889871\n};\nconst uint32_t NORMAL_LED[] = {\n   0x3fc40298,\n   0xd98d8019,\n   0x5889871\n};\nconst uint32_t SAD_LED[] = {\n   0x3fc48a9d,\n   0xd8898018,\n   0x71889905\n};\n```\n\n```arduino\nconst uint32_t HAPPY_LED[] = {\n   0x3fc48a95,\n   0x58019fd9,\n   0x5889871\n};\nconst uint32_t NORMAL_LED[] = {\n   0x3fc40298,\n   0xd98d8019,\n   0x5889871\n};\nconst uint32_t SAD_LED[] = {\n   0x3fc48a9d,\n   0xd8898018,\n   0x71889905\n};\n```\n\nThis function works inside the blink timer_loop and it is used for continuously reading data from the Blynk cloud and utilizing EEPROM function to make sure the controller retains water pump status even after the power reset\n\n```arduino\nBLYNK_WRITE(V1){     \n        pump_status = param.asInt();\n        EEPROM.write(eeprom_addr,pump_status);\n        prev_pump_status = EEPROM.read(eeprom_addr);\n        Serial.println(prev_pump_status);\n        Serial.println(pump_status);\n}\n```\n\n```arduino\nBLYNK_WRITE(V1){     \n        pump_status = param.asInt();\n        EEPROM.write(eeprom_addr,pump_status);\n        prev_pump_status = EEPROM.read(eeprom_addr);\n        Serial.println(prev_pump_status);\n        Serial.println(pump_status);\n}\n```\n\nThis function is used to send water moist sensor data to Blynk cloud\n\n```arduino\nvoid sendSensor(){   \n      Blynk.virtualWrite(V0,moist_percent);\n}\n```\n\n```arduino\nvoid sendSensor(){   \n      Blynk.virtualWrite(V0,moist_percent);\n}\n```\n\nThis function initializes and sets the microcontroller peripherals, ADC, and LED matrix\n\n```arduino\nvoid init_renesas_MCU_IO(){\n pinMode(relay, OUTPUT);\n pinMode(moisture_sensor, INPUT);\n analogReadResolution(12);                           //change to 12-bit resolution\n matrix.begin();                                                  //initialise the led matrix*/\n}\n```\n\n```arduino\nvoid init_renesas_MCU_IO(){\n pinMode(relay, OUTPUT);\n pinMode(moisture_sensor, INPUT);\n analogReadResolution(12);                           //change to 12-bit resolution\n matrix.begin();                                                  //initialise the led matrix*/\n}\n```\n\nThis function is used for tracking the soil moisture level based on that it will bring back the facial expression on the LED matrix. For eg, it brings a sad face, if the moist percent is low, a Normal face, if the moist percent is normal and a Happy face, if the moist percent is High\n\n```arduino\nvoid track_soil_moisture(){\n  sensorValue = analogRead(moisture_sensor);\n  moist_percent = 100 - ((float)sensorValue / 4096.0) * 100;\n  \n   if(moist_percent >= 0 && moist_percent < 33.33){\n           Serial.println(\"DRY\");\n           matrix.loadFrame(SAD_LED);\n    }\n   else if(moist_percent >= 33.33 && moist_percent < 66.66){\n         Serial.println(\"MODERATE\");\n        matrix.loadFrame(NORMAL_LED);\n    }\n   else if(moist_percent >= 66.66 && moist_percent <= 100){\n        Serial.println(\"WET\");\n       matrix.loadFrame(HAPPY_LED);\n   }\n}\n```\n\n```arduino\nvoid track_soil_moisture(){\n  sensorValue = analogRead(moisture_sensor);\n  moist_percent = 100 - ((float)sensorValue / 4096.0) * 100;\n  \n   if(moist_percent >= 0 && moist_percent < 33.33){\n           Serial.println(\"DRY\");\n           matrix.loadFrame(SAD_LED);\n    }\n   else if(moist_percent >= 33.33 && moist_percent < 66.66){\n         Serial.println(\"MODERATE\");\n        matrix.loadFrame(NORMAL_LED);\n    }\n   else if(moist_percent >= 66.66 && moist_percent <= 100){\n        Serial.println(\"WET\");\n       matrix.loadFrame(HAPPY_LED);\n   }\n}\n```\n\nThis setup function is considered as the starting point of the program, used for setting up the Blynk server, serial monitor, blynk timer, and using EEPROM.read() to get the previous water pump status after power reset.\n\n```arduino\nvoid setup()\n{\n   Serial.begin(9600);\n   Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);\n   init_renesas_MCU_IO();\n   timer.setInterval(1000L,sendSensor);\n   prev_pump_status = EEPROM.read(eeprom_addr);\n   pump_status = prev_pump_status;\n }\n```\n\n```arduino\nvoid setup()\n{\n   Serial.begin(9600);\n   Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);\n   init_renesas_MCU_IO();\n   timer.setInterval(1000L,sendSensor);\n   prev_pump_status = EEPROM.read(eeprom_addr);\n   pump_status = prev_pump_status;\n }\n```\n\nThis loop function keeps on executing after the setup function executes its task\n\n```arduino\nvoid loop()\n{\n Blynk.run();\n timer.run();\n track_soil_moisture();\nif(pump_status == 0){\n    Serial.println(\"Water pump is off\");\n    digitalWrite(relay, LOW);\n  }\n  else if(pump_status == 1){\n    Serial.println(\"Water pump is on\");\n    digitalWrite(relay,HIGH);\n  }\n  delay(500);\n}\n```\n\n```arduino\nvoid loop()\n{\n Blynk.run();\n timer.run();\n track_soil_moisture();\nif(pump_status == 0){\n    Serial.println(\"Water pump is off\");\n    digitalWrite(relay, LOW);\n  }\n  else if(pump_status == 1){\n    Serial.println(\"Water pump is on\");\n    digitalWrite(relay,HIGH);\n  }\n  delay(500);\n}\n```\n\n# Visualizing the Plant's Facial Expression through Led Matrix:\n\nIf you follow the above code explanation, you can understand that we can bring the plant's expression on the LED matrix based on the soil moisture sensor reading. In the below images, you can find expressions like Happy, Normal, and Sad.\n\nAs I previously told you, these expressions appear based on the soil moisture level.  Let's take a scenario: if the soil is very wet, it brings out a laughing expression on the LED matrix.\n\nIf the soil has a tiny amount of moisture level, It brings out a Smile expression on the LED matrix, as you can find in the below image.\n\nIf the soil is very dry, it brings out a sad expression on the LED matrix, as shown in the below image.\n\nThat is it now we have successfully completed our automatic plant watering system mini project. All that is left is to keep it powered on and put the pump inside a water container and see how it works. Lets do exactly that next!\n\n# Automatic Plant Watering System Working Video\n\nThe below video was taken during the working stage of our project, where we were able to water the plants anytime and anywhere.\n\nIn the below image, you can see the customized Blynk app widget on the mobile phone for controlling the water pump motor using the ON-OFF button, and we can also monitor real-time soil moisture levels.\n\nSo finally we can make our remote plant watering system, where we can control the water pump and get to know about the plant’s soil from anywhere around the world. What we just needed was a mobile phone with an active internet connection.\n\nHere is the link to our GitHub repo, where you'll find the source code for this project.\n\n# Projects Similar to Automatic Plant Watering System.\n\nPreviously we have built a lot of electronics projects, including a few related to automatic plant watering systems. I have listed all similar projects below, each project is explained in detail with its circuit diagram and code so that you can build it on your own.\n\nArduino Smart Irrigation System Using ESP32 and Blynk App\n\nIn this project, we'll explore an IoT-based irrigation system using the ESP32 board and Blynk app. It's a project based on the Internet of Things (IoT), the smart irrigation system offers numerous possibilities to automate the entire irrigation process. Here, we're creating a plot-based smart irrigation system using the ESP32 Controller, a soil moisture sensor, a water level sensor, a relay module and DHT22 Sensor.\n\nAutomatic Irrigation System using an Arduino Uno\n\nIn this project, we are making an Automatic Irrigation System with an Arduino Uno which will irrigate your plants automatically and keep them healthy even when you are out of the town for weeks or months. In this project, a Moisture sensor will be used to maintain the optimum level of moisture for your plants.\n\nIoT based Smart Irrigation System using Soil Moisture Sensor and ESP8266 NodeMCU\n\nThis Smart irrigation System has wide scope to automate the complete irrigation system. Here we are building a IoT based Irrigation System using ESP8266 NodeMCU Module and DHT11 Sensor. It will not only automatically irrigate the water based on the moisture level in the soil but also send the Data to ThingSpeak Server to keep track of the land condition.\n\nIoT based Smart Agriculture Monitoring System\n\nIn this project, we are going to build a Smart Farming System using IoT. The objective of this project is to offer assistance to farmers in getting Live Data (Temperature, Humidity, Soil Moisture, Soil Temperature) for efficient environment monitoring which will enable them to increase their overall yield and quality of products.\n\n# Complete Project Code\n\n```arduino\n/*************************************************************\n Automatic plant watering system Arduino Code\nMore details : https://circuitdigest.com/microcontroller-projects/build-a-simple-plant…\n************************************************************/\n/* Comment this out to disable prints and save space */\n//#define BLYNK_PRINT Serial\n/* Fill in information from Blynk Device Info here */\n#define BLYNK_TEMPLATE_ID \"xxx\"\n#define BLYNK_TEMPLATE_NAME \"IOT WATERING APP\"\n#define BLYNK_AUTH_TOKEN \"xxxx-lDh\"\n#include <SPI.h>\n#include <WiFiS3.h>\n#include <BlynkSimpleWifi.h>\n#include \"Arduino_LED_Matrix.h\"\n#include <EEPROM.h>\n#define moisture_sensor A0\n#define relay 7\nBlynkTimer timer;\nArduinoLEDMatrix matrix;  //Create an led matrix object\n// Your WiFi credentials.\n// Set password to \"\" for open networks.\nchar ssid[] = \"Semicon Media\";\nchar pass[] = \"xxxxx\";\nint eeprom_addr = 0;  //eeprom address\nint sensorValue = 0;  // variable to store the value coming from the sensor\nint prev_pump_status = 0;\nint pump_status = 0;\nfloat moist_percent = 0.00;\n \nconst uint32_t HAPPY_LED[] = {\n   0x3fc48a95,\n   0x58019fd9,\n   0x5889871\n};\nconst uint32_t NORMAL_LED[] = {\n   0x3fc40298,\n   0xd98d8019,\n   0x5889871\n};\nconst uint32_t SAD_LED[] = {\n   0x3fc48a9d,\n   0xd8898018,\n   0x71889905\n};\n\nBLYNK_WRITE(V1){     //read data from Blynk cloud\n pump_status = param.asInt();\n EEPROM.write(eeprom_addr,pump_status);\n prev_pump_status = EEPROM.read(eeprom_addr);\n Serial.println(prev_pump_status);\n Serial.println(pump_status);\n}\nvoid sendSensor(){   //send data to Blynk cloud\n Blynk.virtualWrite(V0,moist_percent);\n}\nvoid init_renesas_MCU_IO(){\n pinMode(relay, OUTPUT);\n pinMode(moisture_sensor, INPUT);\n analogReadResolution(12); //change to 12-bit resolution\n matrix.begin(); //initialise the led matrix*/\n}\nvoid track_soil_moisture(){\n \n // read the value from the sensor:\n  sensorValue = analogRead(moisture_sensor);\n  moist_percent = 100 - ((float)sensorValue / 4096.0) * 100;\n  \n if(moist_percent >= 0 && moist_percent < 33.33){\n   Serial.println(\"DRY\");\n   matrix.loadFrame(SAD_LED);\n }\n else if(moist_percent >= 33.33 && moist_percent < 66.66){\n   Serial.println(\"MODERATE\");\n   matrix.loadFrame(NORMAL_LED);\n }\n else if(moist_percent >= 66.66 && moist_percent <= 100){\n   Serial.println(\"WET\");\n   matrix.loadFrame(HAPPY_LED);\n }\n}\nvoid setup()\n{\n // Debug console\n Serial.begin(9600);\n Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);\n init_renesas_MCU_IO();\n\n timer.setInterval(1000L,sendSensor);\n prev_pump_status = EEPROM.read(eeprom_addr);\n pump_status = prev_pump_status;\n}\nvoid loop()\n{\n Blynk.run();\n timer.run();\n \n track_soil_moisture();\n if(pump_status == 0){\n   Serial.println(\"Water pump is off\");\n   digitalWrite(relay, LOW);\n }\n else if(pump_status == 1){\n   Serial.println(\"Water pump is on\");\n   digitalWrite(relay,HIGH);\n }\n delay(500);\n}\n```\n\n```arduino\n/*************************************************************\n Automatic plant watering system Arduino Code\nMore details : https://circuitdigest.com/microcontroller-projects/build-a-simple-plant…\n************************************************************/\n/* Comment this out to disable prints and save space */\n//#define BLYNK_PRINT Serial\n/* Fill in information from Blynk Device Info here */\n#define BLYNK_TEMPLATE_ID \"xxx\"\n#define BLYNK_TEMPLATE_NAME \"IOT WATERING APP\"\n#define BLYNK_AUTH_TOKEN \"xxxx-lDh\"\n#include <SPI.h>\n#include <WiFiS3.h>\n#include <BlynkSimpleWifi.h>\n#include \"Arduino_LED_Matrix.h\"\n#include <EEPROM.h>\n#define moisture_sensor A0\n#define relay 7\nBlynkTimer timer;\nArduinoLEDMatrix matrix;  //Create an led matrix object\n// Your WiFi credentials.\n// Set password to \"\" for open networks.\nchar ssid[] = \"Semicon Media\";\nchar pass[] = \"xxxxx\";\nint eeprom_addr = 0;  //eeprom address\nint sensorValue = 0;  // variable to store the value coming from the sensor\nint prev_pump_status = 0;\nint pump_status = 0;\nfloat moist_percent = 0.00;\n \nconst uint32_t HAPPY_LED[] = {\n   0x3fc48a95,\n   0x58019fd9,\n   0x5889871\n};\nconst uint32_t NORMAL_LED[] = {\n   0x3fc40298,\n   0xd98d8019,\n   0x5889871\n};\nconst uint32_t SAD_LED[] = {\n   0x3fc48a9d,\n   0xd8898018,\n   0x71889905\n};\n\nBLYNK_WRITE(V1){     //read data from Blynk cloud\n pump_status = param.asInt();\n EEPROM.write(eeprom_addr,pump_status);\n prev_pump_status = EEPROM.read(eeprom_addr);\n Serial.println(prev_pump_status);\n Serial.println(pump_status);\n}\nvoid sendSensor(){   //send data to Blynk cloud\n Blynk.virtualWrite(V0,moist_percent);\n}\nvoid init_renesas_MCU_IO(){\n pinMode(relay, OUTPUT);\n pinMode(moisture_sensor, INPUT);\n analogReadResolution(12); //change to 12-bit resolution\n matrix.begin(); //initialise the led matrix*/\n}\nvoid track_soil_moisture(){\n \n // read the value from the sensor:\n  sensorValue = analogRead(moisture_sensor);\n  moist_percent = 100 - ((float)sensorValue / 4096.0) * 100;\n  \n if(moist_percent >= 0 && moist_percent < 33.33){\n   Serial.println(\"DRY\");\n   matrix.loadFrame(SAD_LED);\n }\n else if(moist_percent >= 33.33 && moist_percent < 66.66){\n   Serial.println(\"MODERATE\");\n   matrix.loadFrame(NORMAL_LED);\n }\n else if(moist_percent >= 66.66 && moist_percent <= 100){\n   Serial.println(\"WET\");\n   matrix.loadFrame(HAPPY_LED);\n }\n}\nvoid setup()\n{\n // Debug console\n Serial.begin(9600);\n Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);\n init_renesas_MCU_IO();\n\n timer.setInterval(1000L,sendSensor);\n prev_pump_status = EEPROM.read(eeprom_addr);\n pump_status = prev_pump_status;\n}\nvoid loop()\n{\n Blynk.run();\n timer.run();\n \n track_soil_moisture();\n if(pump_status == 0){\n   Serial.println(\"Water pump is off\");\n   digitalWrite(relay, LOW);\n }\n else if(pump_status == 1){\n   Serial.println(\"Water pump is on\");\n   digitalWrite(relay,HIGH);\n }\n delay(500);\n}\n```\n\n# Start a Discussion on:\n\n# Add New Comment\n\nLog in or register to post comments"}
{"title":"Line Follower Robot using Arduino UNO: How to Build (Step-by-Step Guide)","content":"This line follower robot with Arduino project example illustrates professional Arduino robotics project ideas through learning by doing. Our complete block diagram of the line follower robot with  Arduino UNO, the approach begins with thoroughly explaining the hardware connections and then explaining the logic behind the software. The complete Arduino line follower robot code provided here has been tested to work reliably with the listed components. This line follower robot Arduino code project is a great starting point for learning more advanced robots. You can increase the complexity by easily converting it into a mazesolving robot, which not just follows a line but also solves a maze to find the exit autonomously.\n\nTo build this project, you will need some basic knowledge of Arduino. The estimated build time for this project is 2-3 hours with a beginner or intermediate skill level, and the total cost for this project will be between $25 - $30. This whole comprehensive line follower robot using Arduino project tutorial covers everything from a basic block diagram of a line follower robot using Arduino, to advanced Arduino line follower robot code optimisation. It provides a professional robot line follower Arduino project tutorial.\n\n# Line Follower Robot using Arduino UNO - Quick Overview\n\nBuild Time: 2-3 hours | Cost: $25-30 | Difficulty: Beginner-Intermediate\n\nWhat You'll Learn: IR sensor interfacing, Motor driver control, Arduino programming, Line detection logic\n\nApplications: Autonomous navigation, Robotics competitions, Educational projects, Maze-solving robots\n\n# Components Required for Arduino Line Follower Robot\n\nBuilding a dependable line follower robot using Arduino project requires a good selection of reliable components. The line follower robot using Arduino is built with standard, commonly available components that work together; the block diagram of the line follower robot using Arduino shows how each component works together for the robot.\n\nArduino Uno - 1Nos\n\nArduino Uno - 1Nos\n\nL293D motor driver- 1Nos\n\nL293D motor driver- 1Nos\n\nIR sensor module -2 Nos\n\nIR sensor module -2 Nos\n\n7.4 or 9V battery -1 Nos\n\n7.4 or 9V battery -1 Nos\n\nBO motor - 2 Nos\n\nBO motor - 2 Nos\n\nMotor wheel - 2 Nos\n\nMotor wheel - 2 Nos\n\nCastor wheel - 1 Nos\n\nCastor wheel - 1 Nos\n\nHobby robot chassis - 1 Nos\n\nHobby robot chassis - 1 Nos\n\nWires\n\nWires\n\nScrews\n\nScrews\n\nApart from the above components, you will also need a few tools like a soldering iron and solder, wire stripper, screwdriver set, hot glue gun, etc. Also, it is recommended to have a few additional components like a battery voltage monitor, a power switch, and an extra IR sensor module, just in case you want to troubleshoot the robot later.\n\n# Working Principle and Block Diagram of Line Follower Robot Using Arduino\n\nAs stated earlier, a line follower robot (LFR) follows a line, and to follow a line, the robot must detect the line first. Now the question is how to implement the line sensing mechanism in an LFR. We all know that the reflection of light on the white surface is maximum and minimum on the black surface because the black surface absorbs the maximum amount of light. So, we are going to use this property of light to detect the line. To detect light, either an LDR (light-dependent resistor) or an IR sensor can be used.\n\nFor this project, we are going with the IR sensor because of its higher accuracy. To detect the line, we place two IR sensors, one on the left and the other on the right side of the robot, as marked in the diagram below. We then place the robot on the line such that the line lies in the middle of both sensors. We have covered a detailed Arduino IR sensor tutorial, which you can check to learn more about the working of IR sensors with Arduino Uno.\n\nThis line follower robot using Arduino</strong> project tutorial covers everything from a basic block diagram of a line follower robot using Arduino, to advanced Arduino line follower robot code optimisation. Whether it is your first line follower robot Arduino code project, or simply an enhancement of an existing Arduino line follower robot. It provides a professional robot line follower Arduino project tutorial.\n\nInfrared sensors consist of two elements, a transmitter and a receiver. The transmitter is basically an IR LED, which produces the signal, and the IR receiver is a photodiode, which senses the signal produced by the transmitter. The IR sensors emit the infrared light on an object; the light hitting the black part gets absorbed, thus giving a low output, but the light hitting the white part reflects to the transmitter, which is then detected by the infrared receiver, thereby giving an analog output. Using the stated principle, we control the movement of the robot by driving the wheels attached to the motors, which are controlled by a microcontroller.\n\n# How Arduino Line Follower Robot Code Controls Navigation\n\nA typical line follower robot has two sets of motors, let's call them the left motor and the right motor. Both motors rotate on the basis of the signal received from the left and the right sensors, respectively. The robot needs to perform 4 sets of motion, which include moving forward, turning left, turning right and coming to a halt. The descriptions of the cases are given below.\n\n# Moving Forward:\n\nIn this case, when both the sensors are on a white surface and the line is between the two sensors, the robot should move forward, i.e., both the motors should rotate such that the robot moves in forward direction (actually both the motors should rotate in the opposite direction due to the placement of motors in our setup. But for the sake of simplicity, we will call the motors rotating forward.)\n\n# Turning LEFT:\n\nIn this case, the left sensor is on top of the dark line, whereas the right sensor is on the white part; hence, the left sensor detects the black line and gives a signal to the microcontroller. Since, signal comes from the left sensor, the robot should turn to the left. Therefore, the left motor rotates backwards and the right motor rotates in the forward direction. Thus, the robot turns towards the left side.\n\n# Turning RIGHT:\n\nThis case is similar to the left case, but in this situation, only the right sensor detects the line, which means that the robot should turn in the right direction. To turn the robot towards the right direction, the left motor rotates forward and the right motor rotates backwards, and as a result, the robot turns towards the right direction.\n\n# Stopping:\n\nIn this case, both sensors are on top of the line and they can detect the black line simultaneously, the microcontroller is fed to consider this situation as a process to halt. Hence, both motors are stopped, which causes the robot to stop moving.\n\n# Circuit Diagram for Line Follower Robot Using Arduino\n\nThe circuit consists mainly of four parts: Two IR sensors, one motor drive, two motors, one Arduino, a battery and a few connecting wires. The sensor senses the IR light reflected from the surface and feeds the output to the onboard op-amp comparator. When the sensor is situated over the white background, the light emitted by the sensor is reflected by the white ground and is received by the receiver. But when the sensor is above the black background, the light from the source is not reflected to the sensor. The sensor senses the intensity of reflected light to give an output.\n\nThe sensor’s output is fed to the microcontroller, which gives commands to the motor driver to drive the motor accordingly. In our project, the Arduino Uno is programmed to make the robot move forward, turn right or turn left and stop according to the input coming from the sensor. The output of the Arduino is fed to the motor driver.\n\n# Why do We Require a Motor Driver?\n\nThe reason to use a motor driver here is that the output signal of an Arduino is not sufficient to drive the motor. Furthermore, we need to rotate the motors in both directions; therefore, we use a motor driver to drive the motor as required and also the motor driver can supply sufficient current to drive the motor. Here, we are using a L293D motor driver, which is a dual H-bridge motor driver and is sufficient for our 2 motors.\n\nThe L293D has 16 pins; the pinout of L293D is shown in the diagram below.\n\n# Connecting Motor Driver to Arduino UNO\n\nPINs 1 and 9 are the enable pins; we connect these two pins to a 5V input to enable the motor.\n\nPINs 1A, 2A, 3A, and 4A are the control pins.\n\nFor eg, the motor will turn to the right if the pin 1A goes low and 2A goes high, and the motor will turn to the left if 1A goes low and 2A goes high. So, we connect these pins to the output pins of the decoder.\n\nPins 1Y, 2Y, 3Y, and 4Y are the motor connection pins.\n\nNote: Vcc2 is the motor driving voltage pin, and is only used if you are using a high-voltage motor.\n\nPin connection of Arduino Uno with the Motor driver is as follows:\n\nHere, we are using a 7.4 Li-ion battery to power the whole circuit. You can use any battery type from 6-12 volts. To move the robot, we need to use motors with low RPM but high enough torque to carry the weight of the robot. So, I chose two 60 RPM 6V battery-operated, geared motors for this robot.\n\n# L298N Motor Driver for Line Following Robot\n\nWhen it comes to selecting the motor driver for a line-following robot, we have two different options. One is the L293D module, which we have discussed so far, and the other is the L298N motor driver module. At the time of building this project, the L293D module was the most popular option, but recently the cost of the L298N motor driver module has greatly reduced, so we are updating this project to use the L298N motor driver module. The circuit diagram to build a line following robot using the L298N motor driver module is shown below\n\nTo make connections easy, we have also marked the parts and labelled the wires. You can simply follow the above schematics and make the connections. Now that you understand the circuit for the line following robot, let's start to build the robot.\n\n# L293D vs L298N Motor Driver for Arduino Line Follower Robot\n\nFeature\n\nL293D\n\nL298N\n\nCurrent Capacity\n\n0.6A per channel\n\n2A per channel\n\nVoltage Range\n\n4.5V - 36V\n\n5V - 35V\n\nHeat Dissipation\n\nModerate\n\nBetter (heat sink)\n\nCost\n\nLower ($2-3)\n\nHigher ($3-5)\n\nBest For\n\nSmall BO motors\n\nLarger motors\n\n# Assembling the Line Follower Robot\n\nOnce we have understood the connection of all the components, we can start assembling our LFR. I have explained the step-by-step assembly procedure of the Robot in the video provided at the bottom of the page.\n\nTo make this robot, first, we need a robot body; here, I am using a homemade chassis. You can either use a readymade chassis or build one yourself. Now, place the BO motors on the chassis with the help of some hot glue as shown in the image below.\n\nThe next step is to place the motor driver on the chassis and connect the motor wires to the output of the motor driver, and bend the IR LED and sensor as shown in the image.\n\nThen place the sensors on the downside of the robot, adjust the sensors according to the track width and robot width. Remember that one sensor is for left side detection and another is for right side detection.\n\nNow, place the Arduino Uno using glue and connect the sensor output pins to digital pins 2 and 4 of the Arduino.\n\nConnect the VCC pins to 5 volts and the ground pins to ground. Now, connect the enable pins of the motor driver to pins 5 and 8 of Arduino and connect the motor driver input pins to pins 6, 7, 9 and 10 of Arduino, respectively. Finally, connect the battery to the circuit and place the battery on the chassis. Here, I have connected everything with jumper wires. To make a permanent setup, you can directly solder everything together. Then turn the board upside down and with the help of a hot glue gun, attach the castor wheels as shown in the image below.\n\nFinally, add the wheels. For extra safety, I have added a plastic sheet as a bumper, too.\n\n# Line Follower Robot Arduino Code\n\nThe line follower robot Arduino code is designed for beginners while maintaining professional functionality. This Arduino line follower robot code implements all four essential movements with clear, commented functions. The programming part of the line follower robot is very simple, and we require only basic Arduino functions. The complete program for this project can be found at the bottom of this page. The explanation of this program is as follows:\n\nThe first step is to define every Arduino pin that we are using. I started with the motoring of the driver pins and sensor pins. Here, I have commented on each line of code for your easy understanding.\n\n```arduino\n#define enA 5 //Enable1 L293 Pin enA\n #define in1 6 //Motor1  L293 Pin in1\n #define in2 7 //Motor1  L293 Pin in1\n #define in3 9 //Motor2  L293Pin in1\n #define in4 10 //Motor2  L293 Pin in1\n #define enB 8 //Enable2 L298 Pin enB\n #define R_S 4 // Right sensor\n #define L_S 2 // Left sensor\n```\n\n```arduino\n#define enA 5 //Enable1 L293 Pin enA\n #define in1 6 //Motor1  L293 Pin in1\n #define in2 7 //Motor1  L293 Pin in1\n #define in3 9 //Motor2  L293Pin in1\n #define in4 10 //Motor2  L293 Pin in1\n #define enB 8 //Enable2 L298 Pin enB\n #define R_S 4 // Right sensor\n #define L_S 2 // Left sensor\n```\n\nIn the loop section, declare the pin modes of each pin. Here, we need to read the output of the IR sensors; hence, I have defined those pins as input. The motor needs to be driven by the Arduino, thus defining the motor driver pins as outputs. Finally, I pulled the enable pin too high.\n\n```arduino\npinMode(R_S, INPUT);\npinMode(L_S, INPUT);\npinMode(enA, OUTPUT);\npinMode(in1, OUTPUT);\npinMode(in2, OUTPUT);\npinMode(in3, OUTPUT);\npinMode(in4, OUTPUT);\npinMode(enB, OUTPUT);\ndigitalWrite(enA, HIGH);\ndigitalWrite(enB, HIGH);\n```\n\n```arduino\npinMode(R_S, INPUT);\npinMode(L_S, INPUT);\npinMode(enA, OUTPUT);\npinMode(in1, OUTPUT);\npinMode(in2, OUTPUT);\npinMode(in3, OUTPUT);\npinMode(in4, OUTPUT);\npinMode(enB, OUTPUT);\ndigitalWrite(enA, HIGH);\ndigitalWrite(enB, HIGH);\n```\n\nIn the loop section, we first read the values of the IR sensors and then use an ‘if condition’ to control the movement of the motor as per our requirements. The four movement conditions are explained below.\n\n# Moving forward:\n\n```arduino\nif((digitalRead(R_S) == 0)&&(digitalRead(L_S) == 0)){forward();}\n```\n\n```arduino\nif((digitalRead(R_S) == 0)&&(digitalRead(L_S) == 0)){forward();}\n```\n\nIn this case, if Right Sensor and Left Sensor are on top of white colour, then the robot should move in the forward direction, so we call the forward function.\n\n(Note: here 0 means the output of the IR sensor is high as the sensor is on a white surface)\n\n# Turning towards the Right Side:\n\n```arduino\nif((digitalRead(R_S) == 1)&&(digitalRead(L_S) == 0)){turnRight();}\n```\n\n```arduino\nif((digitalRead(R_S) == 1)&&(digitalRead(L_S) == 0)){turnRight();}\n```\n\nIf the Right Sensor is detecting Black and the Left Sensor is not detecting any black line, then it will call the Right function, initiating the protocol for making a right turn by calling the turnRight function.\n\n# Turning towards the Left side:\n\n```arduino\nif((digitalRead(R_S) == 0)&&(digitalRead(L_S) == 1)){turnLeft();}\n```\n\n```arduino\nif((digitalRead(R_S) == 0)&&(digitalRead(L_S) == 1)){turnLeft();}\n```\n\nIf the Right Sensor is over white and the Left Sensor is detecting Black, then it will call the turnLeft function. It will initiate the steps for turning the robot to the left.\n\n# Stopping the Robot:\n\n```arduino\nif((digitalRead(R_S) == 1)&&(digitalRead(L_S) == 1)){Stop();}\n```\n\n```arduino\nif((digitalRead(R_S) == 1)&&(digitalRead(L_S) == 1)){Stop();}\n```\n\nIf the Right Sensor and Left Sensor are on the Black colour, then it will call the Stop function. In this case, the robot will come to a complete halt.\n\nWe have defined the 4 functions of the robot as Forward, turnLeft, turnRight and Stop. The code to perform these functions is given below:\n\n# Forward function:\n\n```arduino\nvoid forward(){ \ndigitalWrite(in1, HIGH); \n digitalWrite(in2, LOW); \n digitalWrite(in3, LOW); \n digitalWrite(in4, HIGH);\n }\n```\n\n```arduino\nvoid forward(){ \ndigitalWrite(in1, HIGH); \n digitalWrite(in2, LOW); \n digitalWrite(in3, LOW); \n digitalWrite(in4, HIGH);\n }\n```\n\nThis means we are pulling too high the inputs 1 and 4 of the motor driver, as a result, both motors will move forward  same As this I made other functions\n\n# Turn Right Function:\n\n```arduino\nvoid turnRight(){\ndigitalWrite(in1, LOW);  //Right Motor forword Pin\ndigitalWrite(in2, HIGH); //Right Motor backword Pin \ndigitalWrite(in3, LOW);  //Left Motor backword Pin\ndigitalWrite(in4, HIGH); //Left Motor forword Pin\n }\n```\n\n```arduino\nvoid turnRight(){\ndigitalWrite(in1, LOW);  //Right Motor forword Pin\ndigitalWrite(in2, HIGH); //Right Motor backword Pin \ndigitalWrite(in3, LOW);  //Left Motor backword Pin\ndigitalWrite(in4, HIGH); //Left Motor forword Pin\n }\n```\n\n# Turn Left Function:\n\n```arduino\nvoid turnLeft(){\n digitalWrite(in1, HIGH); //Right Motor forword Pin\n digitalWrite(in2, LOW);  //Right Motor backword Pin\n digitalWrite(in3, HIGH); //Left Motor backword Pin\n digitalWrite(in4, LOW);  //Left Motor forword Pin\n }\n```\n\n```arduino\nvoid turnLeft(){\n digitalWrite(in1, HIGH); //Right Motor forword Pin\n digitalWrite(in2, LOW);  //Right Motor backword Pin\n digitalWrite(in3, HIGH); //Left Motor backword Pin\n digitalWrite(in4, LOW);  //Left Motor forword Pin\n }\n```\n\n# Stop Function:\n\n```arduino\nvoid Stop(){\n digitalWrite(in1, LOW); //Right Motor forword Pin \ndigitalWrite(in2, LOW); //Right Motor backword Pin\ndigitalWrite(in3, LOW); //Left Motor backword Pin \ndigitalWrite(in4, LOW); //Left Motor forward Pin\n```\n\n```arduino\nvoid Stop(){\n digitalWrite(in1, LOW); //Right Motor forword Pin \ndigitalWrite(in2, LOW); //Right Motor backword Pin\ndigitalWrite(in3, LOW); //Left Motor backword Pin \ndigitalWrite(in4, LOW); //Left Motor forward Pin\n```\n\nSo, that’s all about coding. Now we need to upload the code to the Arduino, and to do so, connect your Arduino to the computer using a USB cable and upload this code using the Arduino IDE.\n\n# Testing and Calibrating the Line Follower Robot\n\nWe have assembled the robot and uploaded the code, so now it's time to see it in action, and if it is unable to follow the line, then we’ll have to calibrate the robot. For the first place robot on a black surface ( both sensors should be on top of the black surface), then adjust the variable resistor of the IR Module until the output LED of the IR Module turns off. Next, place the robot on a white surface and check whether the LED is turning on; if not, then just adjust the variable resistor. Repeat the process once again to be sure that the output LED is operating as per the requirement.\n\nNow, since we have calibrated the robot, all we need to do is place the robot on top of the black line and see it in action. The GIF below shows the working of our line follower robot. As you can see the the robot can follow the line without any problem.\n\n# Troubleshooting Your Line Follower Robot\n\nEven with careful assembly and coding, you might encounter some common issues with your line follower robot. Let's explore these problems and their solutions to help you get your robot running perfectly.\n\nIf your robot isn't following the line properly, first check your IR sensor calibration. Place your sensors over a white surface and adjust the potentiometer on the IR sensor module until the LED just turns off. Then test it over your black line - the LED should light up clearly. This sweet spot in calibration is crucial for reliable line detection.\n\nWhen your robot moves but seems to ignore the line, check your sensor heights. If they're too far from the ground (more than 1cm), they won't detect the line reliably. Similarly, if they're too close (less than 2mm), they might get false readings. The ideal height is about 5mm from the surface.\n\nBattery voltage significantly affects robot behaviour. As batteries drain, motor speed and sensor sensitivity can change. Consider adding a voltage monitor or using a regulated power supply for consistent performance. Fresh batteries should measure between 7.4V to 9V for optimal performance.\n\n# Arduino Line Follower Robot Troubleshooting Guide\n\nProblem\n\nPossible Cause\n\nSolution\n\n# Further Modifications and Upgrades\n\nOnce your basic line follower is working, there are several exciting upgrades you can implement to enhance its capabilities:\n\n» PID Control Implementation: Add PID (Proportional-Integral-Derivative) control to your code for smoother line following. This advanced control method helps your robot make more precise adjustments and handle curves better. It replaces the simple on-off control with proportional responses to line position.\n\n» Speed Control System: Add a potentiometer or switches to adjust the speed of the DC motor using Arduino. This is particularly useful when testing your robot on different courses. You can implement multiple speed modes for straight lines versus turns.\n\n» LCD Display Integration: Add a 16x2 LCD with Arduino display to show sensor readings, motor speeds, and battery voltage in real-time. This helps in debugging and makes your robot more interactive. You can display different parameters and even create a menu system for adjusting settings.\n\n» Additional Sensors: Consider adding a third IR sensor in the middle or ultrasonic sensors for obstacle detection. More sensors give your robot better awareness and allow for more complex behaviours like obstacle avoidance while line following.\n\nThe complete making of the line follower robot can also be found in the video linked at the bottom of this page. If you have any questions, leave them in the comment section.\n\n# Technical Summary and GitHub Repository\n\nTechnical descriptions listed under this section are presented to shed light on hardware elements, circuit arrangements, and flow of programming--thus helping its makers and developers get an insight into the way the entire system works.  Also, source codes, libraries, and documentation can be downloaded using the GitHub link so that it's easier to set up and customise.\n\n# Frequently Asked Questions (FAQ) About Line Follower Robots\n\n⇥ What is a line following robot, and how does it work? \nA line-following robot is an autonomous robot designed to follow a visible line drawn on the ground. It uses infrared (IR) sensors to detect the line and follow it. When IR light hits a white surface, it reflects to the sensor, but when it hits a black line, it absorbs the light. The robot uses this information to adjust its motors and follow the line\n\n⇥ What components do I need to build a basic line follower robot? \nThe bare minimum components to build a line follower robot are a dev board like Arduino UNO (or equivalent), two IR sensors, an L293D motor driver, two DC gear motors (60-100 RPM), wheels, a chassis, a battery (7.4V or 9V), and connecting wires. The total cost is typically around $25-30, making it an affordable project for beginners.\n\n⇥ Which IR sensor is best for a line following robot? \nThe TCRT5000 IR sensor module is highly recommended for line following robots due to its good detection range (2-30cm), built-in potentiometer for sensitivity adjustment, and stable performance. It's also widely available and compatible with Arduino's 5V operating voltage. But in this tutorial, we have used the generic IR sensor module because it is more cost-effective.\n\n⇥ Why do we need a motor driver in a line follower robot? \nA motor driver is essential because Arduino's output pins can't provide enough current to drive DC motors directly. The L293D motor driver acts as an intermediary, providing the necessary current and voltage control for the motors while protecting the Arduino from potential damage.\n\n⇥ How can I improve my line follower robot's performance? \nYou improve your line-following robot by implementing PID control for smoother movement, adding more sensors for better line detection, optimising the sensor height (ideally 5-10mm from the ground), and ensuring proper battery voltage.\n\n⇥ What are the common problems with line follower robots and their solutions? \nCommon issues include inconsistent line following (solution: adjust sensor calibration), jerky movements (solution: tune motor speeds or implement PID control), losing the line on sharp turns (solution: optimise sensor positioning or add more sensors), and erratic behaviour (solution: check battery voltage and connections). But if you are facing more problems than this, then you can write them in the comment section below, and we will help you out.\n\n⇥ Can a line follower robot detect different colored lines? \nWhile basic IR sensors work best with black lines on white surfaces, you can modify your robot to detect different colored lines by using colour sensors (TCS230) instead of IR sensors. However, this increases complexity and cost and is not recommended.\n\n⇥ What programming skills do I need to build a line follower robot? \nBasic knowledge of Arduino programming (C++) is sufficient. You should understand digital I/O, variables, if-else statements, and basic functions. Our tutorial includes fully commented code that's easy to understand and modify. Also, if you are looking to learn programming or robotics, this might be the best project to start your journey with.\n\n# Projects Similar to Line Follower Robot\n\nNow that you have learned how to build a line following robot using Arduino. Here are other similar Arduino Project ideas that you can try next. All these projects are built by us here in CircuitDigest and use more or less the same components that are used to build the line following Robot.\n\nObstacle Avoidance Robot using Arduino and Ultrasonic Sensor\n\nObstacle Avoiding Robot is an intelligent device that can automatically sense the obstacles in front of it and avoid them by turning itself in another direction. This design allows the robot to navigate in an unknown environment by avoiding collisions, which is a primary requirement for any autonomous mobile robot.\n\nBluetooth-Controlled Car\n\nThis robot car can be controlled wirelessly with Bluetooth and an Android app, and other than that, we have placed RGB Neopixel LEDs on the front, back, and bottom of the robot to make it look cool. We will also build a custom Android app with the MIT App Inventor so that we can send commands directly via Bluetooth.\n\nFire Fighting Robot using Arduino\n\nIn this project, we will learn how to build a simple robot using Arduino that could move towards the fire and pump out water around it to put down the fire. It is a very simple robot that would teach us the underlying concept of robotics; you would be able to build more sophisticated robots once you understand the following basics.\n\nGesture Controlled Robot Using Arduino\n\nLet's build a cool hand gesture-controlled robot that'll amaze your friends and family—it's like magic! This step-by-step guide helps you build a hand gesture-controlled robot using simple components like Arduino, MPU6050 Accelerometer, nRF24L01 Transmitter-Receiver Pair, and L293D motor driver module. We'll split the robot into two parts: the Transmitter and the Receiver.\n\nLight Following Robot using Arduino UNO\n\nToday, we are building a simple Arduino-based project: a light-following robot. This project is perfect for beginners, and we'll use LDR sensor modules to detect light and an MX1508 motor driver module for control.\n\n# Complete Project Code\n\n```arduino\n// Arduino Line Follower Robot Code\n//More Information: https://circuitdigest.com/microcontroller-projects/arduino-uno-line-follower-robot \n#define enA 5//Enable1 L293 Pin enA \n#define in1 6 //Motor1  L293 Pin in1 \n#define in2 7 //Motor1  L293 Pin in1 \n#define in3 9 //Motor2  L293 Pin in1 \n#define in4 10 //Motor2  L293 Pin in1 \n#define enB 8 //Enable2 L293 Pin enB \n#define R_S 4//ir sensor Right\n#define L_S 2 //ir sensor Left\nvoid setup(){ \npinMode(R_S, INPUT); \npinMode(L_S, INPUT); \npinMode(enA, OUTPUT); \npinMode(in1, OUTPUT); \npinMode(in2, OUTPUT); \npinMode(in3, OUTPUT); \npinMode(in4, OUTPUT); \npinMode(enB, OUTPUT);\ndigitalWrite(enA, HIGH); \ndigitalWrite(enB, HIGH); \ndelay(1000);\n}\nvoid loop(){  \nif((digitalRead(R_S) == 0)&&(digitalRead(L_S) == 0)){forward();}   //if Right Sensor and Left Sensor are at White color then it will call forword function\nif((digitalRead(R_S) == 1)&&(digitalRead(L_S) == 0)){turnRight();} //if Right Sensor is Black and Left Sensor is White then it will call turn Right function  \nif((digitalRead(R_S) == 0)&&(digitalRead(L_S) == 1)){turnLeft();}  //if Right Sensor is White and Left Sensor is Black then it will call turn Left function\nif((digitalRead(R_S) == 1)&&(digitalRead(L_S) == 1)){Stop();} //if Right Sensor and Left Sensor are at Black color then it will call Stop function\n}\nvoid forward(){  //forword\ndigitalWrite(in1, HIGH); //Right Motor forword Pin \ndigitalWrite(in2, LOW);  //Right Motor backword Pin \ndigitalWrite(in3, LOW);  //Left Motor backword Pin \ndigitalWrite(in4, HIGH); //Left Motor forword Pin \n}\nvoid turnRight(){ //turnRight\ndigitalWrite(in1, LOW);  //Right Motor forword Pin \ndigitalWrite(in2, HIGH); //Right Motor backword Pin  \ndigitalWrite(in3, LOW);  //Left Motor backword Pin \n digitalWrite(in4, HIGH); //Left Motor forword Pin \n}\nvoid turnLeft(){ //turnLeft\ndigitalWrite(in1, HIGH); //Right Motor forword Pin \ndigitalWrite(in2, LOW);  //Right Motor backword Pin \ndigitalWrite(in3, HIGH); //Left Motor backword Pin \ndigitalWrite(in4, LOW);  //Left Motor forword Pin \n}\nvoid Stop(){ //stop\ndigitalWrite(in1, LOW); //Right Motor forword Pin \ndigitalWrite(in2, LOW); //Right Motor backword Pin \ndigitalWrite(in3, LOW); //Left Motor backword Pin \ndigitalWrite(in4, LOW); //Left Motor forword Pin \n}\n```\n\n```arduino\n// Arduino Line Follower Robot Code\n//More Information: https://circuitdigest.com/microcontroller-projects/arduino-uno-line-follower-robot \n#define enA 5//Enable1 L293 Pin enA \n#define in1 6 //Motor1  L293 Pin in1 \n#define in2 7 //Motor1  L293 Pin in1 \n#define in3 9 //Motor2  L293 Pin in1 \n#define in4 10 //Motor2  L293 Pin in1 \n#define enB 8 //Enable2 L293 Pin enB \n#define R_S 4//ir sensor Right\n#define L_S 2 //ir sensor Left\nvoid setup(){ \npinMode(R_S, INPUT); \npinMode(L_S, INPUT); \npinMode(enA, OUTPUT); \npinMode(in1, OUTPUT); \npinMode(in2, OUTPUT); \npinMode(in3, OUTPUT); \npinMode(in4, OUTPUT); \npinMode(enB, OUTPUT);\ndigitalWrite(enA, HIGH); \ndigitalWrite(enB, HIGH); \ndelay(1000);\n}\nvoid loop(){  \nif((digitalRead(R_S) == 0)&&(digitalRead(L_S) == 0)){forward();}   //if Right Sensor and Left Sensor are at White color then it will call forword function\nif((digitalRead(R_S) == 1)&&(digitalRead(L_S) == 0)){turnRight();} //if Right Sensor is Black and Left Sensor is White then it will call turn Right function  \nif((digitalRead(R_S) == 0)&&(digitalRead(L_S) == 1)){turnLeft();}  //if Right Sensor is White and Left Sensor is Black then it will call turn Left function\nif((digitalRead(R_S) == 1)&&(digitalRead(L_S) == 1)){Stop();} //if Right Sensor and Left Sensor are at Black color then it will call Stop function\n}\nvoid forward(){  //forword\ndigitalWrite(in1, HIGH); //Right Motor forword Pin \ndigitalWrite(in2, LOW);  //Right Motor backword Pin \ndigitalWrite(in3, LOW);  //Left Motor backword Pin \ndigitalWrite(in4, HIGH); //Left Motor forword Pin \n}\nvoid turnRight(){ //turnRight\ndigitalWrite(in1, LOW);  //Right Motor forword Pin \ndigitalWrite(in2, HIGH); //Right Motor backword Pin  \ndigitalWrite(in3, LOW);  //Left Motor backword Pin \n digitalWrite(in4, HIGH); //Left Motor forword Pin \n}\nvoid turnLeft(){ //turnLeft\ndigitalWrite(in1, HIGH); //Right Motor forword Pin \ndigitalWrite(in2, LOW);  //Right Motor backword Pin \ndigitalWrite(in3, HIGH); //Left Motor backword Pin \ndigitalWrite(in4, LOW);  //Left Motor forword Pin \n}\nvoid Stop(){ //stop\ndigitalWrite(in1, LOW); //Right Motor forword Pin \ndigitalWrite(in2, LOW); //Right Motor backword Pin \ndigitalWrite(in3, LOW); //Left Motor backword Pin \ndigitalWrite(in4, LOW); //Left Motor forword Pin \n}\n```\n\n# Start a Discussion on:\n\n# Comments\n\nVery nice project! Will try to build one for my little son. Thank you.\n\nLog in or register to post comments\n\nHello I need some Help with the Motor Driver. I dont know what the Input 1B and 2B stand for or where I can find them.\n\nIm pretty new to this so please help me out quick :)\n\nThanks.\n\nLog in or register to post comments\n\n# Add New Comment\n\nLog in or register to post comments"}
{"title":"How to Detect the Direction of Sound Using Arduino?","content":"Sound direction detection is a fascinating concept in robotics and automation. It allows a device to \"hear\" and determine the direction of a sound. This concept has numerous applications, including robot navigation, smart security systems, gaming, and entertainment. Earlier we showed you how to measure sound in dB using Arduino, in this tutorial let's learn how to find the direction of sound using Arduino and a few microphones.\n\nAbove, you can see a short demonstration GIF of the project we’ll be discussing today. Let's learn some basics about detecting sound direction using Arduino and a few microphones. Without further ado, let’s dive into the technique used here.\n\n# How does Sound Localization works?\n\nIn a nutshell, sound localization involves detecting sound from four microphones simultaneously, identifying the highest amplitude signal, and determining the direction of the sound source based on the microphone receiving the strongest signal. While this method is straightforward, it has limitations that may reduce system efficiency.\n\nThis is where an advanced method, Fast Fourier Transform (FFT) analysis, comes into play. FFT shifts the time-domain signal to the frequency domain, making it easier to differentiate sounds—like human voices versus background noise—by analyzing frequency ranges. This approach reduces some limitations of the simpler method and enables detection within a fixed range of frequencies.\n\nUsing four microphones positioned around the device, the system listens for a target frequency (e.g., 3000 Hz) and compares the magnitude of sound from each microphone. The Arduino processes the signals in real-time, finding the direction based on the strongest signal. This information is then visualized on an OLED screen with animated \"eyes\" that track the sound source. This physical setup is essential to accurately identify the direction, allowing detection over a full 360°.\n\nYou don't need to rely on 3D printing for this setup; simple cardboard or foam can do the job well.\n\nNow that you understand the concept, let’s build it!\n\n# 3D Model\n\nI designed a 3D case for this project using TinkerCad, which should be easy to replicate. The 3D model is available on GitHub, with a link provided at the bottom of this document.\n\nNote: 3D printing is not necessary to demonstrate sound localization. Alternatives like foam, cardboard, or small boxes can be used.\n\n# Components Required\n\nBelow is the list of required components. This project has been tested with Arduino UNO R4 WiFi, Arduino UNO R3, and ESP32, so you can use any of these. However, there may be minor code adjustments for each microcontroller.\n\nArduino UNO R4 WiFi - 1\n\nMAX4466 Microphone Amplifier Module - 4\n\n0.96” OLED Display (128x64 px) - 1\n\nConnecting wires - Required\n\nBreadBoard - Optional\n\n3D Printing - Optional\n\n# Circuit Diagram\n\nThe circuit diagram depends on your choice of microcontroller. For Arduino UNO, the circuit is similar to the one shown below.\n\nWhen using a different microcontroller, focus on selecting suitable ADC pins for microphone inputs. For Arduino, I used A0, A1, A2, and A3 for microphone inputs, with A4 and A5 as SDA and SCL pins for the OLED display.\n\nFor simplicity, I powered all microphones and the OLED display with the Arduino’s 3.3V output. The MAX4466 module supports input voltages from 2.4 to 5.5V, and the OLED operates at 3.3V (some displays may support up to 5V, but I suggest 3.3V for safety).\n\nWith the circuit clear, let’s move on to the assembly.\n\n# Hardware Assembling\n\nLet’s begin assembling the hardware. Starting with the head section, place all components as shown.\n\nI secured the microphone module and OLED display with hot glue and shortened the pins for hassle-free soldering. You can choose the method that suits you best.\n\nI wrapped a bit of tape around the microphones to ensure a snug fit.\n\nI started by soldering the OLED display, creating a parallel connection for the power rails, with individual connections for the analog output and the SDA/SCL pins.\n\nYou can see the partial wiring above, followed by the complete wiring. I used multicolor ribbon cables to simplify things.\n\nAfter completing the soldering, I routed the wires through the center hole in the bottom 3D print, which functions like a hollow pipe. I then soldered header pins to connect easily to the Arduino UNO.\n\nWith the hardware assembly complete, let’s move on to coding.\n\n# Coding Part\n\nNow, let’s break down the code logic and functionality for this sound localization project.\n\nThe program detects the direction of sound using four microphones, performing an FFT to analyze sound frequencies, particularly around 3000 Hz. Based on sound direction, it displays \"eyes\" on an OLED screen to track the source. If no sound is detected, it shows \"sleepy eyes\" as an idle state.\n\nNow lets breakdown the code, starting from the utilized libraries.\n\n# Libraries Used:\n\narduinoFFT - Available in Library Manager\n\nWire - default library\n\nAdafruit_GFX - Available in Library Manager\n\nAdafruit_SSD1306 - Available in Library Manager\n\nThese libraries are compatible with both Arduino UNO and ESP32.\n\nNext, constants, variables, and libraries are initialized. I created separate FFT objects for each microphone to manage them independently. Important control parameters, such as target frequency, magnitude threshold, and sampling frequency, are defined. You can adjust these to fine-tune the system.\n\nAnd next, you can see some user defined functions in our programe.\n\n# Code Flow:\n\nSetup Function (setup()):\n\nInitializes the serial communication and the OLED display.\n\nClears the display to ensure it's ready to show graphics.\n\nMain Loop (loop()):\n\nThe loop() runs continuously, calling the function determineAngle() to check where the sound is coming from.\n\nIt then calls drawEyes() to update the OLED display with either normal or sleepy eyes, depending on the sound data.\n\nDetermining the Sound Direction (determineAngle()):\n\nTakes 64 samples from each microphone and applies FFT to convert the sound data into frequency data.\n\nIt checks the magnitude of the target frequency (3000 Hz) from each microphone and determines which microphone has the strongest sound signal.\n\nBased on the strongest signal, it calculates the angle of the sound (0°, 90°, 180°, or 270°).\n\nDisplaying the Eyes (drawEyes()):\n\nThe drawEyes() function draws different eye graphics on the OLED screen based on the calculated angle.\n\nIf the sound stays the same for a long period (based on the angleCounter(), it will display sleepy eyes.\n\nNow hope you understand the working logic of our code. You can find the complete code at the bottom of this document.\n\nNext lets see the working of the program in detail.\n\n# Working of the Sound localization project\n\nOnce the program is uploaded, the final result can be seen in the GIF below. We tested it with various target frequencies, and it responded accurately.\n\nAs per the current code, if the sound is coming from same direction for long time the OLED show the sleep Symbol.\n\nThis project can be further expanded to detect a range of frequencies rather than a specific one. However, it’s still susceptible to noise. While software solutions can help, hardware solutions like analog noise filters on microphone inputs will yield the best results.\n\n# Applications of Sound Direction Detection Project\n\nRobotics Navigation: Robots equipped with sound localization can detect the direction of voice commands or nearby sounds, helping them interact more naturally with people or respond quickly to alerts.\n\nSmart Security Systems: By integrating sound direction detection, smart security systems can identify suspicious sounds—like breaking glass or loud disturbances—and immediately focus cameras or alarms in that direction.\n\nInteractive Art Installations: Artists and designers can use sound direction detection to create immersive exhibits that respond to audience sounds, allowing installations to come to life based on visitor interactions.\n\nVoice-Activated Systems: In smart home devices, sound direction detection helps microphones focus on the source of voice commands, improving accuracy and responsiveness for virtual assistants like Alexa or Google Home.\n\nEnvironmental Monitoring: This technology can assist in wildlife monitoring by pinpointing the direction of animal calls or other environmental sounds, aiding in research and conservation.\n\nAcoustic Measurements and Sound Profiling: Engineers and researchers can use this system to study how sound travels in different environments or to conduct precise measurements of sound direction in experiments.\n\n# For all the code, follow the GitHub link below:\n\n# Start a Discussion on:\n\n# Comments\n\nHello\n\nThis is just what I was looking for. I lost hearing on\n\nmy left ear this summer and thats why I was trying to find\n\nsomething like this. I will try to make this project, but\n\nI am strandet before I was started when I was trying\n\nto compile the sketch. I get the following error from\n\nthe arduino compiler:\n\n>>Global variables use 2673 bytes (130%) \nof dynamic memory, leaving -625 bytes \nfor local variables. Maximum is 2048 bytes.\ndata section exceeds available space in board\nNot enough memory; <<\n\nI am no big programmer so I do not kmow what\n\nto do, is there any help to get here ?\n\nRegard Max\n\nLog in or register to post comments\n\nIn reply to Hello   This is just what I… by Max\n\nHi, looks like you are using Arduino UNO R3, that's why the memory overflow error occurs, since UNO R3 has only 2KB of RAM. Use and UNO R4 instead.\n\nLog in or register to post comments\n\nIn reply to Hi, looks like you are using… by Jobit Joseph\n\nHello\n\nThat is correct, I just found out about that a moment ago.\n\nNow I am trying a ESP-32, and that is going well with no errors\n\nby compilation.\n\nNow I just have to find what pins to use on the ESP-32 instead\n\nof the A0, A1, A2, A3 on the Arduino.\n\nRegards and thank you for the help.\n\nMax\n\nLog in or register to post comments\n\n# Add New Comment\n\nLog in or register to post comments"}
{"title":"Build a Simple Arduino RC Boat that can be Controlled Wirelessly using 433 MHz RF Modules","content":"In this project, we will build a remote-controlled Arduino Air-Boat that can be controlled wirelessly using the 433 MHz RF Radio Modules. We will control this boat using a homemade remote control by building our own 433 MHz transmitter and a receiver module. In the case of remote-controlled devices or communication between two devices, we have a lot of options like IR, Bluetooth, internet, RF, etc. When compared to IR communication, radio communications have some advantages like more range and it doesn’t require a line of sight connection between the transmitter and receiver. Also, these modules can do two ways of communication, meaning it can transmit and receive at the same time. So using this 433MHz RF module, let’s build an Arduino RC Boat in this tutorial.\n\nWe have previously built many remote-controlled projects using these 433Mhz RF modules for either controlling a Robot like this RF controlled Robot or for Home Automation applications to Control Home appliances using RF. Apart from using RF modules, we have also built a Bluetooth Controlled Raspberry Pi Car and a DTMF Mobile phone controlled Arduino Robot previously. You can also check out these projects if you are interested.\n\n# Components Required for Arduino RC Boat\n\n433MHz transmitter and receiver\n\nArduino (any Arduino, to reduce the size I am using promini)\n\nHT12E and HT12D\n\nPush buttons- 4Nos\n\nResistors- 1mega ohm, 47k ohm\n\nL293d Motor Driver\n\n9V Battery (I am using a 7.4-volt battery)- 2Nos\n\n7805 regulator- 2Nos\n\nDC motors- 2Nos\n\nMotor leaf or propellors(I am using homemade propellors)- 2Nos\n\n.1uf capacitor- 2Nos\n\nCommon PCB\n\n# 433MHz RF Transmitter and Receiver Modules\n\nThese types of RF modules are very popular among makers. Because of their low cost and simplicity in connections. These modules are best for all forms of short-range communication projects. These modules are ASK (Amplitude Shift Keying) type RF modules, Amplitude-shift keying (ASK) is a form of amplitude modulation that represents digital data as variations in the amplitude of a carrier wave. In an ASK system, the binary symbol 1 is represented by transmitting a fixed-amplitude carrier wave and fixed frequency for a bit duration of T seconds. If the signal value is 1, then the carrier signal will be transmitted; otherwise, a signal value of 0 will be transmitted. That means they usually draw no power when transmitting Logic “zero”. This low power consumption makes them very useful in battery-operated projects.\n\n# 433MHZ RF Transmitter\n\nThis type of module is super tiny and comes with 3 pins VCC, ground, and data. Some other modules come with an extra antenna pin. The working voltage of the transmitter module is 3V-12V and this module doesn't have any adjustable components. One of the major advantages of this module is the low current consumption, it requires almost zero current to send bit zero.\n\n# Block Diagram of Arduino RC Boat Transmitter\n\nIn the above block diagram, there are four pushbuttons (Control Buttons), these pushbuttons are for controlling the direction of the boat. We have four of them for forward, backward, left, and right. From the pushbuttons, we get logic for controlling the boat but can’t directly connect to the encoder that's why we used the Arduino. You might think why I used Arduino here, it is simply because we need to pull down two parallel data inputs of the encoder at the same time for a backward and forward movement that can’t be achieved with just pushbuttons. Then the encoder encodes the coming parallel data to serial outputs. Then we can transmit that serial data with the help of an RF transmitter.\n\n# Circuit Diagram of the Arduino RC Remote (Transmitter)\n\nIn the above circuit, you can see one side of all four pushbuttons connected to four digital pins of Arduino (D6-D9) and all the four other sides connected to the ground. That is when we press the button, the corresponding digital pins get a logic low. The four parallel inputs of the HT12E encoder connected to another four digital pins of Arduino (D2-D5). So with the help of Arduino, we can decide the input of the encoder.\n\nAnd talking about encoder HT12E is a 12-bit encoder and a parallel input-serial output encoder. Out of 12 bits, 8-bits are address bits that can be utilized for controlling multiple receivers. The pins A0-A7 are the address input pins. In this project, we are controlling only one receiver, so we don't want to change its address, so I connected all address pins to the ground. If you want to control different receivers with one transmitter, you can use dip switches here. AD8-AD11 are the control bit inputs. These inputs will control the D0-D3 outputs of the HT12D decoder. We need to connect an oscillator for the communication and the oscillator frequency should be 3KHz for 5V operation. Then the resistor value will be 1.1MΩ for 5V. Then I connected the output of the HT12E to the transmitter module. We already mentioned, the Arduino and rf transmitter module, both of these devices work on 5V high voltage will kill it, so to avoid this, I added the 7805, voltage regulator. Now we can connect (Vcc) 6-12volt any type batteries to input.\n\n# Building the RC BOAT Transmitter Circuit\n\nI soldered every component on a common PCB. Remember we are working on an RF project so there are a lot of chances for different types of interferences so connect all components very closely as much possible. It's better to use female pin headers for Arduino and the transmitter module. Also, try to solder everything on the copper pads instead of using extra wires. Finally, connect a small wire to the transmitter module that will help to increase the total range. Before connecting the Arduino and transmitter module, double-check the voltage of the lm7805 output.\n\nThe above image shows the top view of the completed RC Boat transmitter circuit and the Bottom view of the completed RC Boat Transmitter circuit is shown below.\n\n# Building the Arduino RC Boat Transmitter Enclosure\n\nA decent body is necessary for the remote. This step is all about your ideas, you can create a remote body with your ideas. I am explaining how I made this. For making a remote body, I choose 4mm MDF sheets, you can also choose plywood, foam sheet, or cardboard, then I cut two pieces from that with a length of 10cm and breadth of 5cm. Then I marked the positions for the buttons. I placed the direction buttons on the left side and forward, backward buttons on right. On the other side of the sheet, I connected the push buttons to the main transmitting circuit. Remember a normal pushbutton has 4 pins that are two pins for each side. Connect one pin to Arduino and the other pin to the ground. If you are confused with that, please check it with a multimeter or check the datasheet.\n\nAfter connecting all these things, I placed the control circuit in between the two MDF boards and tighten with some long bolt (please refer to the below images if you want). Once again creating a good body is all about your ideas.\n\n# 433Mhz Receiver Module\n\nThis receiver also very tiny and comes with 4 pins VCC, ground, and the two middle pins are data out. The working voltage of this module is 5v. Like the transmitter module, this is also a low power module. Some modules come with an extra antenna pin but in my case, that is not present.\n\n# Block Diagram of the Arduino RC Boat Receiver\n\nThe above block diagram describes the working of the RF receiver circuit. First, we can receive the transmitted signals using the RF receiver module. The output of this receiver is serial data. But we can't control anything with this serial data that's why we connected the output to the decoder. The decoder decodes the serial data to our original parallel data. In this section, we don't require any microcontrollers, we can directly connect the outputs to the motor driver.\n\n# Circuit Diagram of Arduino RC Boat Receiver\n\nThe HT12D is a 12-bit decoder which is a serial input-parallel output decoder. The input pin of the HT12D will be connected to a receiver that has a serial output. Among the 12-bits, 8 bits (A0-A7) are address bits and the HT12D will decode the input if only it matches its current address. D8-D11 are the output bits. To match this circuit to the transmitter circuit, I connected all the address pins to the ground. Data out of the module is the serial type and the decoder decodes this serial data to original parallel data and we get out through D8-D11. To match the oscillation frequency should connect the 33-56k resistor to oscillator pins. Led on the 17th pin indicates the valid transmission, it only lit after when the receiver connected to a transmitter. The voltage input of the receiver is also 6-12 volts.\n\nTo control motors, I used the L293D IC, I choose this IC because to decrease the size and weight and this IC is best for controlling two motors in two directions. L293D has 16 pins, the below diagram shows the pinouts.\n\n1, 9 pins are the enable pin, we connect that to 5 v to enable motors 1A, 2A, 3A, and 4A are the control pins. The motor will turn to the right if the pin 1A goes low and 2A goes high, and the motor will turn to the left if 1A goes low and 2A high. So we connected these pins to the output ps of the decoder. 1Y, 2Y, 3Y, and 4Y are the motor connection pins. Vcc2 is the motor driving voltage pin, if you are using a high voltage motor, then you connect this pin to the corresponding voltage source.\n\n# Building the Receiver Circuit of Arduino RC Boat\n\nBefore building the receiver circuit, you should remember some important things. The important one is the size and weight because after building the circuit, we need to fix it on the boat. So if the weight increases, that will affect the buoyancy and movement.\n\nSo same as in the transmitter circuit, solder every component in a small common PCB and try to use minimum wires. I connected pin 8 of the motor driver to 5v because I am using 5V motors.\n\n# Building the RC-BOAT\n\nI tried different materials to build the boat body. And I got a better result with thermocol sheet. So I decided to build the body with thermocol. First, I took a 3cm thick thermocol piece and place the receiver circuit on top, then I marked the shape of the boat in thermocol and cut. So this is my way to build the boat, you can build according to your ideas.\n\n# Motors and Propellers for Arduino Air Boat\n\nOnce again weight matters. So choosing the correct motor is important, I choose 5volt, n20 type normal dc motors which is small and weightless. To avoid the RF interferences should connect 0.1uf capacitor parallel to motor inputs.\n\nIn the case of propellers, I made propellers using plastic sheets. You can buy propellers from the store or you can build your own both will work just fine. To build the propellers, first, I took a small plastic sheet and cut two small pieces from it and I bend the pieces with the help of candle heat. Finally, I put a small hole in its center for the motor and fixed to the motor that's it.\n\n# Working of Arduino RC Boat\n\nThis boat has two motors lets call it left and right. If the motor moves to clockwise also (the position of the propellor also depends) propellor sucks air from the front and exhaust to the backside. That generates forward drag.\n\nForward movement: If  both the left and right motors rotate to clockwise that will  forward movement\n\nBackward movement: If  both the left and right motors  to rotate counterclockwise(that is propeller sucks  air from the backside and exhaust to the front side )that will make backward movement\n\nLeft movement: If  only the right motor  rotates  that is boat get only drag from the right side that will the boat to move to the left  side\n\nRight movement: If only the left motor rotates that is boat gets only drag from the left side that will make the boat move to the right side.\n\nWe connected the motors driver's input to four output bits of the decoder(D8-D11). we can control these 4 outputs by connecting the AD8-AD11 to the ground that is the buttons in the remote. For example, if we connect AD8 to the ground that will activate the D8. So such a way we can control the two motors in two directions using these 4 outputs. But we can't control two motors by just one button (we need that for forward and backward movement) that's why we used the Arduino. With help of Arduino, we can select the input data pins as our wish.\n\n# Arduino Programming of the RC Boat\n\nThe programming of this boat is very simple because we want only some logic switching. And we can achieve everything with basic Arduino functions. The complete program for this project can be found at the bottom of this page. The explanation of your program is as follows\n\nWe start the program by defining the integers for four input buttons and decoder inputs pins.\n\n```arduino\nint f_button = 9;\nint b_button = 8;\nint l_button = 7;\nint r_button = 6;\nint m1=2;\nint m2=3;\nint m3=4;\nint m4=5;\n```\n\nIn the setup section, I defined the pin modes. That is, the buttons are connected to digital pins so these pins should define as input and we need to get output for the input of the decoder so we should define those pins as output.\n\n```arduino\npinMode(f_button,INPUT_PULLUP);\n  pinMode(b_button,INPUT_PULLUP);\n  pinMode(l_button,INPUT_PULLUP);\n  pinMode(r_button,INPUT_PULLUP);\n  pinMode(m1,OUTPUT);\n  pinMode(m2,OUTPUT);\n  pinMode(m3,OUTPUT);\n  pinMode(m4,OUTPUT);\n```\n\nNext in the main loop function, we will read the button status using the digitalread function of Arduino. If the pin status goes low that means the corresponding pin is pressed then we will execute the conditions as like follows-\n\n```arduino\nif ( digitalRead(f_button)==LOW)\n```\n\nThat means the forward button is pressed\n\n```arduino\n{\n   digitalWrite(m1, LOW);\n   digitalWrite(m3, LOW);\n   digitalWrite(m2, HIGH);\n   digitalWrite(m4, HIGH);\n }\n```\n\nThis will pulldown m1 and m2 of the encoder this will activate both motors on the receiver side. Similarly, for backward movement\n\n```arduino\n{\n   digitalWrite(m1, HIGH);\n   digitalWrite(m3, HIGH);\n   digitalWrite(m2, LOW);\n   digitalWrite(m4, LOW);\n }\n```\n\nFor left movement\n\n```arduino\n{\n   digitalWrite(m1, LOW);\n   digitalWrite(m3, HIGH);\n   digitalWrite(m2, HIGH);\n   digitalWrite(m4, HIGH);\n }\n```\n\nFor right movement\n\n```arduino\n{\n   digitalWrite(m1, HIGH);\n   digitalWrite(m3, LOW);\n   digitalWrite(m2, HIGH);\n   digitalWrite(m4, HIGH);\n }\n```\n\nAfter compiling the code, upload it to your Arduino board.\n\nTroubleshooting: Place the boat on the water surface and check whether it is moving correctly if not try to change the polarity of motors and propellers. Also, try to balance weight.\n\nThe complete working of the project can be found in the video linked at the bottom of this page. If you have any questions leave them in the comment section.\n\n# Complete Project Code\n\n```arduino\nint f_button = 9;\nint b_button = 8;\nint l_button = 7;\nint r_button = 6;\nint m1 = 2;\nint m2 = 3;\nint m3 = 4;\nint m4 = 5;\nvoid setup () {\n  pinMode(f_button, INPUT_PULLUP);\n  pinMode(b_button, INPUT_PULLUP);\n  pinMode(l_button, INPUT_PULLUP);\n  pinMode(r_button, INPUT_PULLUP);\n  pinMode(m1, OUTPUT);\n  pinMode(m2, OUTPUT);\n  pinMode(m3, OUTPUT);\n  pinMode(m4, OUTPUT);\n}\nvoid loop() {\n  if ( digitalRead(f_button) == LOW)\n  {\n    digitalWrite(m1, LOW);\n    digitalWrite(m3, LOW);\n    digitalWrite(m2, HIGH );\n    digitalWrite(m4, HIGH);\n  }\n  if ( digitalRead(b_button) == LOW)\n  {\n    digitalWrite(m2, LOW);\n    digitalWrite(m4, LOW);\n    digitalWrite(m1, HIGH);\n    digitalWrite(m3, HIGH);\n  }\n  if ( digitalRead(l_button) == LOW)\n  {\n    digitalWrite(m1, LOW);\n    digitalWrite(m2, HIGH);\n    digitalWrite(m3, HIGH);\n    digitalWrite(m4, HIGH);\n  }\n  if ( digitalRead(r_button) == LOW)\n  {\n    digitalWrite(m1, HIGH);\n    digitalWrite(m2, LOW);\n    digitalWrite(m3, HIGH);\n    digitalWrite(m4, HIGH);\n  }\n}\n```\n\n```arduino\nint f_button = 9;\nint b_button = 8;\nint l_button = 7;\nint r_button = 6;\nint m1 = 2;\nint m2 = 3;\nint m3 = 4;\nint m4 = 5;\nvoid setup () {\n  pinMode(f_button, INPUT_PULLUP);\n  pinMode(b_button, INPUT_PULLUP);\n  pinMode(l_button, INPUT_PULLUP);\n  pinMode(r_button, INPUT_PULLUP);\n  pinMode(m1, OUTPUT);\n  pinMode(m2, OUTPUT);\n  pinMode(m3, OUTPUT);\n  pinMode(m4, OUTPUT);\n}\nvoid loop() {\n  if ( digitalRead(f_button) == LOW)\n  {\n    digitalWrite(m1, LOW);\n    digitalWrite(m3, LOW);\n    digitalWrite(m2, HIGH );\n    digitalWrite(m4, HIGH);\n  }\n  if ( digitalRead(b_button) == LOW)\n  {\n    digitalWrite(m2, LOW);\n    digitalWrite(m4, LOW);\n    digitalWrite(m1, HIGH);\n    digitalWrite(m3, HIGH);\n  }\n  if ( digitalRead(l_button) == LOW)\n  {\n    digitalWrite(m1, LOW);\n    digitalWrite(m2, HIGH);\n    digitalWrite(m3, HIGH);\n    digitalWrite(m4, HIGH);\n  }\n  if ( digitalRead(r_button) == LOW)\n  {\n    digitalWrite(m1, HIGH);\n    digitalWrite(m2, LOW);\n    digitalWrite(m3, HIGH);\n    digitalWrite(m4, HIGH);\n  }\n}\n```\n\n```arduino\nint f_button = 9;\nint b_button = 8;\nint l_button = 7;\nint r_button = 6;\nint m1 = 2;\nint m2 = 3;\nint m3 = 4;\nint m4 = 5;\nvoid setup () {\n  pinMode(f_button, INPUT_PULLUP);\n  pinMode(b_button, INPUT_PULLUP);\n  pinMode(l_button, INPUT_PULLUP);\n  pinMode(r_button, INPUT_PULLUP);\n  pinMode(m1, OUTPUT);\n  pinMode(m2, OUTPUT);\n  pinMode(m3, OUTPUT);\n  pinMode(m4, OUTPUT);\n}\nvoid loop() {\n  if ( digitalRead(f_button) == LOW)\n  {\n    digitalWrite(m1, LOW);\n    digitalWrite(m3, LOW);\n    digitalWrite(m2, HIGH );\n    digitalWrite(m4, HIGH);\n  }\n  if ( digitalRead(b_button) == LOW)\n  {\n    digitalWrite(m2, LOW);\n    digitalWrite(m4, LOW);\n    digitalWrite(m1, HIGH);\n    digitalWrite(m3, HIGH);\n  }\n  if ( digitalRead(l_button) == LOW)\n  {\n    digitalWrite(m1, LOW);\n    digitalWrite(m2, HIGH);\n    digitalWrite(m3, HIGH);\n    digitalWrite(m4, HIGH);\n  }\n  if ( digitalRead(r_button) == LOW)\n  {\n    digitalWrite(m1, HIGH);\n    digitalWrite(m2, LOW);\n    digitalWrite(m3, HIGH);\n    digitalWrite(m4, HIGH);\n  }\n}\n```\n\n# Start a Discussion on:\n\n# Add New Comment\n\nLog in or register to post comments"}
{"title":"Bluetooth Controlled Pick and Place Robotic Arm Car using Arduino","content":"In the domain of robotics and automation, precision-controlled mechanical movements have ushered in a revolutionary wave across diverse industries, spanning from manufacturing to healthcare. Thanks to the advent of cost-effective microcontrollers (Arduino) and easily accessible programming tools, enthusiasts and hobbyists now have the means to create their own Bluetooth-controllable robotic arm using an Arduino board, servo motors, and a motor driver.\n\nRobotic arms have found their way into an extensive array of applications, from industrial automation to even Pick and Place assembly lines. The ARA (Arduino Robotic Arm) now, from the comfort of your own home, you can construct a Robot Arm mounted on a 2WD Arduino car kit.\n\nThis tutorial will serve as an illuminating guide on how to create an Arduino-powered Robotic Arm, replete with wireless control and programmability facilitated through a custom-build Android application. Within the application's interface, individual servos or axes of the robot arm can be manually maneuvered using dedicated buttons. Notably, this robot car encompasses two primary functions: a 2WD car mode and the control of a robotic arm. This integration is achieved through the utilization of two DC motors and a robotic arm. The robotic arm itself is presented through both a 3D-designed model (designed from scratch) and a physically assembled iteration.\n\nAlso check our previously built Robotic Arm projects using different microcontrollers:\n\nDIY Pick and Place Robotic Arm using ARM7-LPC2148 ARM Microcontroller\n\nHand Gesture Controlled Robotic Arm using Arduino Nano\n\nArduino Based Robotic Arm\n\nRecord and Play 3D Printed Robotic Arm using Arduino\n\nRobotic Arm Control using PIC Microcontroller\n\n# Kinematics of Arm Robot Manipulator\n\nAt first, the thought of building a robotic arm might sound complex and gruesome. But after learning the physics and kinematics behind it and going more in-depth to the topic. You will understand that it is not that hard.\n\nThis robotic arm consists of 3 servo motors 1 for Gripper and 2 for Arm joints movement. This means that the DOF (degree of freedom) for this robot is 2. The angle and position of the Arm depends on the kinematics.\n\nKinematics is the science that considers the motion of an object (robot) without cares for the cause of that motion. Kinematics studies the position, velocity, acceleration, and other higher derivatives of position with respect to time. Therefore, the study of kinematics refers to all geometrical and time-based properties of motion.\n\nAn arm robot manipulator is a set of links connected by joints, the lowest part is called the based, and the end part is called end-effector. The number of joints and how it moves define the degree of freedom (DOF). The joints are characterized as revolute or prismatic joints. Below fig shows 2 DOF robot consists of all revolute joints. A typical applied in industries robot has 5 or 6 joints. In this project, the kinematics and dynamics are derived from 2 DOF for the sake of simplicity.\n\n# Forward Kinematics\n\nForward kinematics involves utilizing a robot's kinematic equations to calculate the position of the end-effector based on given joint parameter values, which in this context are the positions of the servo motors. In the sketch of the robotic arm below, you can visualize the Denavit-Hartenberg parameters, an essential component in this process. Additionally, the derived forward kinematic equations for the robotic arm are presented.\n\nWhile an alternative approach was ultimately pursued, one not reliant on matrices, the derived equations remain valuable for those interested in exploring different methodologies. It's important to note that 'C' represents cosine and 'S' represents sine.\n\n# Inverse Kinematics\n\nBy solving the Inverse Kinematics equations, we can precisely control the movement and orientation of the robotic arm's end-effector. These equations provide us with the necessary angles for each joint to achieve a desired position in space. The figure below visually breaks down the variables that play a crucial role in these equations, allowing us to translate mathematical concepts into practical arm movements.\n\n# Design and Build of Robotic Arm\n\nI created the custom robotic arm specifically for this project, and you can see screenshots of the CAD design I made using onshape, as well as the actual mechanical arm I built, in the images below. If you're interested in recreating this project or incorporating my design into your own work, I've included the CAD .dxf files, which you can download from here.\n\nRobotic Arm\n\nFor constructing the arm, I used laser-cut acrylic parts. However, if you have access to a 3D printer, you can also use that. If you opt for the 3D printing route, you'll need to open the files in SolidWorks, convert them to STL format, and save them. To do this, open any part, click 'Save As,' and choose STL as the file format.\n\nHere's a visual representation of what the laser-cut acrylic sheet will look like.\n\nArduino robot arms, much like other robot arms, are commonly evaluated based on their degrees of freedom (DOF). This term refers to the count of rotational joints integrated into the robot's design. The concept of DOF is interchangeable with the term \"axes,\" a familiar term in this context. For instance, a 2DOF (2 Axis) robot arm is equipped with two distinct axes enabling specific motion.\n\nThis robotic arm arrives in a flat-pack state, requiring minimal soldering for assembly and activation. It incorporates two MG90 servos, enabling two degrees of movement. Notably, it can adeptly grip lightweight objects using the gripper.\n\nThe \"Base,\" also known as the \"Waist,\" often facilitates a 180° or 360° rotation of the arm, contingent on the servo type employed (in this project, a 180° Servo was utilized).\n\nThe \"Base,\" also known as the \"Waist,\" often facilitates a 180° or 360° rotation of the arm, contingent on the servo type employed (in this project, a 180° Servo was utilized).\n\nThe \"Shoulder\" maneuver is responsible for vertically raising or lowering the arm.\n\nThe \"Shoulder\" maneuver is responsible for vertically raising or lowering the arm.\n\nThe \"Gripper\" engages by either opening or closing to \"grab things.\"\n\nThe \"Gripper\" engages by either opening or closing to \"grab things.\"\n\n# Components Required for Robotic Arm Car\n\nArduino board (e.g., Arduino Uno)\n\nArduino board (e.g., Arduino Uno)\n\nMG 90 metal gear Servo motors (3x)\n\nMG 90 metal gear Servo motors (3x)\n\nL298N motor driver\n\nL298N motor driver\n\nHC-05 Bluetooth module\n\nHC-05 Bluetooth module\n\nLaser cut Chassis and Robotic arm mechanical components\n\nLaser cut Chassis and Robotic arm mechanical components\n\n12V Li-ion battery\n\n12V Li-ion battery\n\nLM2596 DC-DC Buck Converter\n\nLM2596 DC-DC Buck Converter\n\nSwitch\n\nSwitch\n\nJumper wires\n\nJumper wires\n\nBreadboard or PCB (Printed Circuit Board)\n\nBreadboard or PCB (Printed Circuit Board)\n\nScrews, nuts, spacers\n\nScrews, nuts, spacers\n\n# Assembly of Robotic Arm\n\nWe have utilized an acrylic sheet cut with a laser to create a Robotic Arm for our project. The sheet has been precisely cut to accommodate all the necessary fittings and components, allowing for easy assembly using screwdrivers.\n\nBefore starting the assembly, we need to adjust the angle adjustment of the servo motors. Otherwise, your robotic Arm will not work properly.\n\nTo begin, attach the Servo Arm to the servo by carefully aligning and securing it in place. We can manually calibrate and adjust the servo motor angle but some time manually calibration is not accurate or may not be possible. so you can calibrate your servo motors using the provided code #1. Refer to the circuit diagram mentioned below and connect your servo motors to Arduino pins 5, 6, and 3 accordingly. Upload the provided code #1 to your Arduino board, which will facilitate the calibration process. Failing to execute this step may result in unstable performance of your robot.\n\nBy ensuring proper alignment and calibration of the servos, you lay the foundation for a stable and well-functioning robot.\n\nAngle values for robotic arm movements\n\nNo.\n\nServo type\n\nAngle of rotation on servo(in°)\n\nInformation\n\n1\n\nServo gripper\n\n150°\n\nPinch\n\n60°\n\nOpen\n\n2\n\nServo Waist\n\n45°\n\nDown\n\n90°\n\nUp\n\n3\n\nServo Base\n\n0°\n\nRight position\n\n90°\n\nMiddle position\n\n180°\n\nLeft position\n\nThis angle value maybe changed cording to your servo adjustment. After done with servo adjustments, you can pass Assembly stages.\n\nStep 1: Here is an image showcasing all the essential components necessary for assembling the robotic arm.\n\nStep 2: Secure the servo motor to the gripper base plate using M2.5 10mm nuts and bolts.\n\nStep 3: Attach the pair of gripper gears to the servo and base plate using M4 10mm nuts and bolts.\n\nStep 4: Secure the gripper hand to both gears at their designated positions using M3 30mm nuts and bolts.\n\nStep 5: Join the hand support link to both the gripper hand and servo base plate using M3 and M4 10mm nuts and bolts.\n\nStep 6: Finally, attach the side stopper and shoulder movement legs to their respective positions using M3 nuts and bolts.\n\n# Circuit Diagram for Bluetooth-Controlled Robotic Arm Car with Arduino (3 Servo Motors)\n\nIn this setup, the DC motors work like the robot's wheels, helping it to move in different directions. Meanwhile, the three servo motors act like the robot arm's joints, allowing it to twist and turn at the waist, lift or lower its shoulder, and open or close its gripper.\n\nFor this project, you don't need any complicated wiring because all the motors use 5V. We control the motors using digital pins. We didn't use the 5V pin on the Arduino because it wouldn't give enough power to run all the motors well. Instead, we use a DC-DC buck converter and a different power supply. This way, we can provide enough power to make sure all the motors work properly.\n\n# Circuit Connection:\n\nArduino and L298n motor driver module Connections:\n\nConnect the ground (GND) pin of the Arduino to the ground rail on the breadboard.\n\nConnect the ground (GND) pin of the Arduino to the ground rail on the breadboard.\n\nConnect the Vin pin of the Arduino to the positive rail on the breadboard.\n\nConnect the Vin pin of the Arduino to the positive rail on the breadboard.\n\nConnect the 5V output from the LM2596 DC-DC buck converter to the positive rail on the breadboard.\n\nConnect the 5V output from the LM2596 DC-DC buck converter to the positive rail on the breadboard.\n\nConnect the ground (GND) output from the LM2596 DC-DC buck converter to the ground rail on the breadboard.\n\nConnect the ground (GND) output from the LM2596 DC-DC buck converter to the ground rail on the breadboard.\n\nConnect the input 1 (IN1) and input 2 (IN2) pins of the L298N motor driver to two digital pins on the Arduino (e.g., pins 7 and 8) for controlling the first DC motor.\n\nConnect the input 1 (IN1) and input 2 (IN2) pins of the L298N motor driver to two digital pins on the Arduino (e.g., pins 7 and 8) for controlling the first DC motor.\n\nConnect the input 3 (IN3) and input 4 (IN4) pins of the L298N motor driver to two digital pins on the Arduino (e.g., pins 12 and 11) for controlling the second DC motor.\n\nConnect the input 3 (IN3) and input 4 (IN4) pins of the L298N motor driver to two digital pins on the Arduino (e.g., pins 12 and 11) for controlling the second DC motor.\n\nConnect the ENA and ENB pins of the L298N motor driver to on board high state pin of L298N motor driver.\n\nConnect the ENA and ENB pins of the L298N motor driver to on board high state pin of L298N motor driver.\n\nServo Motor Connections:\n\nConnect the brown signal wire of the waist servo (first servo motor) to a digital pin on the Arduino (e.g., pin 5).\n\nConnect the brown signal wire of the waist servo (first servo motor) to a digital pin on the Arduino (e.g., pin 5).\n\nConnect the red positive wire of the waist servo to the positive rail on the breadboard.\n\nConnect the red positive wire of the waist servo to the positive rail on the breadboard.\n\nConnect the black negative wire of the waist servo to the ground rail on the breadboard.\n\nConnect the black negative wire of the waist servo to the ground rail on the breadboard.\n\nConnect the brown signal wire of the shoulder servo (second servo motor) to a digital pin on the Arduino (e.g., pin 6).\n\nConnect the brown signal wire of the shoulder servo (second servo motor) to a digital pin on the Arduino (e.g., pin 6).\n\nConnect the red positive wire of the shoulder servo to the positive rail on the breadboard.\n\nConnect the red positive wire of the shoulder servo to the positive rail on the breadboard.\n\nConnect the black negative wire of the shoulder servo to the ground rail on the breadboard.\n\nConnect the black negative wire of the shoulder servo to the ground rail on the breadboard.\n\nConnect the brown signal wire of the gripper servo (third servo motor) to a digital pin on the Arduino (e.g., pin 3).\n\nConnect the brown signal wire of the gripper servo (third servo motor) to a digital pin on the Arduino (e.g., pin 3).\n\nConnect the red positive wire of the gripper servo to the positive rail on the breadboard.\n\nConnect the red positive wire of the gripper servo to the positive rail on the breadboard.\n\nConnect the black negative wire of the gripper servo to the ground rail on the breadboard.\n\nConnect the black negative wire of the gripper servo to the ground rail on the breadboard.\n\nBluetooth Module Connections:\n\nConnect the TX pin of the HC-05 Bluetooth module to the RX pin (digital pin 0) of the Arduino.\n\nConnect the TX pin of the HC-05 Bluetooth module to the RX pin (digital pin 0) of the Arduino.\n\nConnect the RX pin of the HC-05 Bluetooth module to the TX pin (digital pin 1) of the Arduino.\n\nConnect the RX pin of the HC-05 Bluetooth module to the TX pin (digital pin 1) of the Arduino.\n\nConnect the VCC pin of the HC-05 Bluetooth module to the 5V rail on the breadboard.\n\nConnect the VCC pin of the HC-05 Bluetooth module to the 5V rail on the breadboard.\n\nConnect the GND pin of the HC-05 Bluetooth module to the ground rail on the breadboard.\n\nConnect the GND pin of the HC-05 Bluetooth module to the ground rail on the breadboard.\n\nPower Connections:\n\nConnect the positive terminal of the 12V Li-ion battery to the Vin input of the LM2596 DC-DC buck converter.\n\nConnect the positive terminal of the 12V Li-ion battery to the Vin input of the LM2596 DC-DC buck converter.\n\nConnect the negative terminal of the battery to the ground rail on the breadboard.\n\nConnect the negative terminal of the battery to the ground rail on the breadboard.\n\nConnect the positive terminal of the 12V Li-ion battery to L298n motor driver module 12V input.\n\nConnect the positive terminal of the 12V Li-ion battery to L298n motor driver module 12V input.\n\nConnect the negative terminal of the battery to GND of L298n motor driver module.\n\nConnect the negative terminal of the battery to GND of L298n motor driver module.\n\nWhen working with multiple servo motors, the power requirements exceed what the Arduino Uno microcontroller can’t provide. Therefore, an external power input is necessary. However, it is crucial to ensure that the input voltage does not exceed 5 volts to prevent damage to the Arduino microcontroller.\n\nIf using a higher voltage battery, use a voltage reducing circuit (DC - DC buck converter) to lower it to 5 volts. Connect the output of the voltage reducing circuit to both the Arduino and servo motors. This ensures safe and efficient power supply.\n\nAdditionally, make sure to configure the servo motor control and motor direction control in your Arduino code. Always double-check your connections before powering on the circuit.\n\n# Bluetooth-Controlled Robotic Arm Car Code Explanation\n\nThe Bluetooth-controlled robotic arm Car is controlled via an Android app on Smart phone. The app has different buttons for making the Car move forward, backward, left, and right. It also controls the robotic arm waist, shoulder, and gripper movements.\n\nThe app sends signals when pressed the specific button to the servo motors in the robot, telling them how to position the arm for each type of movement.\n\nIt is important to execute this code #1 before starting the assembly stages. This code is designed to calibrate and adjust the servo motors to their correct angles. By running this code, you can ensure that the servo motors are properly functioning and positioned accurately. This will help prevent any potential issues or complications during the subsequent stages of the assembly process.\n\nCode #1\n\n```arduino\n#include <ESP32_Servo.h>    // include servo library\n// Define 3 Servos\nServo myServo1; // waist or base Servo\nServo myServo2; // shoulder Servo\nServo myServo3; // gripper Servo\nvoid setup() {\n  // Attach servos to Arduino PWM Pins\n  myServo1.attach(5);\n  myServo2.attach(6);\n  myServo3.attach(3);\n  myServo1.write(90);\n  myServo2.write(90);\n  myServo3.write(90);\n}\nvoid loop() {\n}\n```\n\nThis code #2 includes all the necessary servo motor movements to make your robot functional. Without this code, you will not be able to complete the project successfully. It is crucial for the proper operation of the robot.\n\nThis code outlines the setup and control mechanisms for a robotic arm and a 2WD Arduino car using servo motors and DC motors. It integrates Bluetooth communication to enable remote control and demonstrates how to manipulate servo angles and motor directions to achieve specific movements.\n\nCode #2\n\n```arduino\n#include <Servo.h>\nServo motor_1;      \nServo motor_2;\nServo motor_3;\n```\n\nThese lines include the necessary library for using servo motors and define three Servo objects (motor_1, motor_2, and motor_3) are created to control the three servos connected to pins 5, 6, and 3 respectively.\n\n```arduino\n#define in1 7 //Motor1  L298 Pin in1\n#define in2 8 //Motor1  L298 Pin in1\n#define in3 12 //Motor2  L298 Pin in1\n#define in4 11 //Motor2  L298 Pin in1\n```\n\nThese lines define digital pins of Arduino (pin7,pin8,pin12 and pin11) for the L298N motor driver inputs to control the DC motors. The pins in1 and in2 control one motor, and the pins in3 and in4 control the other motor.\n\n```arduino\nint servo1 = 90;\nint servo2 = 0;\nint servo3 = 90;\nint bt_data;\nint Speed = 130;\n```\n\nInitial positions (angles) for the three servos are set: servo1, servo2, and servo3. bt_data is used to store incoming Bluetooth data. Speed is initially set to 130.\n\n```arduino\nvoid setup(){\nSerial.begin(9600); // initialize serial communication at 9600 bits per second:\nmotor_1.attach(5);   // Waist Servo\nmotor_2.attach(6);   // Shoulder Servo\nmotor_3.attach(3);   // Gripper Servo\nmotor_1.write(servo1);\nmotor_2.write(servo2);\nmotor_3.write(servo3);\n//pinMode(enA, OUTPUT); // declare as output for L298 Pin enA\npinMode(in1, OUTPUT); // declare as output for L298 Pin in1\npinMode(in2, OUTPUT); // declare as output for L298 Pin in2\npinMode(in3, OUTPUT); // declare as output for L298 Pin in3  \npinMode(in4, OUTPUT); // declare as output for L298 Pin in4\n//pinMode(enB, OUTPUT); // declare as output for L298 Pin enB\ndigitalWrite(in1, LOW); //Right Motor forword Pin\ndigitalWrite(in2, LOW); //Right Motor backword Pin\ndigitalWrite(in3, LOW); //Left Motor backword Pin\ndigitalWrite(in4, LOW); //Left Motor forword Pin\ndelay(1000);\n}\n```\n\nIn the setup() function, serial communication is initialized at 9600 bits per second. The servo motors are attached to specific pins, and their initial positions are set. The digital pins for motor control and the motor driver pins are set as outputs. The motor driver pins are initially set to low to ensure the motors are not moving during setup.\n\n```arduino\nvoid loop(){\n//if some date is sent, reads it and saves in state\nif(Serial.available() > 0){    \nbt_data = Serial.read();\nSerial.println(bt_data);\nif(bt_data > 20)\n{Speed = bt_data;}      \n}\n```\n\nThe loop function is where the main program logic runs in a continuous loop.\n\nThis code block reads incoming Bluetooth data from the serial connection. If the received data is greater than 20, it updates the Speed variable.\n\n```arduino\nif(bt_data == 1)\n  {forword(); }  // if the bt_data is '1' the DC motor will go forward\nelse if(bt_data == 2)\n  {backword();}  // if the bt_data is '2' the motor will Reverse\nelse if(bt_data == 3)\n  {turnLeft();}  // if the bt_data is '3' the motor will turn left\nelse if(bt_data == 4)\n  {turnRight();} // if the bt_data is '4' the motor will turn right\nelse if(bt_data == 5)\n  {Stop(); }     // if the bt_data '5' the motor will Stop\n```\n\nThese conditional statements check the value of bt_data and call corresponding functions (forword, backword, turnLeft, turnRight, Stop) based on the received data.\n\n```arduino\nelse if (bt_data == 8){\nif(servo1<180){servo1 = servo1+1;}\nmotor_1.write(servo1);  \n}\nelse if (bt_data == 9){\nif(servo1>0){servo1 = servo1-1;}\nmotor_1.write(servo1);  \n}\nelse if (bt_data == 10){\nif(servo2>0){servo2 = servo2-1;}\nmotor_2.write(servo2);\n}\nelse if (bt_data == 11){\nif(servo2<180){servo2 = servo2+1;}\nmotor_2.write(servo2);  \n}\nelse if (bt_data == 16){\nif(servo3>60){servo3 = servo3-1;}\nmotor_3.write(servo3);\n}\nelse if (bt_data == 17){\nif(servo3<150){servo3 = servo3+1;}\nmotor_3.write(servo3);\n}\ndelay(30);\n}\n```\n\nThese conditional statements adjust the position of the waist servo (motor_1) based on the received Bluetooth data.\n\nThe remaining else if blocks adjust the positions of the shoulder and gripper servos (motor_2 and motor_3) similarly.\n\ndelay introduces a short pause between iterations of the loop function to prevent rapid and continuous execution.\n\n```arduino\nvoid forword(){  //forword\ndigitalWrite(in1, HIGH);   //Right Motor forword Pin\ndigitalWrite(in2, LOW);   //Right Motor backword Pin\ndigitalWrite(in3, HIGH);  //Left Motor forward Pin\ndigitalWrite(in4, LOW);   //Left Motor backward Pin\n}\nvoid backword(){ //backword\ndigitalWrite(in1, LOW);  \ndigitalWrite(in2, HIGH);\ndigitalWrite(in3, LOW);\ndigitalWrite(in4, HIGH);  \n}\nvoid turnRight(){ //turnRight\ndigitalWrite(in1, LOW);  \ndigitalWrite(in2, HIGH);  \ndigitalWrite(in3, HIGH);  \ndigitalWrite(in4, LOW);\n}\nvoid turnLeft(){ //turnLeft\ndigitalWrite(in1, HIGH);\ndigitalWrite(in2, LOW);  \ndigitalWrite(in3, LOW);\ndigitalWrite(in4, HIGH);  \n}\nvoid Stop(){ //stop\ndigitalWrite(in1, LOW);\ndigitalWrite(in2, LOW);  \ndigitalWrite(in3, LOW);\ndigitalWrite(in4, LOW);\n}\n```\n\nThese functions (forword, backword, turnLeft, turnRight, Stop) define the movements of the robot based on the motor driver pins' states.\n\nThese functions control the direction of the motors to achieve the desired movement.\n\nBy organizing the code in this way, we can modularize the functionality and make it easier to understand and maintain. The conditional statements ensure that the appropriate movement function is executed when the corresponding condition is met based on the received data.\n\n# Android App for Controlling Robotic Arm Car\n\nIn Playstore there are a lot of different app’s for controlling Robot Arm. But for this project I am creating my own Android app with the help of MIT App Inventor.\n\nYou can download the App .apk file for Bluetooth:\n\nTo connect the Bluetooth-controlled robotic arm Car with your phone, follow these steps:\n\nOpen the \"Robotic Arm Car\" app on your Android device. Please note that currently, this app is not available for iOS users.\n\nOpen the \"Robotic Arm Car\" app on your Android device. Please note that currently, this app is not available for iOS users.\n\nTurn on the Bluetooth on your phone by going to your phone's settings.\n\nTurn on the Bluetooth on your phone by going to your phone's settings.\n\nConnect your phone to the HC-05 Bluetooth module. If you have a new HC-05 module, there is an additional step before connecting.\n\nConnect your phone to the HC-05 Bluetooth module. If you have a new HC-05 module, there is an additional step before connecting.\n\nGo to the Bluetooth settings on your phone.\n\nGo to the Bluetooth settings on your phone.\n\nSearch for Bluetooth devices.\n\nSearch for Bluetooth devices.\n\nYou will find a Bluetooth device named HC-05.\n\nYou will find a Bluetooth device named HC-05.\n\nPair the Bluetooth device with your phone by selecting it.\n\nPair the Bluetooth device with your phone by selecting it.\n\nDuring the pairing process, you will be prompted to enter a password.\n\nDuring the pairing process, you will be prompted to enter a password.\n\nThe default password for HC-05 is usually either 1234 or 0000.\n\nThe default password for HC-05 is usually either 1234 or 0000.\n\nEnter the password and proceed with the pairing process.\n\nEnter the password and proceed with the pairing process.\n\nOnce the pairing is successful, your Bluetooth-controlled robotic arm Car is now connected to your Android device.\n\nOnce the pairing is successful, your Bluetooth-controlled robotic arm Car is now connected to your Android device.\n\nThis app features a total of 10 control buttons, designed to facilitate seamless interaction. Four of these buttons are dedicated to directing the robot's movements—forward, backward, right, and left. The remaining six buttons are specifically allocated for fine-tuning the angles of the robotic arm servos.\n\nOnce the HC-05 Bluetooth module is properly paired with an Android phone using our dedicated app, the user can effortlessly activate these control buttons. Upon pressing a control key, the Android phone promptly sends and receives the corresponding value, ensuring precise and responsive control over the robot and its robotic arm.\n\n# Conclusion\n\nModeling an Arm robot manipulator is complicated work, starting from how it moves in kinematics, and how much energy is needed in dynamics. Building a Bluetooth-controlled robotic arm with Arduino provides a hands-on introduction to robotics and automation. This project presents the design of a 2 DOF manipulator robot prototype for the application of lifting and moving light material objects with the help of a Gripper. By combining servos, a motor driver, and Bluetooth communication, enthusiasts can create a versatile and interactive mechanical system. This project not only demonstrates the fusion of hardware and software but also serves as a stepping stone to more complex robotic endeavors. Whether you're an aspiring engineer or simply curious about robotics, this project offers an exciting and educational journey into the world of automation.\n\n# Complete Project Code\n\n```arduino\nCode #1\n\n#include     // include servo library\n// Define 3 Servos\nServo myServo1; // waist or base Servo\nServo myServo2; // shoulder Servo\nServo myServo3; // gripper Servo\nvoid setup() {\n // Attach servos to Arduino PWM Pins\n  myServo1.attach(5);\n  myServo2.attach(6);\n  myServo3.attach(3);\n  myServo1.write(90);\n  myServo2.write(90);\n  myServo3.write(90);\n}\n void loop() {\n}\n\n \nCode #2\n\n#include <Servo.h>\n\nServo motor_1;      \nServo motor_2;\nServo motor_3;\n\n//#define enA 9  //Enable1 L298 Pin enA \n#define in1 7 //Motor1  L298 Pin in1 \n#define in2 8 //Motor1  L298 Pin in1 \n#define in3 12 //Motor2  L298 Pin in1 \n#define in4 11 //Motor2  L298 Pin in1 \n//#define enB 9  //Enable2 L298 Pin enB \n\nint servo1 = 90;\nint servo2 = 0;\nint servo3 = 90;\n\nint bt_data;\nint Speed = 130;\n\nvoid setup(){\n  \nSerial.begin(9600); // initialize serial communication at 9600 bits per second:\n \nmotor_1.attach(5);   // Waist Servo\nmotor_2.attach(6);   // Shoulder Servo\nmotor_3.attach(3);   // Gripper Servo\n \nmotor_1.write(servo1); \nmotor_2.write(servo2); \nmotor_3.write(servo3); \n\n//pinMode(enA, OUTPUT); // declare as output for L298 Pin enA \npinMode(in1, OUTPUT); // declare as output for L298 Pin in1 \npinMode(in2, OUTPUT); // declare as output for L298 Pin in2 \npinMode(in3, OUTPUT); // declare as output for L298 Pin in3   \npinMode(in4, OUTPUT); // declare as output for L298 Pin in4 \n//pinMode(enB, OUTPUT); // declare as output for L298 Pin enB\n\ndigitalWrite(in1, LOW); //Right Motor forword Pin \ndigitalWrite(in2, LOW); //Right Motor backword Pin \ndigitalWrite(in3, LOW); //Left Motor backword Pin \ndigitalWrite(in4, LOW); //Left Motor forword Pin \n\ndelay(1000);\n}\n\nvoid loop(){\n//if some date is sent, reads it and saves in state\n\nif(Serial.available() > 0){     \nbt_data = Serial.read(); \nSerial.println(bt_data);\nif(bt_data > 20)\n{Speed = bt_data;}      \n}\n\n//analogWrite(enA, Speed); // Write The Duty Cycle 0 to 255 Enable Pin A for Motor1 Speed \n//analogWrite(enB, Speed); // Write The Duty Cycle 0 to 255 Enable Pin B for Motor2 Speed \n\n\nif(bt_data == 1)\n  {forword(); }  // if the bt_data is '1' the DC motor will go forward\nelse if(bt_data == 2)\n  {backword();}  // if the bt_data is '2' the motor will Reverse\nelse if(bt_data == 3)\n  {turnLeft();}  // if the bt_data is '3' the motor will turn left\nelse if(bt_data == 4)\n  {turnRight();} // if the bt_data is '4' the motor will turn right\nelse if(bt_data == 5)\n  {Stop(); }     // if the bt_data '5' the motor will Stop\n\n\n\nelse if (bt_data == 8){\nif(servo1<180){servo1 = servo1+1;}\nmotor_1.write(servo1);  \n}\nelse if (bt_data == 9){\nif(servo1>0){servo1 = servo1-1;} \nmotor_1.write(servo1);  \n}\n\nelse if (bt_data == 10){\nif(servo2>0){servo2 = servo2-1;}\nmotor_2.write(servo2);\n}\nelse if (bt_data == 11){\nif(servo2<180){servo2 = servo2+1;}\nmotor_2.write(servo2);  \n}\n\nelse if (bt_data == 16){\nif(servo3>60){servo3 = servo3-1;}\nmotor_3.write(servo3);\n}\nelse if (bt_data == 17){\nif(servo3<150){servo3 = servo3+1;}\nmotor_3.write(servo3);\n}\n\ndelay(30);\n}\n\n\nvoid forword(){  //forword\ndigitalWrite(in1, HIGH);   //Right Motor forword Pin \ndigitalWrite(in2, LOW);   //Right Motor backword Pin \ndigitalWrite(in3, HIGH);  //Left Motor forward Pin \ndigitalWrite(in4, LOW);   //Left Motor backward Pin \n}\n\nvoid backword(){ //backword\ndigitalWrite(in1, LOW);  \ndigitalWrite(in2, HIGH); \ndigitalWrite(in3, LOW); \ndigitalWrite(in4, HIGH);  \n}\n\nvoid turnRight(){ //turnRight\ndigitalWrite(in1, LOW);  \ndigitalWrite(in2, HIGH);  \ndigitalWrite(in3, HIGH);   \ndigitalWrite(in4, LOW); \n}\n\nvoid turnLeft(){ //turnLeft\ndigitalWrite(in1, HIGH); \ndigitalWrite(in2, LOW);   \ndigitalWrite(in3, LOW); \ndigitalWrite(in4, HIGH);   \n}\n\nvoid Stop(){ //stop\ndigitalWrite(in1, LOW); \ndigitalWrite(in2, LOW);  \ndigitalWrite(in3, LOW); \ndigitalWrite(in4, LOW); \n}\n```\n\n```arduino\nCode #1\n\n#include     // include servo library\n// Define 3 Servos\nServo myServo1; // waist or base Servo\nServo myServo2; // shoulder Servo\nServo myServo3; // gripper Servo\nvoid setup() {\n // Attach servos to Arduino PWM Pins\n  myServo1.attach(5);\n  myServo2.attach(6);\n  myServo3.attach(3);\n  myServo1.write(90);\n  myServo2.write(90);\n  myServo3.write(90);\n}\n void loop() {\n}\n\n \nCode #2\n\n#include <Servo.h>\n\nServo motor_1;      \nServo motor_2;\nServo motor_3;\n\n//#define enA 9  //Enable1 L298 Pin enA \n#define in1 7 //Motor1  L298 Pin in1 \n#define in2 8 //Motor1  L298 Pin in1 \n#define in3 12 //Motor2  L298 Pin in1 \n#define in4 11 //Motor2  L298 Pin in1 \n//#define enB 9  //Enable2 L298 Pin enB \n\nint servo1 = 90;\nint servo2 = 0;\nint servo3 = 90;\n\nint bt_data;\nint Speed = 130;\n\nvoid setup(){\n  \nSerial.begin(9600); // initialize serial communication at 9600 bits per second:\n \nmotor_1.attach(5);   // Waist Servo\nmotor_2.attach(6);   // Shoulder Servo\nmotor_3.attach(3);   // Gripper Servo\n \nmotor_1.write(servo1); \nmotor_2.write(servo2); \nmotor_3.write(servo3); \n\n//pinMode(enA, OUTPUT); // declare as output for L298 Pin enA \npinMode(in1, OUTPUT); // declare as output for L298 Pin in1 \npinMode(in2, OUTPUT); // declare as output for L298 Pin in2 \npinMode(in3, OUTPUT); // declare as output for L298 Pin in3   \npinMode(in4, OUTPUT); // declare as output for L298 Pin in4 \n//pinMode(enB, OUTPUT); // declare as output for L298 Pin enB\n\ndigitalWrite(in1, LOW); //Right Motor forword Pin \ndigitalWrite(in2, LOW); //Right Motor backword Pin \ndigitalWrite(in3, LOW); //Left Motor backword Pin \ndigitalWrite(in4, LOW); //Left Motor forword Pin \n\ndelay(1000);\n}\n\nvoid loop(){\n//if some date is sent, reads it and saves in state\n\nif(Serial.available() > 0){     \nbt_data = Serial.read(); \nSerial.println(bt_data);\nif(bt_data > 20)\n{Speed = bt_data;}      \n}\n\n//analogWrite(enA, Speed); // Write The Duty Cycle 0 to 255 Enable Pin A for Motor1 Speed \n//analogWrite(enB, Speed); // Write The Duty Cycle 0 to 255 Enable Pin B for Motor2 Speed \n\n\nif(bt_data == 1)\n  {forword(); }  // if the bt_data is '1' the DC motor will go forward\nelse if(bt_data == 2)\n  {backword();}  // if the bt_data is '2' the motor will Reverse\nelse if(bt_data == 3)\n  {turnLeft();}  // if the bt_data is '3' the motor will turn left\nelse if(bt_data == 4)\n  {turnRight();} // if the bt_data is '4' the motor will turn right\nelse if(bt_data == 5)\n  {Stop(); }     // if the bt_data '5' the motor will Stop\n\n\n\nelse if (bt_data == 8){\nif(servo1<180){servo1 = servo1+1;}\nmotor_1.write(servo1);  \n}\nelse if (bt_data == 9){\nif(servo1>0){servo1 = servo1-1;} \nmotor_1.write(servo1);  \n}\n\nelse if (bt_data == 10){\nif(servo2>0){servo2 = servo2-1;}\nmotor_2.write(servo2);\n}\nelse if (bt_data == 11){\nif(servo2<180){servo2 = servo2+1;}\nmotor_2.write(servo2);  \n}\n\nelse if (bt_data == 16){\nif(servo3>60){servo3 = servo3-1;}\nmotor_3.write(servo3);\n}\nelse if (bt_data == 17){\nif(servo3<150){servo3 = servo3+1;}\nmotor_3.write(servo3);\n}\n\ndelay(30);\n}\n\n\nvoid forword(){  //forword\ndigitalWrite(in1, HIGH);   //Right Motor forword Pin \ndigitalWrite(in2, LOW);   //Right Motor backword Pin \ndigitalWrite(in3, HIGH);  //Left Motor forward Pin \ndigitalWrite(in4, LOW);   //Left Motor backward Pin \n}\n\nvoid backword(){ //backword\ndigitalWrite(in1, LOW);  \ndigitalWrite(in2, HIGH); \ndigitalWrite(in3, LOW); \ndigitalWrite(in4, HIGH);  \n}\n\nvoid turnRight(){ //turnRight\ndigitalWrite(in1, LOW);  \ndigitalWrite(in2, HIGH);  \ndigitalWrite(in3, HIGH);   \ndigitalWrite(in4, LOW); \n}\n\nvoid turnLeft(){ //turnLeft\ndigitalWrite(in1, HIGH); \ndigitalWrite(in2, LOW);   \ndigitalWrite(in3, LOW); \ndigitalWrite(in4, HIGH);   \n}\n\nvoid Stop(){ //stop\ndigitalWrite(in1, LOW); \ndigitalWrite(in2, LOW);  \ndigitalWrite(in3, LOW); \ndigitalWrite(in4, LOW); \n}\n```\n\n```arduino\n#include     // include servo library\n// Define 3 Servos\nServo myServo1; // waist or base Servo\nServo myServo2; // shoulder Servo\nServo myServo3; // gripper Servo\nvoid setup() {\n // Attach servos to Arduino PWM Pins\n  myServo1.attach(5);\n  myServo2.attach(6);\n  myServo3.attach(3);\n  myServo1.write(90);\n  myServo2.write(90);\n  myServo3.write(90);\n}\n void loop() {\n}\n```\n\n```arduino\n#include <Servo.h>\n\nServo motor_1;      \nServo motor_2;\nServo motor_3;\n\n//#define enA 9  //Enable1 L298 Pin enA \n#define in1 7 //Motor1  L298 Pin in1 \n#define in2 8 //Motor1  L298 Pin in1 \n#define in3 12 //Motor2  L298 Pin in1 \n#define in4 11 //Motor2  L298 Pin in1 \n//#define enB 9  //Enable2 L298 Pin enB \n\nint servo1 = 90;\nint servo2 = 0;\nint servo3 = 90;\n\nint bt_data;\nint Speed = 130;\n\nvoid setup(){\n  \nSerial.begin(9600); // initialize serial communication at 9600 bits per second:\n \nmotor_1.attach(5);   // Waist Servo\nmotor_2.attach(6);   // Shoulder Servo\nmotor_3.attach(3);   // Gripper Servo\n \nmotor_1.write(servo1); \nmotor_2.write(servo2); \nmotor_3.write(servo3); \n\n//pinMode(enA, OUTPUT); // declare as output for L298 Pin enA \npinMode(in1, OUTPUT); // declare as output for L298 Pin in1 \npinMode(in2, OUTPUT); // declare as output for L298 Pin in2 \npinMode(in3, OUTPUT); // declare as output for L298 Pin in3   \npinMode(in4, OUTPUT); // declare as output for L298 Pin in4 \n//pinMode(enB, OUTPUT); // declare as output for L298 Pin enB\n\ndigitalWrite(in1, LOW); //Right Motor forword Pin \ndigitalWrite(in2, LOW); //Right Motor backword Pin \ndigitalWrite(in3, LOW); //Left Motor backword Pin \ndigitalWrite(in4, LOW); //Left Motor forword Pin \n\ndelay(1000);\n}\n\nvoid loop(){\n//if some date is sent, reads it and saves in state\n\nif(Serial.available() > 0){     \nbt_data = Serial.read(); \nSerial.println(bt_data);\nif(bt_data > 20)\n{Speed = bt_data;}      \n}\n\n//analogWrite(enA, Speed); // Write The Duty Cycle 0 to 255 Enable Pin A for Motor1 Speed \n//analogWrite(enB, Speed); // Write The Duty Cycle 0 to 255 Enable Pin B for Motor2 Speed \n\n\nif(bt_data == 1)\n  {forword(); }  // if the bt_data is '1' the DC motor will go forward\nelse if(bt_data == 2)\n  {backword();}  // if the bt_data is '2' the motor will Reverse\nelse if(bt_data == 3)\n  {turnLeft();}  // if the bt_data is '3' the motor will turn left\nelse if(bt_data == 4)\n  {turnRight();} // if the bt_data is '4' the motor will turn right\nelse if(bt_data == 5)\n  {Stop(); }     // if the bt_data '5' the motor will Stop\n\n\n\nelse if (bt_data == 8){\nif(servo1<180){servo1 = servo1+1;}\nmotor_1.write(servo1);  \n}\nelse if (bt_data == 9){\nif(servo1>0){servo1 = servo1-1;} \nmotor_1.write(servo1);  \n}\n\nelse if (bt_data == 10){\nif(servo2>0){servo2 = servo2-1;}\nmotor_2.write(servo2);\n}\nelse if (bt_data == 11){\nif(servo2<180){servo2 = servo2+1;}\nmotor_2.write(servo2);  \n}\n\nelse if (bt_data == 16){\nif(servo3>60){servo3 = servo3-1;}\nmotor_3.write(servo3);\n}\nelse if (bt_data == 17){\nif(servo3<150){servo3 = servo3+1;}\nmotor_3.write(servo3);\n}\n\ndelay(30);\n}\n\n\nvoid forword(){  //forword\ndigitalWrite(in1, HIGH);   //Right Motor forword Pin \ndigitalWrite(in2, LOW);   //Right Motor backword Pin \ndigitalWrite(in3, HIGH);  //Left Motor forward Pin \ndigitalWrite(in4, LOW);   //Left Motor backward Pin \n}\n\nvoid backword(){ //backword\ndigitalWrite(in1, LOW);  \ndigitalWrite(in2, HIGH); \ndigitalWrite(in3, LOW); \ndigitalWrite(in4, HIGH);  \n}\n\nvoid turnRight(){ //turnRight\ndigitalWrite(in1, LOW);  \ndigitalWrite(in2, HIGH);  \ndigitalWrite(in3, HIGH);   \ndigitalWrite(in4, LOW); \n}\n\nvoid turnLeft(){ //turnLeft\ndigitalWrite(in1, HIGH); \ndigitalWrite(in2, LOW);   \ndigitalWrite(in3, LOW); \ndigitalWrite(in4, HIGH);   \n}\n\nvoid Stop(){ //stop\ndigitalWrite(in1, LOW); \ndigitalWrite(in2, LOW);  \ndigitalWrite(in3, LOW); \ndigitalWrite(in4, LOW); \n}\n```\n\n# Start a Discussion on:\n\n# Comments\n\nHi, Can you share the MIT App Inventor FIle to create app for more servo motors\n\nLog in or register to post comments\n\nHola amigos, gran trabajo. Estoy armando un brazo robotico de 4 servomotres mg995, para cintura, hombro, codo y pinzas. Busco algo justo asi, ya que tengo un tanque y un carro arduino de 6 motores y queria unirlos. Mi pregunta es sobre el codigo, si me podian facilitar un codigo pero para controlar 4 servomotores. Muchas gracias\n\nLog in or register to post comments\n\nIn reply to Hola amigos, gran trabajo… by javierfelpete\n\nYou can use the same code, just define an additional servo and modify the app accordingly.\n\nLog in or register to post comments\n\n# Add New Comment\n\nLog in or register to post comments"}
{"title":"Build your own Mars Rover Robot using Arduino","content":"The planet Mars has captivated our imagination for centuries, and the idea of sending rovers to explore its surface has fueled our curiosity even further. In this project, we will delve into the exciting world of robotics and demonstrate how to build an Arduino-based mars rover capable of traversing various terrains. So, fasten your seatbelt as we embark on this thrilling journey of constructing our very own Mars rover.\n\nIn this article, our focus is on creating an Arduino Bluetooth-controlled Mars rover. Arduino proves to be a valuable and cost-effective option for hobbyists acting like a miniature computer. This guide aims to providing a clear step-by-step explanation from building a rover chassis to its programming and testing. Our primary task involves coding instruction, which are written in C or C++ programming language. The Arduino microcontroller compiles and executes the code, enabling the rover to function according to our desired specifications.\n\nWe also have a dedicated Arduino robotics section, where you can find all kind of Arduino robotics projects like line follower robot, fire fighting robot, robotic arm, self balancing robot etc.\n\n# Understanding Mars Rover Design\n\nBefore we dive into the technical aspects, let’s take a moment to understand the design consideration of a Mars rover. A typical mars rover needs to navigate challenging landscape on the Martian surface. To achieve this, we will focus on building a rover with the 6-wheels drive system with appropriate suspension ensure optimal mobility and stability for the rover.\n\nThe rover chassis serves as the foundation for the entire vehicle. It needs to be sturdy, durable, and capable to traversing different terrains and should also accommodate the placement of various electronic components, such as the Arduino board, power supply, and motor control modules.\n\nI created acrylic chassis parts using SolidWorks and performed laser cutting to construct my Mars rover.\n\nI am attaching the .dxf files for the Mars rover project, which you can utilize for laser cutting. The video will demonstrate the assembly process for the Mars rover.\n\n# Necessary Components Needed for Mars Rover\n\nMars rover acrylic cutting chassis\n\nMars rover acrylic cutting chassis\n\n6 BO motors and wheels\n\n6 BO motors and wheels\n\nArduino Uno\n\nArduino Uno\n\nL298n motor driver module\n\nL298n motor driver module\n\nHC-05 Bluetooth module\n\nHC-05 Bluetooth module\n\n12V Li-ion battery with connecter\n\n12V Li-ion battery with connecter\n\nL clamp (8 nos.)\n\nL clamp (8 nos.)\n\nM4 10mm nuts and bolts (8 nos.)\n\nM4 10mm nuts and bolts (8 nos.)\n\nM3 10mm nuts and bolts (12 nos.)\n\nM3 10mm nuts and bolts (12 nos.)\n\nM3 30mm nuts and bolts (12 nos.)\n\nM3 30mm nuts and bolts (12 nos.)\n\nSwitch and connecting wires\n\nSwitch and connecting wires\n\n# L298N Motor Driver Module\n\nThe L298N motor driver module is a popular motor driver module commonly used in robotics and electronics projects. The module is based on the L298n integrated circuit, it has two H-bridge circuits, one for each motor channel, which enables bi-directional control of the motors. By providing appropriate logic signals to the module’s control pins, you can control the motor’s speed and direction.\n\nSince we are not using the PWM signal generated by the Arduino to control the speed of the motors, they will operate at their maximum speed. This is because we keep the ENA and ENB pins, which correspond to the PWM control, in a fixed state on the board. Therefore, the main purpose of the motor driver module in this setup is to change the direction of rotation of the motors. This capability enables the robot to move in all four directions, including forward, backward, left, and right.\n\n# L298N Motor Driver Pinout\n\nThe L298N motor driver module has a specific pinout that corresponds to its various functionalities. Here is the pinout description of the L298N motor driver module. If you are completely new to this motor driver module check out our article on how to use L298N with Arduino for a detailed understanding.\n\nVCC This pin is used to connect an external power source (up to 12V) to power the motors.\n\nGND This pin is the ground connection for the module and should be connected to the ground of the power source and the control signal source (Arduino).\n\n5V This pin provides a regulated 5V output that can be used to power external components or provide logic voltage to the control signal source.\n\nENA & ENB This pin is used to enable or disable the motor connected to Channel A and Channel B. It is responsible for controlling the speed of the motor through PWM (Pulse Width Modulation) signals.\n\nIN1, IN2, IN3, IN4 This input pin is used to control the direction of rotation for the motor connected to Channel A, similarly IN3 & IN4 for Channel B. By providing appropriate logic levels (HIGH or LOW), you can set the desired direction. This pins are connected to Arduino digital pins for receiving (HIGH or LOW) signal.\n\nOUT-1 & OUT-2 The pin mentioned is intended for connecting the motors. Specifically, one motor should be connected to OUT-1 & OUT-2 while the other motor should be connected to OUT-3 & OUT-4 . It is important to note that the motors can be connected within a voltage range of 5V to 35V. However, it's worth considering that there will be an approximate 2-volt reduction in the output voltage compared to the voltage applied to the Vcc pin.\n\n# HC-05 Bluetooth Module\n\nThe HC-05 is a widely used Bluetooth module that provides a convenient and reliable way to add wireless communication capabilities to electronic devices. It supports serial communication via UART (Universal Asynchronous Receiver-Transmitter) protocol.\n\nThe HC-05 module supports the Bluetooth version 2.0 specification and can be configured as a Master or Slave device through AT commands, depending on the desired application. In the Master mode, it can initiate connections with other Bluetooth devices, while in the Slave mode, it can accept incoming connections.\n\n# HC-05 Pinout\n\nThe HC-05 Bluetooth module has a specific pinout that corresponds to its various functionalities. Here is the pinout description of the HC-05 Bluetooth module.\n\nVCC This pin is used to provide power to the module. It typically operates at a voltage range of 3.3V to 6V.\n\nGND This pin is the ground connection for the module and should be connected to the ground of the power source and the control signal source.\n\nTXD This pin is the transmit data pin and is used to send data from the module to another device. It should be connected to the receive pin (RX) of the receiving device.\n\nRXD This pin is the receive data pin and is used to receive data from another device. It should be connected to the transmit pin (TX) of the transmitting device.\n\nSTATE This pin is an optional pin that can be used to check the state of the module. It can be configured to provide information about the module's connection status or other relevant information.\n\nEN This pin is used to enable or disable the module (Command & Data mode). When this pin is pulled HIGH (3.3V or 5V), the module is enabled (command mode), and when it is pulled LOW (0V or GND), the module is disabled (data mode).\n\n# Assemble the Mars Rover Chassis\n\nWe have utilized an acrylic sheet cut with a laser to create a chassis for our project. The sheet has been precisely cut to accommodate all the necessary fittings and components, allowing for easy assembly using screwdrivers.\n\nConnect back leg with front leg with the help of M4 10mm nuts and bolts\n\nConnect the pair of front and back leg with base plate with the help of L clamp with M3, M4 10mm nuts and bolts.\n\nAttached the motors with both legs to its appropriate location with M3 30mm nuts and bolts.\n\nPlaced all the electronics components to its suitable location with double side tape.\n\n# Arduino Bluetooth Controlled Mars Rover Circuit Diagram\n\nHere is the schematic of a Bluetooth-controlled Mars rover. In this design, we have a total of six motors, with three motors connected in parallel on the right side and three motors connected in parallel on the left side. This configuration allows all three motors on each side to operate synchronously, running at the same speed and in the same direction. By connecting them in parallel, we ensure that they receive the same control signals and power supply. This arrangement enables efficient and coordinated movement for the rover, enhancing its maneuverability and stability.\n\n# Connections:\n\nArduino and HC-05 Bluetooth Module:\n\nConnect the TX pin of the Bluetooth module to the RX pin (usually digital pin 0) of the Arduino.\n\nConnect the TX pin of the Bluetooth module to the RX pin (usually digital pin 0) of the Arduino.\n\nConnect the RX pin of the Bluetooth module to the TX pin (usually digital pin 1) of the Arduino.\n\nConnect the RX pin of the Bluetooth module to the TX pin (usually digital pin 1) of the Arduino.\n\nConnect the VCC and GND pins of the Bluetooth module to the appropriate power (+5V) and ground pins on the Arduino.\n\nConnect the VCC and GND pins of the Bluetooth module to the appropriate power (+5V) and ground pins on the Arduino.\n\nArduino and Motor Driver Module:\n\nConnect the digital output pins of the Arduino (digital pins 10, 9, 8, and 7) to the appropriate input pins (IN1, IN2, IN3, and IN4) on the motor driver module.\n\nConnect the digital output pins of the Arduino (digital pins 10, 9, 8, and 7) to the appropriate input pins (IN1, IN2, IN3, and IN4) on the motor driver module.\n\nConnect the ENA and ENB pins of the motor driver module to the on board High state pin with the help of female header.\n\nConnect the ENA and ENB pins of the motor driver module to the on board High state pin with the help of female header.\n\nConnect the OUT1, OUT2, OUT3, and OUT4 pins of the motor driver module to the appropriate terminals of the motors.\n\nConnect the OUT1, OUT2, OUT3, and OUT4 pins of the motor driver module to the appropriate terminals of the motors.\n\nConnect the VCC (+5V) and GND pins of the motor driver module to the appropriate power (Vin) and ground (GND) connections on the Arduino.\n\nConnect the VCC (+5V) and GND pins of the motor driver module to the appropriate power (Vin) and ground (GND) connections on the Arduino.\n\nPower Supply:\n\nConnect the positive terminal of the power supply to the +12V input of the motor driver module.\n\nConnect the positive terminal of the power supply to the +12V input of the motor driver module.\n\nConnect the negative terminal of the power supply to the GND pin of the motor driver module.\n\nConnect the negative terminal of the power supply to the GND pin of the motor driver module.\n\nConnect the GND pin of the Arduino to the GND pin of the motor driver module.\n\nConnect the GND pin of the Arduino to the GND pin of the motor driver module.\n\n# Code Explanation\n\nHere is the simple Bluetooth control Mars rover code that you can use for your project.\n\nPin configuration: The pins on the Arduino board that are connected to the motor driver module and other components are defined. This step ensures that the correct pins are used for motor control and other operations.\n\nWe have defined the IN1, IN2, IN3 & IN4 pins as 10,9,8 & 7 digital pins of the Arduino. This pins are connected to input pins of motor driver module.\n\n```arduino\nint state=0;\nconst int motorpin11=10;  // L298n #NI1\nconst int motorpin12=9;   // L298n #NI2\nconst int motorpin21=8;   // L298n #NI3\nconst int motorpin22=7;   // L298n #NI4\n```\n\nSetup: The setup function runs only once at the beginning of the code execution. It is responsible for configuring the communication protocols, setting the pin modes, and initializing variables\n\nWithin the setup() function, we begin by initializing the hardware serial communication with a baud rate of 9600. This allows the Arduino to establish communication with external devices, such as the Bluetooth module, at the specified data transmission rate.\n\nNext, we set the pin modes for the direction control pins used for motor control. These pins are configured to control the movement and direction of the motors. By setting them initially to LOW, we ensure that the motors are in a halted state at the start of the program execution. This prevents any unintended movement of the motors before receiving any commands or instructions.\n\nInitializing the hardware serial communication and setting the appropriate pin modes are crucial steps in preparing the Arduino for proper motor control and ensuring that the initial motor state is controlled and stationary.\n\n```arduino\nvoid setup() {\n  Serial.begin(9600); \n  pinMode(motorpin11,OUTPUT);\n  pinMode(motorpin12,OUTPUT);\n  pinMode(motorpin21,OUTPUT);\n  pinMode(motorpin22,OUTPUT);\n  digitalWrite(motorpin11,LOW);\n  digitalWrite(motorpin12,LOW);\n  digitalWrite(motorpin21,LOW);\n  digitalWrite(motorpin22,LOW);\n}\n```\n\nLoop: The loop function runs continuously after the setup is complete. It includes the main logic of the program, defining the behavior of the Mars Rover based on the received commands.\n\nThe loop() function continuously checks for incoming commands from the Bluetooth module. Depending on the received command, the rover will move forward, backward, turn left, turn right, or stop.\n\nThe code listens for incoming Bluetooth signals and receives commands from a paired device. This could include instructions for moving forward, backward, turning left or right, or stopping the rover.\n\n```arduino\nvoid loop()\n  { if (Serial.available()>0)\n  state=Serial.read();\n{\n```\n\nThe received commands are translated into appropriate motor control signals. The code sends the necessary signals to the motor driver module, adjusting the directions according to the instructions.\n\n```arduino\nif (state=='F') {\n    digitalWrite(motorpin11,HIGH);\n    digitalWrite(motorpin12,LOW);     // Forward motion of rover\n    digitalWrite(motorpin21,HIGH);\n    digitalWrite(motorpin22,LOW);\n  }     \n   else if(state=='B') {\n      digitalWrite(motorpin11,LOW);\n      digitalWrite(motorpin12,HIGH);   // Backward motion of rover\n      digitalWrite(motorpin21,LOW);\n      digitalWrite(motorpin22,HIGH);\n      }\n      else if(state=='S') {\n        digitalWrite(motorpin11,LOW);\n        digitalWrite(motorpin12,LOW);     // Stop\n        digitalWrite(motorpin21,LOW);\n        digitalWrite(motorpin22,LOW);\n        }\n        else if(state=='L') {\n        digitalWrite(motorpin11,HIGH);\n        digitalWrite(motorpin12,LOW);     // Left motion of rover\n        digitalWrite(motorpin21,LOW);\n        digitalWrite(motorpin22,HIGH);\n        }\n        else if(state=='R')\n      {\n        digitalWrite(motorpin11,LOW);\n        digitalWrite(motorpin12,HIGH);     // Right motion of rover\n        digitalWrite(motorpin21,HIGH);\n        digitalWrite(motorpin22,LOW);\n        }\n        else if(state=='l')\n      {\n        digitalWrite(motorpin11,LOW);\n        digitalWrite(motorpin12,HIGH);    // Backward Left motion of rover\n        digitalWrite(motorpin21,HIGH);\n        digitalWrite(motorpin22,LOW);\n        }\n        else if(state=='r')\n      {\n        digitalWrite(motorpin11,HIGH);\n        digitalWrite(motorpin12,LOW);     // Backward Right motion of rover\n        digitalWrite(motorpin21,LOW);\n        digitalWrite(motorpin22,HIGH);\n        }\n  }}\n```\n\nThe received data is being compared using if and else if statements, allowing for conditional execution of specific statements based on the evaluation of these conditions.\n\nWithin these conditional statements, we have defined seven different movement functions that correspond to various actions for the Mars Rover. These functions are called inside the if statements based on the specific conditions met. Each function is responsible for controlling a specific movement, such as moving forward, backward, turning left or right, stopping, backward left and backward right.\n\nBy organizing the code in this way, we can modularize the functionality and make it easier to understand and maintain. The conditional statements ensure that the appropriate movement function is executed when the corresponding condition is met based on the received data.\n\nIn summary, the if and else if statements enable the code to evaluate the received data and execute the corresponding movement function based on the condition met, facilitating precise control and maneuverability of the Mars Rover.\n\n# Setup the Android App for controlling Mars Rover\n\nTo connect the Bluetooth-controlled car with your phone, follow these steps:\n\nOpen the \"Bluetooth RC Car\" app on your Android device. Please note that currently, this app is only available for Android users.\n\nOpen the \"Bluetooth RC Car\" app on your Android device. Please note that currently, this app is only available for Android users.\n\nTurn on the Bluetooth on your phone by going to your phone's settings.\n\nTurn on the Bluetooth on your phone by going to your phone's settings.\n\nConnect your phone to the HC-05 Bluetooth module. If you have a new HC-05 module, there is an additional step before connecting.\n\nConnect your phone to the HC-05 Bluetooth module. If you have a new HC-05 module, there is an additional step before connecting.\n\nGo to the Bluetooth settings on your phone.\n\nGo to the Bluetooth settings on your phone.\n\nSearch for Bluetooth devices.\n\nSearch for Bluetooth devices.\n\nYou will find a Bluetooth device named HC-05.\n\nYou will find a Bluetooth device named HC-05.\n\nPair the Bluetooth device with your phone by selecting it.\n\nPair the Bluetooth device with your phone by selecting it.\n\nDuring the pairing process, you will be prompted to enter a password.\n\nDuring the pairing process, you will be prompted to enter a password.\n\nThe default password for HC-05 is usually either 1234 or 0000.\n\nThe default password for HC-05 is usually either 1234 or 0000.\n\nEnter the password and proceed with the pairing process.\n\nEnter the password and proceed with the pairing process.\n\nOnce the pairing is successful, your Bluetooth-controlled Mars rover is now connected to your Android device.\n\nOnce the pairing is successful, your Bluetooth-controlled Mars rover is now connected to your Android device.\n\nBy following these steps, you can establish a connection between your phone and the Bluetooth module of the Mars rover, allowing you to control the   wirelessly using the \"Bluetooth RC Car\" app.\n\n# Conclusion\n\nCongratulations! You have successfully built your Arduino-based Mars rover. Now, it's time to let it roam and explore. Take your rover to various terrains, conduct experiments, and gather valuable data. Control it wirelessly using a smartphone or other Bluetooth-enabled devices, and observe how it maneuvers through the challenges.\n\nBuilding an Arduino Mars rover offers a thrilling opportunity to delve into robotics, electronics, and programming. It allows us to simulate the exploration of distant planets and sparks our curiosity about the mysteries of the universe. So, grab your tools, unleash your creativity, and embark on this exciting journey of building and exploring with your very own Mars rover!\n\n# Complete Project Code\n\n```arduino\nint state=0;\nconst int motorpin11=10;  // L298n #NI1\nconst int motorpin12=9;   // L298n #NI2\nconst int motorpin21=8;   // L298n #NI3\nconst int motorpin22=7;   // L298n #NI4\nvoid setup() {\n  pinMode(motorpin11,OUTPUT);\n  pinMode(motorpin12,OUTPUT);\n  pinMode(motorpin21,OUTPUT);\n  pinMode(motorpin22,OUTPUT);\n  digitalWrite(motorpin11,LOW);\n  digitalWrite(motorpin12,LOW);\n  digitalWrite(motorpin21,LOW);\n  digitalWrite(motorpin22,LOW);\n  Serial.begin(9600);\n  }\n  void loop()  {\n  if (Serial.available()>0)\n  state=Serial.read();\n  {\n if (state=='F')\n     {\n    digitalWrite(motorpin11,HIGH);\n    digitalWrite(motorpin12,LOW);     // Forward motion of rover\n    digitalWrite(motorpin21,HIGH);\n    digitalWrite(motorpin22,LOW);\n  }\n   else if(state=='B')\n    {\n      digitalWrite(motorpin11,LOW);\n      digitalWrite(motorpin12,HIGH);   // Backward motion of rover\n      digitalWrite(motorpin21,LOW);\n      digitalWrite(motorpin22,HIGH);\n      }\n      else if(state=='S')\n      {\n        digitalWrite(motorpin11,LOW);\n        digitalWrite(motorpin12,LOW);     // Stop\n        digitalWrite(motorpin21,LOW);\n        digitalWrite(motorpin22,LOW);  \n        }\n        else if(state=='L')\n      {\n        digitalWrite(motorpin11,HIGH);\n        digitalWrite(motorpin12,LOW);     // Left motion of rover\n        digitalWrite(motorpin21,LOW);\n        digitalWrite(motorpin22,HIGH);\n        }\n        else if(state=='R')\n      {\n        digitalWrite(motorpin11,LOW);\n        digitalWrite(motorpin12,HIGH);     // Right motion of rover\n        digitalWrite(motorpin21,HIGH);\n        digitalWrite(motorpin22,LOW);\n        }\n        else if(state=='l')\n      {\n        digitalWrite(motorpin11,LOW);\n        digitalWrite(motorpin12,HIGH);    // Backward Left motion of rover\n        digitalWrite(motorpin21,HIGH);\n        digitalWrite(motorpin22,LOW);\n        }\n        else if(state=='r')\n      {\n        digitalWrite(motorpin11,HIGH);\n        digitalWrite(motorpin12,LOW);     // Backward Right motion of rover\n        digitalWrite(motorpin21,LOW);\n        digitalWrite(motorpin22,HIGH);\n        }\n  }}\n```\n\n```arduino\nint state=0;\nconst int motorpin11=10;  // L298n #NI1\nconst int motorpin12=9;   // L298n #NI2\nconst int motorpin21=8;   // L298n #NI3\nconst int motorpin22=7;   // L298n #NI4\nvoid setup() {\n  pinMode(motorpin11,OUTPUT);\n  pinMode(motorpin12,OUTPUT);\n  pinMode(motorpin21,OUTPUT);\n  pinMode(motorpin22,OUTPUT);\n  digitalWrite(motorpin11,LOW);\n  digitalWrite(motorpin12,LOW);\n  digitalWrite(motorpin21,LOW);\n  digitalWrite(motorpin22,LOW);\n  Serial.begin(9600);\n  }\n  void loop()  {\n  if (Serial.available()>0)\n  state=Serial.read();\n  {\n if (state=='F')\n     {\n    digitalWrite(motorpin11,HIGH);\n    digitalWrite(motorpin12,LOW);     // Forward motion of rover\n    digitalWrite(motorpin21,HIGH);\n    digitalWrite(motorpin22,LOW);\n  }\n   else if(state=='B')\n    {\n      digitalWrite(motorpin11,LOW);\n      digitalWrite(motorpin12,HIGH);   // Backward motion of rover\n      digitalWrite(motorpin21,LOW);\n      digitalWrite(motorpin22,HIGH);\n      }\n      else if(state=='S')\n      {\n        digitalWrite(motorpin11,LOW);\n        digitalWrite(motorpin12,LOW);     // Stop\n        digitalWrite(motorpin21,LOW);\n        digitalWrite(motorpin22,LOW);  \n        }\n        else if(state=='L')\n      {\n        digitalWrite(motorpin11,HIGH);\n        digitalWrite(motorpin12,LOW);     // Left motion of rover\n        digitalWrite(motorpin21,LOW);\n        digitalWrite(motorpin22,HIGH);\n        }\n        else if(state=='R')\n      {\n        digitalWrite(motorpin11,LOW);\n        digitalWrite(motorpin12,HIGH);     // Right motion of rover\n        digitalWrite(motorpin21,HIGH);\n        digitalWrite(motorpin22,LOW);\n        }\n        else if(state=='l')\n      {\n        digitalWrite(motorpin11,LOW);\n        digitalWrite(motorpin12,HIGH);    // Backward Left motion of rover\n        digitalWrite(motorpin21,HIGH);\n        digitalWrite(motorpin22,LOW);\n        }\n        else if(state=='r')\n      {\n        digitalWrite(motorpin11,HIGH);\n        digitalWrite(motorpin12,LOW);     // Backward Right motion of rover\n        digitalWrite(motorpin21,LOW);\n        digitalWrite(motorpin22,HIGH);\n        }\n  }}\n```\n\n# Start a Discussion on:\n\n# Comments\n\nThank you for providing this update\n\nLog in or register to post comments\n\nHere's my Mars Rover, a 1/4 scale version of Mars Perseverance Rover.  Designed by How To Mechantronics, I built it last year.  Uses an Arduino Mega,  has 6 motors, 4 steering servos and a stepper and servo for the camera.  Operated by Flysky remote control using iBus\n\nLog in or register to post comments\n\n# Add New Comment\n\nLog in or register to post comments"}
{"title":"DIY Arduino Bluetooth Car Controlled by Mobile Application","content":"For many years, robots have been a popular topic among students, hobbits, and DIYers. If you are a beginner and enjoy building robots, this is likely the first project you will do after learning the basics, which is why we decided to build a Wireless Bluetooth Controlled Robot Car Using Arduino. This robot car can be controlled wirelessly with Bluetooth and an android app, and other than that we have placed RGB Neopixel LEDs on the front, back, and bottom of the robot to make it look cool. We will also build a custom android app with the MIT app inventor so that we can send commands directly via Bluetooth and control the robot's movements and also control the LEDs on the robot. You can check out the video given at the bottom of this page for complete build details.\n\nPreviously we made some other robotic projects, if you want to build something different and easier you can check out our other projects linked down below.\n\nAutomatic Surface Disinfecting Robot using Ultraviolet Lights\n\nDIY Smart Vacuum Cleaning Robot using Arduino\n\nWiFi Controlled Robot using Arduino\n\nBuild a Simple Arduino RC Boat that can be Controlled Wirelessly using 433 MHz RF Modules\n\n# Components & Tools Required to Build Wireless Arduino Bluetooth Robot\n\nArduino UNO *1\n\nHC05 Module *1\n\nL298N Motor driver *1\n\nNeoPixel LED x as required\n\nLithium ion 18650 battery with protection circuit *1\n\nBO Motors with wheels  *4\n\nPerf board big *1\n\nPerfboard small *1\n\nToggle switch *1\n\nDC female jack *1\n\nRelimate connector pair *1\n\nMale bergstrip *1\n\nFemale Bergstip *2\n\nSingle Strand Wires of various colors * as required\n\nSunboard of medium thickness * as required\n\nPaper Cutter, Hot Glue, Feviquick, Ruler, Marker, Wirecutter, Screwdriver\n\n# Building the Chassis for Arduino based Bluetooth Robot\n\nChassis of the Robot is the base/main part of the bot that holds all the circuits of the bot. So, we will be using sunboards to make a reliable and strong chassis.\n\nThese boards are equally strong as cardboards but they are lightweight and cost-effective. We will require half of the full sheet for our whole construction.\n\nNote: I recommend cutting extra pieces of the sunboards so that you can replace them easily if they get broken during the building process.\n\nCut out the pieces of given dimensions:\n\nRectangular piece of 10.5 X 13.5 cm  (2 pcs)\n\nStrips of 7.5 X 2.3 cm (2 pcs)\n\nStrip of 11.5 X 2.3 cm (2 pcs)\n\n4.3 X 2.3 cm (1 pc)\n\n10.5 X 3.5 cm (2 pcs)\n\nIt will look like this-\n\nConnecting Motors\n\nNow all four motors will be connected in such a way that they will be formed into two pairs and each pair will be connected in parallel to each other. Likewise, Right side motors are connected in parallel drive and same with the left one.\n\nTip: If you connect the motor in the corresponding cross direction then it will be connected in parallel. Please refer to the video for more information.\n\nAttaching motor to the motor driver\n\nSince we are using the L298N Module, we have 2 screw terminals on both sides for connecting the motors. Just randomly attach the motors with the driver as the polarity and direction can be controlled using the input pins attached with the Arduino. This we discuss in upcoming steps.\n\nMotor driver attachment\n\nI have made a separate Hardware attachment for the motor driver that will provide the connections to the Arduino Uno board.\n\nArduino UNO Protoshield\n\nSince Arduino Protoshield can be used for direct connection of IN1, IN2, IN3, IN4 of the motor diver, and other connections but I had tried to make my own protoshield for the onboard connections. For the connectivity, I have used Female berstrips, male berstrips, and relimate connector onboard.\n\n# Arduino Bluetooth Car Circuit Diagram\n\nThe complete circuit diagram for the Arduino Bluetooth Car is shown below. This circuit is made out of generic components and can be found in your local store or it's easily available on any online store so the replication process becomes easier.\n\nThe working of this circuit is very simple and easy to understand. First, we have the Arduino which is working as the brains of the circuit. Next, we have the Bluetooth module. The Bluetooth module is connected to pin 13 and 10 of the Arduino that we are using as the software serial. Next, we are using pins 11,12,8, and 7 to connect our WS2812B RGB leds. Finally, we are using pins 9, 6, 5and 4 to connect the L298N motor driver IC that is driving four of our motors. Finally, to power it all up, we are using a 9V battery.\n\nArduino\n\nL298N\n\n3\n\nIN1\n\n9\n\nIN2\n\n5\n\nIN3\n\n6\n\nIN4\n\nVIN\n\n+5V\n\nGND\n\nGND\n\nArduino\n\nHC05\n\n10\n\nTx\n\n11\n\nRx\n\n+5V\n\nVCC\n\nGND\n\nGND\n\nArduino\n\nNeoPixel\n\n8\n\nLeft LED\n\n7\n\nRight LED\n\n12\n\nFront LED Data\n\n13\n\nBack LED Data\n\nThe working of this circuit is very easy.\n\n# Arduino Code for Bluetooth Controlled Robot\n\nThe code for the Arduino, and Bluetooth-based robot is a little bit complicated, so we separate the total code into three separate files this way we can change things quickly in the code if needed. We will start with the main file.\n\narduino_bluetooth_bot_main:\n\nAs we all know the Bluetooth module uses serial communication to communicate with the Arduino, and as the Arduino has only one serial port or TX, and RX port we need to use SoftwareSerial.h library of the Arduino to communicate with the Bluetooth module. So in the void setup() function, we begin hardware serial at 9600 baud for debugging and we open software serial at 38400 baud to communicate with the Bluetooth. Then we check if the Bluetooth module is working or not by sending AT command to the Bluetooth module. If the Bluetooth module returns an OK command, then surely the Bluetooth module is working exactly as intended. Once that was done we called LED_setup() function to set up the neo pixel LEDs which we will discuss later.\n\n```arduino\n#include <SoftwareSerial.h>\nSoftwareSerial mySerial(10, 11); // RX, TX\nvoid setup() {\n  // Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  mySerial.begin(38400);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n  Serial.println(\"Sending AT...\");\n  mySerial.write(\"AT\");\n  if (mySerial.available()>0) {\n    Serial.write(mySerial.read());\n  }\n  // set the data rate for the SoftwareSerial port\n    Serial.println(\"loop begins\");\n     LED_setup();\n}\n```\n\nNext, we have to initialize three global variables, the first one is called rcd and it's a character type variable that will hold the received data from the Bluetooth module. Next, we define an integer type variable spd that will hold the speed data of the car. Then we have a long type variable time_now  variable which we will be using to hold time data. Now the code is very simple. We check the rcd variable that it is receiving and execute an if condition accordingly. We continue this process for all the RGB LEDs and robot movements. And that marks the end of our loop function.\n\n```arduino\nvoid loop() { // run over and over\n  if (mySerial.available()) {\n    rcd = mySerial.read();\n    Serial.write(rcd);\n  }\n  unsigned long time_now = 0;\n  if (rcd == 'O')\n  {\n    R_LED(1);\n    L_LED(1);\n    F_LED(1);\n    B_LED(1);\n  }\n  if (rcd == 'o')\n  {\n    R_LED(0);\n    L_LED(0);\n    F_LED(0);\n    B_LED(0);\n  }\n  if (rcd == 'X')\n  { L_LED(1);\n  }\n  if (rcd == 'x')\n  {\n    L_LED(0);\n  }\n  if (rcd == 'P')\n  {\n    R_LED(1);\n  }\n  if (rcd == 'p')\n  { R_LED(0);\n  }\n  if (rcd == 'W')\n  { F_LED(1);\n  }\n  if (rcd == 'w')\n  { F_LED(0);\n  }\n  if (rcd == 'U')\n  { B_LED(1);\n  }\n  if (rcd == 'u')\n  { B_LED(0);\n  }\n  if (rcd == '0')\n  { spd = 80;\n  }\n  if (rcd == '1')\n  { spd = 100;\n  }\n  if (rcd == '3')\n  { spd = 120;\n  }\n  if (rcd == '5')\n  { spd = 180;\n  }\n  if (rcd == 'q')\n  { spd = 255;\n  }\n  if (rcd == 'F')\n  { Forward();\n    time_now = millis();\n    while (millis() < time_now + 100) {}\n  }\n  else if (rcd == 'B')\n  { time_now = millis();\n    while (millis() < time_now + 100) {}\n    Backward();\n  }\n  else if (rcd == 'I')\n  { time_now = millis();\n    while (millis() < time_now + 100) {}\n    FdRight();\n  }\n  else if (rcd == 'J')\n  { time_now = millis();\n    while (millis() < time_now + 100) {}\n    BkRight();\n  }\n  else if (rcd == 'R')\n  { time_now = millis();\n    while (millis() < time_now + 100) {}\n    SharpRight();\n  }\n  else if (rcd == 'L')\n  { time_now = millis();\n    while (millis() < time_now + 100) {}\n   SharpLeft();\n  }\n  else if (rcd == 'G')\n  { time_now = millis();\n    while (millis() < time_now + 100) {}\n   FdLeft();\n  }\n  else if (rcd == 'H')\n  { time_now = millis();\n    while (millis() < time_now + 100) {}\n    BkLeft();\n  }\n  else\n    Stop();\n}\n```\n\nled_control:\n\nInside the led controller file we have set up, declared, and defined the pins where the neopixel LEDs are connected. To control the neopixels we have used the Adafruit_NeoPixel library.\n\n```arduino\n#include <Adafruit_NeoPixel.h>\n#ifdef __AVR__\n#include <avr/power.h>\n#endif\n#define F_LED_PIN        12 //Front LED\n#define F_LED_PIXEL       6\n#define B_LED_PIN        13  //Back LED\n#define B_LED_PIXEL       6\n#define R_LED_PIN        7 //Right LED\n#define R_LED_PIXEL       1\n#define L_LED_PIN        8 //Left LED\n#define L_LED_PIXEL       1\nAdafruit_NeoPixel F_LED_STRIP(F_LED_PIXEL, F_LED_PIN, NEO_GRB + NEO_KHZ800);\nAdafruit_NeoPixel B_LED_STRIP(B_LED_PIXEL, B_LED_PIN, NEO_GRB + NEO_KHZ800);\nAdafruit_NeoPixel R_LED_STRIP(R_LED_PIXEL, R_LED_PIN, NEO_GRB + NEO_KHZ800);\nAdafruit_NeoPixel L_LED_STRIP(L_LED_PIXEL, L_LED_PIN, NEO_GRB + NEO_KHZ800);\n```\n\nNext inside this file, we have LED_setup() function. Inside this function, we have initialized all the neopixels LEDs and cleared them out with the default function provided by Adafruit, so that the neopixels don't light up randomly at the start of the code.\n\n```arduino\nvoid LED_setup()\n{\n  #if defined(__AVR_ATtiny85__) && (F_CPU == 16000000)\n  clock_prescale_set(clock_div_1);\n#endif\n  F_LED_STRIP.begin();\n  B_LED_STRIP.begin();\n  R_LED_STRIP.begin();\n  L_LED_STRIP.begin();\n  R_LED_STRIP.clear();\n  L_LED_STRIP.clear();\n  F_LED_STRIP.clear();\n  B_LED_STRIP.clear();\n}\n```\n\nNext, we have another four functions that control all the LEDs. Those functions are attached to the robot and are called R_LED, L_LED, F_LED, B_LED respectively.\n\n```arduino\nvoid R_LED(int a)\n{\n  if(a==1)\n  {\n    R_LED_STRIP.clear();\n    R_LED_STRIP.setPixelColor(0, R_LED_STRIP.Color(0, 255, 255));\n   R_LED_STRIP.show();   // Send the updated pixel colors to the hardware.\n  }\n  else {\n    R_LED_STRIP.clear();\n     R_LED_STRIP.show();\n  }   \n}\nvoid L_LED(int a)\n{\n  if(a==1)\n  {\n    L_LED_STRIP.clear();\n    L_LED_STRIP.setPixelColor(0, L_LED_STRIP.Color(0, 255, 255));\n   L_LED_STRIP.show();   // Send the updated pixel colors to the hardware.\n  }\n  else\n  {\n     L_LED_STRIP.clear();\n     L_LED_STRIP.show();\n  }\n}\nvoid F_LED(int a)\n{\n  if(a==1)\n  {\n    F_LED_STRIP.clear();\n    F_LED_STRIP.setPixelColor(0, F_LED_STRIP.Color(255, 255, 255));\n    F_LED_STRIP.setPixelColor(1, F_LED_STRIP.Color(0, 0, 50));\n    F_LED_STRIP.setPixelColor(2, F_LED_STRIP.Color(0, 0, 50));\n    F_LED_STRIP.setPixelColor(3, F_LED_STRIP.Color(0, 0, 50));\n    F_LED_STRIP.setPixelColor(4, F_LED_STRIP.Color(0, 0, 50));\n    F_LED_STRIP.setPixelColor(5, F_LED_STRIP.Color(255, 255, 255));\n   F_LED_STRIP.show();   // Send the updated pixel colors to the hardware.\n  }\n  else if(a==0)\n  {\n    F_LED_STRIP.clear();\n    F_LED_STRIP.show();\n  }\n}\nvoid B_LED(int a)\n{\n  if(a==1)\n  {\n    B_LED_STRIP.clear();\n    B_LED_STRIP.setPixelColor(0, B_LED_STRIP.Color(255, 0, 0));\n    B_LED_STRIP.setPixelColor(1, B_LED_STRIP.Color(0, 50, 0));\n    B_LED_STRIP.setPixelColor(2, B_LED_STRIP.Color(0, 50, 0));\n    B_LED_STRIP.setPixelColor(3, B_LED_STRIP.Color(0, 50, 0));\n    B_LED_STRIP.setPixelColor(4, B_LED_STRIP.Color(0, 50, 0));\n    B_LED_STRIP.setPixelColor(5, B_LED_STRIP.Color(255, 0, 0));\n    B_LED_STRIP.show();   // Send the updated pixel colors to the hardware.\n  }\n  else if(a==0)\n  {\n    B_LED_STRIP.clear();\n    B_LED_STRIP.show();\n  }\n}\n```\n\nThis marks the end of the led_control code portion.\n\nMovements :\n\nNext, we have our movement files. In this particular file, we have defined functions to control the movement of the robot. In the function shown below, we have used analogWrite(5, spd) function and passed the pin and speed value so that it can generate a PWM signal. After that we are driving a motor driver IC and that in turn drives the motor.\n\n```arduino\nvoid Forward()\n{\n  analogWrite(5, spd);\n  digitalWrite(6, 0);\n  analogWrite(9, spd);\n  digitalWrite(3, 0);\n  //  delay(50);\n}\nvoid Backward()\n{\n  digitalWrite(5, 0);\n  analogWrite(6, spd);\n  digitalWrite(9, 0);\n  analogWrite(3, spd);\n}\nvoid Stop()\n{\n  analogWrite(5, 0);\n  digitalWrite(6, 0);\n  analogWrite(9, 0);\n  digitalWrite(3, 0);\n}\nvoid FdRight()\n{\n  analogWrite(5, spd);\n  digitalWrite(6, 0);\n  digitalWrite(9, 0);\n  analogWrite(3, 0);\n}\nvoid BkRight()\n{\n  analogWrite(5, 0);\n  digitalWrite(6, 0);\n  digitalWrite(9, 0);\n  analogWrite(3, spd);\n}\nvoid SharpRight()\n{\n  analogWrite(5, spd);\n  digitalWrite(6, 0);\n  digitalWrite(9, 0);\n  analogWrite(3, spd);\n}\nvoid SharpLeft()\n{\n  digitalWrite(5, 0);\n  analogWrite(6, spd);\n  analogWrite(9, spd);\n  digitalWrite(3, 0);\n}\nvoid BkLeft()\n{\n  digitalWrite(5, 0);\n  analogWrite(6, spd);\n  analogWrite(9, 0);\n  digitalWrite(3, 0);\n}\nvoid FdLeft()\n{\n  digitalWrite(5, 0);\n  analogWrite(6, 0);\n  analogWrite(9, spd);\n  digitalWrite(3, 0);\n}\n```\n\nThat's all there is for the code part and we can move on to the android app part.\n\n# Building the Android App for our Bluetooth Controlled Robot\n\nBuilding the android application was very simple with the app inventor. First, we started by designing the user interface. As you can see on the left-hand side of the image the screenshot is taken from the web GUI of the MIT app inventor and the right-hand side of the image is a screenshot from the phone. Once we were satisfied with the GUI, we proceeded with the logical part of the app.\n\nIn the logical part, there is nothing much. We use standard app inventor methods to connect to the HC-05 Bluetooth and once the connection is done, we just send some specific commands to move the robot and control the LEDs in the robot. The aia file for the android app is given, you can download and edit it to your heart's content. Screenshot of the MIT app inventor logical part is given below-\n\nThat concludes the app-building process.\n\n# Bluetooth Controlled Robot - In action\n\nFor the testing part, we made the circuit beforehand and tested every part differently, so we can determine any faults in our part. Once every part was tested, we started to build the robot by first measuring and then cutting the sunboard according to the dimension. Once everything was finished the bot looks something like the image below.\n\nWith this, we are concluding our project Arduino-based android and Bluetooth controlled robot car. Hope you have enjoyed reading this and learned something useful. Now it’s time for you to build it on your own and let us know what you are doing with this project in the comment section below. If you have any questions, you can use our forum to get in touch with us.\n\n# Complete Project Code\n\n```arduino\nArduino_Bluetooth_Bot_main\n#include <SoftwareSerial.h>\nSoftwareSerial mySerial(10, 11); // RX, TX\nvoid setup() {\n  // Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  mySerial.begin(38400);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n  Serial.println(\"Sending AT...\");\n  mySerial.write(\"AT\");\n  if (mySerial.available() > 0) {\n    Serial.write(mySerial.read());\n  }\n  // set the data rate for the SoftwareSerial port\n  Serial.println(\"loop begins\");\n  LED_setup();\n}\nchar rcd = ' ';\nint spd = 100;\nunsigned long time_now = 0;\nvoid loop() { // run over and over\n  if (mySerial.available()) {\n    rcd = mySerial.read();\n    Serial.write(rcd);\n  }\n  unsigned long time_now = 0;\n  if (rcd == 'O')\n  {\n    R_LED(1);\n    L_LED(1);\n    F_LED(1);\n    B_LED(1);\n  }\n  if (rcd == 'o')\n  {\n    R_LED(0);\n    L_LED(0);\n    F_LED(0);\n    B_LED(0);\n  }\n  if (rcd == 'X')\n  { L_LED(1);\n  }\n  if (rcd == 'x')\n  {\n    L_LED(0);\n  }\n  if (rcd == 'P')\n  {\n    R_LED(1);\n  }\n  if (rcd == 'p')\n  { R_LED(0);\n  }\n  if (rcd == 'W')\n  { F_LED(1);\n  }\n  if (rcd == 'w')\n  { F_LED(0);\n  }\n  if (rcd == 'U')\n  { B_LED(1);\n  }\n  if (rcd == 'u')\n  { B_LED(0);\n  }\n  if (rcd == '0')\n  { spd = 80;\n  }\n  if (rcd == '1')\n  { spd = 100;\n  }\n  if (rcd == '3')\n  { spd = 120;\n  }\n  if (rcd == '5')\n  { spd = 180;\n  }\n  if (rcd == 'q')\n  { spd = 255;\n  }\n  if (rcd == 'F')\n  { Forward();\n    time_now = millis();\n    while (millis() < time_now + 100) {}\n  }\n  else if (rcd == 'B')\n  { time_now = millis();\n    while (millis() < time_now + 100) {}\n    Backward();\n  }\n  else if (rcd == 'I')\n  { time_now = millis();\n    while (millis() < time_now + 100) {}\n    FdRight();\n  }\n  else if (rcd == 'J')\n  { time_now = millis();\n    while (millis() < time_now + 100) {}\n    BkRight();\n  }\n  else if (rcd == 'R')\n  { time_now = millis();\n    while (millis() < time_now + 100) {}\n    SharpRight();\n  }\n  else if (rcd == 'L')\n  { time_now = millis();\n    while (millis() < time_now + 100) {}\n    SharpLeft();\n  }\n  else if (rcd == 'G')\n  { time_now = millis();\n    while (millis() < time_now + 100) {}\n    FdLeft();\n  }\n  else if (rcd == 'H')\n  { time_now = millis();\n    while (millis() < time_now + 100) {}\n    BkLeft();\n  }\n  else\n    Stop();\n}\n \nLED_Control\n#include <Adafruit_NeoPixel.h>\n#ifdef __AVR__\n#include <avr/power.h>\n#endif\n#define F_LED_PIN        12 //Front LED\n#define F_LED_PIXEL       6\n#define B_LED_PIN        13  //Back LED\n#define B_LED_PIXEL       6\n#define R_LED_PIN        7 //Right LED\n#define R_LED_PIXEL       1\n#define L_LED_PIN        8 //Left LED\n#define L_LED_PIXEL       1\nAdafruit_NeoPixel F_LED_STRIP(F_LED_PIXEL, F_LED_PIN, NEO_GRB + NEO_KHZ800);\nAdafruit_NeoPixel B_LED_STRIP(B_LED_PIXEL, B_LED_PIN, NEO_GRB + NEO_KHZ800);\nAdafruit_NeoPixel R_LED_STRIP(R_LED_PIXEL, R_LED_PIN, NEO_GRB + NEO_KHZ800);\nAdafruit_NeoPixel L_LED_STRIP(L_LED_PIXEL, L_LED_PIN, NEO_GRB + NEO_KHZ800);\nvoid LED_setup()\n{\n  #if defined(__AVR_ATtiny85__) && (F_CPU == 16000000)\n  clock_prescale_set(clock_div_1);\n#endif\n  F_LED_STRIP.begin();\n  B_LED_STRIP.begin();\n  R_LED_STRIP.begin();\n  L_LED_STRIP.begin();\n  R_LED_STRIP.clear();\n  L_LED_STRIP.clear();\n  F_LED_STRIP.clear();\n  B_LED_STRIP.clear();\n}\nvoid R_LED(int a)\n{\n  if(a==1)\n  {\n    R_LED_STRIP.clear();\n    R_LED_STRIP.setPixelColor(0, R_LED_STRIP.Color(0, 255, 255));\n   R_LED_STRIP.show();   // Send the updated pixel colors to the hardware.\n  }\n  else {\n    R_LED_STRIP.clear();\n     R_LED_STRIP.show();\n  }   \n}\nvoid L_LED(int a)\n{\n  if(a==1)\n  {\n    L_LED_STRIP.clear();\n    L_LED_STRIP.setPixelColor(0, L_LED_STRIP.Color(0, 255, 255));\n   L_LED_STRIP.show();   // Send the updated pixel colors to the hardware.\n  }\n  else\n  {\n     L_LED_STRIP.clear();\n     L_LED_STRIP.show();\n  }\n}\nvoid F_LED(int a)\n{\n  if(a==1)\n  {\n    F_LED_STRIP.clear();\n    F_LED_STRIP.setPixelColor(0, F_LED_STRIP.Color(255, 255, 255));\n    F_LED_STRIP.setPixelColor(1, F_LED_STRIP.Color(0, 0, 50));\n    F_LED_STRIP.setPixelColor(2, F_LED_STRIP.Color(0, 0, 50));\n    F_LED_STRIP.setPixelColor(3, F_LED_STRIP.Color(0, 0, 50));\n    F_LED_STRIP.setPixelColor(4, F_LED_STRIP.Color(0, 0, 50));\n    F_LED_STRIP.setPixelColor(5, F_LED_STRIP.Color(255, 255, 255));\n   F_LED_STRIP.show();   // Send the updated pixel colors to the hardware.\n  }\n  else if(a==0)\n  {\n    F_LED_STRIP.clear();\n    F_LED_STRIP.show();\n  }\n}\nvoid B_LED(int a)\n{\n  if(a==1)\n  {\n    B_LED_STRIP.clear();\n    B_LED_STRIP.setPixelColor(0, B_LED_STRIP.Color(255, 0, 0));\n    B_LED_STRIP.setPixelColor(1, B_LED_STRIP.Color(0, 50, 0));\n    B_LED_STRIP.setPixelColor(2, B_LED_STRIP.Color(0, 50, 0));\n    B_LED_STRIP.setPixelColor(3, B_LED_STRIP.Color(0, 50, 0));\n    B_LED_STRIP.setPixelColor(4, B_LED_STRIP.Color(0, 50, 0));\n    B_LED_STRIP.setPixelColor(5, B_LED_STRIP.Color(255, 0, 0));\n    B_LED_STRIP.show();   // Send the updated pixel colors to the hardware.\n  }\n  else if(a==0)\n  {\n    B_LED_STRIP.clear();\n    B_LED_STRIP.show();\n  }\n}\n \nMovements\nvoid Forward()\n{\n  analogWrite(5, spd);\n  digitalWrite(6, 0);\n  analogWrite(9, spd);\n  digitalWrite(3, 0);\n  //  delay(50);\n}\nvoid Backward()\n{\n  digitalWrite(5, 0);\n  analogWrite(6, spd);\n  digitalWrite(9, 0);\n  analogWrite(3, spd);\n}\nvoid Stop()\n{\n  analogWrite(5, 0);\n  digitalWrite(6, 0);\n  analogWrite(9, 0);\n  digitalWrite(3, 0);\n}\nvoid FdRight()\n{\n  analogWrite(5, spd);\n  digitalWrite(6, 0);\n  digitalWrite(9, 0);\n  analogWrite(3, 0);\n}\nvoid BkRight()\n{\n  analogWrite(5, 0);\n  digitalWrite(6, 0);\n  digitalWrite(9, 0);\n  analogWrite(3, spd);\n}\nvoid SharpRight()\n{\n  analogWrite(5, spd);\n  digitalWrite(6, 0);\n  digitalWrite(9, 0);\n  analogWrite(3, spd);\n}\nvoid SharpLeft()\n{\n  digitalWrite(5, 0);\n  analogWrite(6, spd);\n  analogWrite(9, spd);\n  digitalWrite(3, 0);\n}\nvoid BkLeft()\n{\n  digitalWrite(5, 0);\n  analogWrite(6, spd);\n  analogWrite(9, 0);\n  digitalWrite(3, 0);\n}\nvoid FdLeft()\n{\n  digitalWrite(5, 0);\n  analogWrite(6, 0);\n  analogWrite(9, spd);\n  digitalWrite(3, 0);\n}\n```\n\n```arduino\nArduino_Bluetooth_Bot_main\n#include <SoftwareSerial.h>\nSoftwareSerial mySerial(10, 11); // RX, TX\nvoid setup() {\n  // Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  mySerial.begin(38400);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n  Serial.println(\"Sending AT...\");\n  mySerial.write(\"AT\");\n  if (mySerial.available() > 0) {\n    Serial.write(mySerial.read());\n  }\n  // set the data rate for the SoftwareSerial port\n  Serial.println(\"loop begins\");\n  LED_setup();\n}\nchar rcd = ' ';\nint spd = 100;\nunsigned long time_now = 0;\nvoid loop() { // run over and over\n  if (mySerial.available()) {\n    rcd = mySerial.read();\n    Serial.write(rcd);\n  }\n  unsigned long time_now = 0;\n  if (rcd == 'O')\n  {\n    R_LED(1);\n    L_LED(1);\n    F_LED(1);\n    B_LED(1);\n  }\n  if (rcd == 'o')\n  {\n    R_LED(0);\n    L_LED(0);\n    F_LED(0);\n    B_LED(0);\n  }\n  if (rcd == 'X')\n  { L_LED(1);\n  }\n  if (rcd == 'x')\n  {\n    L_LED(0);\n  }\n  if (rcd == 'P')\n  {\n    R_LED(1);\n  }\n  if (rcd == 'p')\n  { R_LED(0);\n  }\n  if (rcd == 'W')\n  { F_LED(1);\n  }\n  if (rcd == 'w')\n  { F_LED(0);\n  }\n  if (rcd == 'U')\n  { B_LED(1);\n  }\n  if (rcd == 'u')\n  { B_LED(0);\n  }\n  if (rcd == '0')\n  { spd = 80;\n  }\n  if (rcd == '1')\n  { spd = 100;\n  }\n  if (rcd == '3')\n  { spd = 120;\n  }\n  if (rcd == '5')\n  { spd = 180;\n  }\n  if (rcd == 'q')\n  { spd = 255;\n  }\n  if (rcd == 'F')\n  { Forward();\n    time_now = millis();\n    while (millis() < time_now + 100) {}\n  }\n  else if (rcd == 'B')\n  { time_now = millis();\n    while (millis() < time_now + 100) {}\n    Backward();\n  }\n  else if (rcd == 'I')\n  { time_now = millis();\n    while (millis() < time_now + 100) {}\n    FdRight();\n  }\n  else if (rcd == 'J')\n  { time_now = millis();\n    while (millis() < time_now + 100) {}\n    BkRight();\n  }\n  else if (rcd == 'R')\n  { time_now = millis();\n    while (millis() < time_now + 100) {}\n    SharpRight();\n  }\n  else if (rcd == 'L')\n  { time_now = millis();\n    while (millis() < time_now + 100) {}\n    SharpLeft();\n  }\n  else if (rcd == 'G')\n  { time_now = millis();\n    while (millis() < time_now + 100) {}\n    FdLeft();\n  }\n  else if (rcd == 'H')\n  { time_now = millis();\n    while (millis() < time_now + 100) {}\n    BkLeft();\n  }\n  else\n    Stop();\n}\n \nLED_Control\n#include <Adafruit_NeoPixel.h>\n#ifdef __AVR__\n#include <avr/power.h>\n#endif\n#define F_LED_PIN        12 //Front LED\n#define F_LED_PIXEL       6\n#define B_LED_PIN        13  //Back LED\n#define B_LED_PIXEL       6\n#define R_LED_PIN        7 //Right LED\n#define R_LED_PIXEL       1\n#define L_LED_PIN        8 //Left LED\n#define L_LED_PIXEL       1\nAdafruit_NeoPixel F_LED_STRIP(F_LED_PIXEL, F_LED_PIN, NEO_GRB + NEO_KHZ800);\nAdafruit_NeoPixel B_LED_STRIP(B_LED_PIXEL, B_LED_PIN, NEO_GRB + NEO_KHZ800);\nAdafruit_NeoPixel R_LED_STRIP(R_LED_PIXEL, R_LED_PIN, NEO_GRB + NEO_KHZ800);\nAdafruit_NeoPixel L_LED_STRIP(L_LED_PIXEL, L_LED_PIN, NEO_GRB + NEO_KHZ800);\nvoid LED_setup()\n{\n  #if defined(__AVR_ATtiny85__) && (F_CPU == 16000000)\n  clock_prescale_set(clock_div_1);\n#endif\n  F_LED_STRIP.begin();\n  B_LED_STRIP.begin();\n  R_LED_STRIP.begin();\n  L_LED_STRIP.begin();\n  R_LED_STRIP.clear();\n  L_LED_STRIP.clear();\n  F_LED_STRIP.clear();\n  B_LED_STRIP.clear();\n}\nvoid R_LED(int a)\n{\n  if(a==1)\n  {\n    R_LED_STRIP.clear();\n    R_LED_STRIP.setPixelColor(0, R_LED_STRIP.Color(0, 255, 255));\n   R_LED_STRIP.show();   // Send the updated pixel colors to the hardware.\n  }\n  else {\n    R_LED_STRIP.clear();\n     R_LED_STRIP.show();\n  }   \n}\nvoid L_LED(int a)\n{\n  if(a==1)\n  {\n    L_LED_STRIP.clear();\n    L_LED_STRIP.setPixelColor(0, L_LED_STRIP.Color(0, 255, 255));\n   L_LED_STRIP.show();   // Send the updated pixel colors to the hardware.\n  }\n  else\n  {\n     L_LED_STRIP.clear();\n     L_LED_STRIP.show();\n  }\n}\nvoid F_LED(int a)\n{\n  if(a==1)\n  {\n    F_LED_STRIP.clear();\n    F_LED_STRIP.setPixelColor(0, F_LED_STRIP.Color(255, 255, 255));\n    F_LED_STRIP.setPixelColor(1, F_LED_STRIP.Color(0, 0, 50));\n    F_LED_STRIP.setPixelColor(2, F_LED_STRIP.Color(0, 0, 50));\n    F_LED_STRIP.setPixelColor(3, F_LED_STRIP.Color(0, 0, 50));\n    F_LED_STRIP.setPixelColor(4, F_LED_STRIP.Color(0, 0, 50));\n    F_LED_STRIP.setPixelColor(5, F_LED_STRIP.Color(255, 255, 255));\n   F_LED_STRIP.show();   // Send the updated pixel colors to the hardware.\n  }\n  else if(a==0)\n  {\n    F_LED_STRIP.clear();\n    F_LED_STRIP.show();\n  }\n}\nvoid B_LED(int a)\n{\n  if(a==1)\n  {\n    B_LED_STRIP.clear();\n    B_LED_STRIP.setPixelColor(0, B_LED_STRIP.Color(255, 0, 0));\n    B_LED_STRIP.setPixelColor(1, B_LED_STRIP.Color(0, 50, 0));\n    B_LED_STRIP.setPixelColor(2, B_LED_STRIP.Color(0, 50, 0));\n    B_LED_STRIP.setPixelColor(3, B_LED_STRIP.Color(0, 50, 0));\n    B_LED_STRIP.setPixelColor(4, B_LED_STRIP.Color(0, 50, 0));\n    B_LED_STRIP.setPixelColor(5, B_LED_STRIP.Color(255, 0, 0));\n    B_LED_STRIP.show();   // Send the updated pixel colors to the hardware.\n  }\n  else if(a==0)\n  {\n    B_LED_STRIP.clear();\n    B_LED_STRIP.show();\n  }\n}\n \nMovements\nvoid Forward()\n{\n  analogWrite(5, spd);\n  digitalWrite(6, 0);\n  analogWrite(9, spd);\n  digitalWrite(3, 0);\n  //  delay(50);\n}\nvoid Backward()\n{\n  digitalWrite(5, 0);\n  analogWrite(6, spd);\n  digitalWrite(9, 0);\n  analogWrite(3, spd);\n}\nvoid Stop()\n{\n  analogWrite(5, 0);\n  digitalWrite(6, 0);\n  analogWrite(9, 0);\n  digitalWrite(3, 0);\n}\nvoid FdRight()\n{\n  analogWrite(5, spd);\n  digitalWrite(6, 0);\n  digitalWrite(9, 0);\n  analogWrite(3, 0);\n}\nvoid BkRight()\n{\n  analogWrite(5, 0);\n  digitalWrite(6, 0);\n  digitalWrite(9, 0);\n  analogWrite(3, spd);\n}\nvoid SharpRight()\n{\n  analogWrite(5, spd);\n  digitalWrite(6, 0);\n  digitalWrite(9, 0);\n  analogWrite(3, spd);\n}\nvoid SharpLeft()\n{\n  digitalWrite(5, 0);\n  analogWrite(6, spd);\n  analogWrite(9, spd);\n  digitalWrite(3, 0);\n}\nvoid BkLeft()\n{\n  digitalWrite(5, 0);\n  analogWrite(6, spd);\n  analogWrite(9, 0);\n  digitalWrite(3, 0);\n}\nvoid FdLeft()\n{\n  digitalWrite(5, 0);\n  analogWrite(6, 0);\n  analogWrite(9, spd);\n  digitalWrite(3, 0);\n}\n```\n\n# Start a Discussion on:\n\n# Comments\n\nHello,\n\nI have designed the RC car as per the description also downloaded the app code compiled it with MIT inventor. installed app , LED is blowing in aurdino as well as in bluetooth. but car is not responding as per the back and forth button pressed from the app. Please do needful.\n\nThank you\n\nLog in or register to post comments\n\nhello,\n\nthe MIT app inventor app does not exist in the link provided above , please help me to find the file to complete this project.\n\nbest regards\n\nLog in or register to post comments\n\nIn reply to hello,   the MIT app… by khaed\n\nHi, you can download the MIT app inventor file from the Building the Android App for our Bluetooth Controlled Robot section in the above article. The link is checked and verified to be working.\n\nLog in or register to post comments\n\n# Add New Comment\n\nLog in or register to post comments"}
{"title":"Stress Monitoring Device","content":"Stress is a significant contributor to various health issues such as heart disease, high blood pressure, diabetes, and mental health conditions. This project aims to develop a real-time wearable stress monitoring device that uses sensors to track physiological parameters such as heart rate, skin conductivity (GSR), and body temperature. The device leverages an Arduino R4 Wi-Fi board, which is a powerful microcontroller capable of wireless communication, to send the collected data to a Telegram bot for real-time monitoring.\n\n# Impact Statement\n\nThis wearable stress monitoring device leverages real-time sensors to track key physiological indicators such as heart rate, skin conductivity, and body temperature, providing users with immediate feedback on their stress levels. Through wireless communication with a Telegram bot, it allows for continuous, remote monitoring, empowering users to manage their stress more effectively and proactively. Designed with a 3D-printed casing and powered by a rechargeable Li-ion battery, this compact, portable solution promotes mental well-being by making stress management accessible anytime, anywhere.\n\n# Objectives\n\nThe primary objectives of this project are as follows:\n\nDevelop a Wearable Device: Build a portable and comfortable wearable band to monitor stress levels continuously.\n\nDevelop a Wearable Device: Build a portable and comfortable wearable band to monitor stress levels continuously.\n\nReal-Time Data Collection and Transmission: Measure heart rate, skin conductivity (GSR), and body temperature as indicators of stress.\n\nReal-Time Data Collection and Transmission: Measure heart rate, skin conductivity (GSR), and body temperature as indicators of stress.\n\nWireless Communication: Use the Arduino R4 WiFi board to wirelessly transmit the data to a Telegram bot for remote monitoring.\n\nWireless Communication: Use the Arduino R4 WiFi board to wirelessly transmit the data to a Telegram bot for remote monitoring.\n\nPersonalized Stress Insights: Provide immediate feedback and long-term insights into stress levels.\n\nPersonalized Stress Insights: Provide immediate feedback and long-term insights into stress levels.\n\n# Components and Hardware Setup\n\nThe key components used in this project were selected for their compatibility, portability, and accuracy in measuring physiological parameters. Here's a breakdown of the components:\n\nArduino R4 Wi-Fi: The central microcontroller responsible for reading data from sensors, processing the data, and transmitting it to the Telegram bot over Wi-Fi.\n\nArduino R4 Wi-Fi: The central microcontroller responsible for reading data from sensors, processing the data, and transmitting it to the Telegram bot over Wi-Fi.\n\nMAX30105 Heart Rate Sensor: Measures heart rate using photoplethysmography (PPG) by detecting blood volume changes.\n\nMAX30105 Heart Rate Sensor: Measures heart rate using photoplethysmography (PPG) by detecting blood volume changes.\n\nBME280 Temperature Sensor: Measures ambient temperature, which can correlate with stress as stress can affect body temperature.\n\nBME280 Temperature Sensor: Measures ambient temperature, which can correlate with stress as stress can affect body temperature.\n\nGSR Sensor: Measures skin conductivity, which varies with stress levels and emotional arousal.\n\nGSR Sensor: Measures skin conductivity, which varies with stress levels and emotional arousal.\n\nOLED Display (0.96-inch): Displays real-time data, including heart rate, skin conductivity, and body temperature.\n\nOLED Display (0.96-inch): Displays real-time data, including heart rate, skin conductivity, and body temperature.\n\nBattery: A 3.7V 1500mAh rechargeable Li-ion battery provides the power for the device, ensuring portability and long usage times. The battery is rechargeable and provides sufficient capacity for continuous monitoring.\n\nBattery: A 3.7V 1500mAh rechargeable Li-ion battery provides the power for the device, ensuring portability and long usage times. The battery is rechargeable and provides sufficient capacity for continuous monitoring.\n\nTelegram Bot: A communication platform that receives real-time sensor data from the device and notifies users.\n\nTelegram Bot: A communication platform that receives real-time sensor data from the device and notifies users.\n\n# Additional Components\n\n3D Printed Casing: The casing for the device was designed using SolidWorks and 3D printed to house all the components, making the device compact and wearable. The design was optimized for comfort, durability, and ease of access to the sensors and display.\n\n3D Printed Casing: The casing for the device was designed using SolidWorks and 3D printed to house all the components, making the device compact and wearable. The design was optimized for comfort, durability, and ease of access to the sensors and display.\n\nCharging Circuit: A TP4056 lithium battery charging module is used for safely charging the 3.7V Li-ion battery, providing an easy and efficient charging solution.\n\nCharging Circuit: A TP4056 lithium battery charging module is used for safely charging the 3.7V Li-ion battery, providing an easy and efficient charging solution.\n\nNavigate to This YouTube Video for Full Demonstration of the Project\n\nThese components are connected as described in the following circuit diagram:\n\nLet's look at the circuit diagram.\n\nThis wearable stress monitoring device combines a set of carefully chosen sensors—heart rate (MAX30105), skin conductivity (GSR), and temperature (BME280)—to offer real-time tracking of stress-related physiological parameters. By using I2C communication, the device is able to efficiently integrate multiple sensors onto the Arduino R4 Wi-Fi board connected on A4 and A5 of board as SDA and SCL. The GSR has a signal pin which is attached on pin A0 to read the data from the sensor. simplifying the wiring and making the system compact and portable. The GSR sensor is connected to the analog pin for continuous skin conductivity measurement, while the data is displayed on a 0.96-inch OLED screen and transmitted wirelessly to a Telegram bot, offering easy, remote monitoring.\n\nTo make the device truly portable, I’ve powered it using a 3.7V 1500mAh rechargeable Li-ion battery paired with a TP4056 charging module, allowing for convenient, on-the-go usage. The design is enclosed in a custom 3D-printed casing created in SolidWorks, ensuring a lightweight and ergonomic form factor suitable for everyday wear. This compact, accessible solution empowers users to monitor and manage their stress levels effectively, anytime and anywhere, supporting proactive mental well-being management.\n\n# CAD Model\n\nFor the casing of the device, I designed a custom 3D model using SolidWorks, taking precise measurements of all the components—like the Arduino R4 Wi-Fi board, MAX30105 heart rate sensor, BME280 temperature sensor, OLED display, GSR sensor, and the Li-ion battery. Once the design was complete, I 3D printed the casing to ensure a snug fit for all the parts.\n\nThe design prioritized compactness, portability, and comfort, as the device is intended to be worn. I carefully positioned all components inside the casing, ensuring everything fits securely while keeping the device lightweight and wearable. The 3D printing process allowed me to quickly iterate and make adjustments, and the result is a durable, functional enclosure that protects the electronics while being easy to wear and use on a daily basis.\n\n# Data Transmission and Telegram Setup\n\nTo enable real-time data transmission, I created a Telegram bot through BotFather, which is a simple and powerful tool provided by Telegram for bot creation. The bot was named \"Stress Monitoring\", specifically designed to send stress-related data such as heart rate (BPM), body temperature, and GSR (Galvanic Skin Response) readings to my personal Telegram account.\n\nAfter creating the bot, I obtained its API key, a unique identifier that allows the Arduino R4 board to securely communicate with the Telegram servers. Additionally, I retrieved my Telegram chat ID, which is required to specify where the data should be sent within the app. This chat ID corresponds to my personal Telegram account, allowing me to receive notifications directly to my phone.\n\nUsing this API key and chat ID, I programmed the Arduino R4 Wi-Fi board to send data over the internet. The Arduino board, with its built-in Wi-Fi capability, connects to the internet and establishes a communication link with the Telegram servers. It sends periodic updates regarding the monitored stress parameters (such as BPM, temperature, and GSR) via Telegram messages, ensuring I can monitor my stress levels remotely at any time.\n\nThe UniversalTelegramBot library, used in the Arduino code, provides the necessary functionality to send these messages. It handles the API calls and message formatting, making it easy to send real-time data to the Telegram bot. By integrating the Telegram Bot API into the project, I have enabled a simple and reliable way to transmit the device’s health data without the need for a complex app interface.\n\n# Demo Results\n\nThe project successfully captures and displays real-time stress-related data. Heart rate, temperature, and GSR values are continuously monitored and displayed on the OLED screen, providing immediate feedback to the user. The data is also transmitted to the Telegram app, where it can be viewed remotely, offering additional convenience.\n\nHere are some screenshots of the live data being displayed on oled with Arduino:\n\nThe data collected can be used for future analytics, potentially integrating machine learning algorithms to predict stress levels and offer personalized insights.\n\n# Code\n\n#include <Wire.h>\n\n```arduino\n#include <Wire.h>\n```\n\n#include <Adafruit_Sensor.h>\n\n```arduino\n#include <Adafruit_Sensor.h>\n```\n\n#include <Adafruit_BME280.h>\n\n```arduino\n#include <Adafruit_BME280.h>\n```\n\n#include <WiFiS3.h>\n\n```arduino\n#include <WiFiS3.h>\n```\n\n#include <WiFiSSLClient.h>\n\n```arduino\n#include <WiFiSSLClient.h>\n```\n\n#include <UniversalTelegramBot.h>\n\n```arduino\n#include <UniversalTelegramBot.h>\n```\n\n#include \"MAX30105.h\"\n\n```arduino\n#include \"MAX30105.h\"\n```\n\n#include \"heartRate.h\"\n\n```arduino\n#include \"heartRate.h\"\n```\n\n#include <Adafruit_GFX.h>        // OLED Library\n\n```arduino\n#include <Adafruit_GFX.h>        // OLED Library\n```\n\n#include <Adafruit_SSD1306.h>    // OLED Library\n\n```arduino\n#include <Adafruit_SSD1306.h>    // OLED Library\n```\n\n// GSR reading and percentage\n\n```arduino\n// GSR reading and percentage\n```\n\nint GSR;\n\n```arduino\nint GSR;\n```\n\nint GSR_percentage;\n\n```arduino\nint GSR_percentage;\n```\n\n// WiFi credentials\n\n```arduino\n// WiFi credentials\n```\n\n#define WIFI_SSID \"LAVKUSH_CHAUDHARI \"\n\n```arduino\n#define WIFI_SSID \"LAVKUSH_CHAUDHARI \"\n```\n\n#define WIFI_PASSWORD \"8108491665\"\n\n```arduino\n#define WIFI_PASSWORD \"8108491665\"\n```\n\n// Telegram bot token\n\n```arduino\n// Telegram bot token\n```\n\n#define BOT_API_TOKEN \"7534847312:AAEmhLTw7KuXPPPt9pWi00ePsqpilst1zdo\"\n\n```arduino\n#define BOT_API_TOKEN \"7534847312:AAEmhLTw7KuXPPPt9pWi00ePsqpilst1zdo\"\n```\n\n// BME280 sensor configuration\n\n```arduino\n// BME280 sensor configuration\n```\n\nAdafruit_BME280 bme;  // I2C\n\n```arduino\nAdafruit_BME280 bme;  // I2C\n```\n\n// MAX30105 sensor configuration\n\n```arduino\n// MAX30105 sensor configuration\n```\n\nMAX30105 particleSensor;\n\n```arduino\nMAX30105 particleSensor;\n```\n\n// OLED display configuration\n\n```arduino\n// OLED display configuration\n```\n\n#define SCREEN_WIDTH 128         // OLED display width, in pixels\n\n```arduino\n#define SCREEN_WIDTH 128         // OLED display width, in pixels\n```\n\n#define SCREEN_HEIGHT 64         // OLED display height, in pixels\n\n```arduino\n#define SCREEN_HEIGHT 64         // OLED display height, in pixels\n```\n\n#define OLED_RESET    -1         // Reset pin # (or -1 if sharing Arduino reset pin)\n\n```arduino\n#define OLED_RESET    -1         // Reset pin # (or -1 if sharing Arduino reset pin)\n```\n\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET); //Declaring the display name (display)\n\n```arduino\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET); //Declaring the display name (display)\n```\n\nconst byte RATE_SIZE = 4; // Increase for more averaging\n\n```arduino\nconst byte RATE_SIZE = 4; // Increase for more averaging\n```\n\nbyte rates[RATE_SIZE]; // Array of heart rates\n\n```arduino\nbyte rates[RATE_SIZE]; // Array of heart rates\n```\n\nbyte rateSpot = 0;\n\n```arduino\nbyte rateSpot = 0;\n```\n\nlong lastBeat = 0; // Time of the last beat\n\n```arduino\nlong lastBeat = 0; // Time of the last beat\n```\n\nfloat beatsPerMinute;\n\n```arduino\nfloat beatsPerMinute;\n```\n\nint beatAvg;\n\n```arduino\nint beatAvg;\n```\n\nString chat_id = \"\";             // Chat ID for Telegram\n\n```arduino\nString chat_id = \"\";             // Chat ID for Telegram\n```\n\nint message_id = -1;             // Message ID for Telegram\n\n```arduino\nint message_id = -1;             // Message ID for Telegram\n```\n\nunsigned long last_call = 0;     // Last call time for checking messages\n\n```arduino\nunsigned long last_call = 0;     // Last call time for checking messages\n```\n\nconst unsigned long interval = 1000; // Interval between message checks\n\n```arduino\nconst unsigned long interval = 1000; // Interval between message checks\n```\n\n// Object for secure WiFi client management\n\n```arduino\n// Object for secure WiFi client management\n```\n\nWiFiSSLClient securedClient;\n\n```arduino\nWiFiSSLClient securedClient;\n```\n\n// Object for managing the Telegram bot\n\n```arduino\n// Object for managing the Telegram bot\n```\n\nUniversalTelegramBot bot(BOT_API_TOKEN, securedClient);\n\n```arduino\nUniversalTelegramBot bot(BOT_API_TOKEN, securedClient);\n```\n\n// Function to handle incoming messages from Telegram\n\n```arduino\n// Function to handle incoming messages from Telegram\n```\n\nvoid handleMessages(int num_new_messages) {\n\n```arduino\nvoid handleMessages(int num_new_messages) {\n```\n\nfor (int i = 0; i < num_new_messages; i++) {\n\n```arduino\nfor (int i = 0; i < num_new_messages; i++) {\n```\n\nmessage_id = bot.messages[i].message_id;\n\n```arduino\nmessage_id = bot.messages[i].message_id;\n```\n\nchat_id = bot.messages[i].chat_id;\n\n```arduino\nchat_id = bot.messages[i].chat_id;\n```\n\nString text = bot.messages[i].text;\n\n```arduino\nString text = bot.messages[i].text;\n```\n\n// Command handling\n\n```arduino\n// Command handling\n```\n\nif (text == \"/GSR\") {\n\n```arduino\nif (text == \"/GSR\") {\n```\n\n// Send the GSR value and mapped percentage to the chat\n\n```arduino\n// Send the GSR value and mapped percentage to the chat\n```\n\nbot.sendMessage(chat_id, \"Mapped GSR: \" + String(GSR_percentage) + \"%\", \"Markdown\");\n\n```arduino\nbot.sendMessage(chat_id, \"Mapped GSR: \" + String(GSR_percentage) + \"%\", \"Markdown\");\n```\n\n} else if (text == \"/TEMP\") {\n\n```arduino\n} else if (text == \"/TEMP\") {\n```\n\nfloat temperature = bme.readTemperature(); // Read temperature\n\n```arduino\nfloat temperature = bme.readTemperature(); // Read temperature\n```\n\nbot.sendMessage(chat_id, \"Temperature: \" + String(temperature, 2) + \" °C\", \"Markdown\");\n\n```arduino\nbot.sendMessage(chat_id, \"Temperature: \" + String(temperature, 2) + \" °C\", \"Markdown\");\n```\n\nSerial.print(\"Temperature: \");\n\n```arduino\nSerial.print(\"Temperature: \");\n```\n\nSerial.print(temperature, 2);\n\n```arduino\nSerial.print(temperature, 2);\n```\n\nSerial.println(\" °C\");\n\n```arduino\nSerial.println(\" °C\");\n```\n\n} else if (text == \"/BPM\") {\n\n```arduino\n} else if (text == \"/BPM\") {\n```\n\nbot.sendMessage(chat_id, \"Average BPM: \" + String(beatAvg), \"Markdown\");\n\n```arduino\nbot.sendMessage(chat_id, \"Average BPM: \" + String(beatAvg), \"Markdown\");\n```\n\n} else if (text == \"/start\") {\n\n```arduino\n} else if (text == \"/start\") {\n```\n\nbot.sendMessage(chat_id, \"Use /GSR Value to get the GSR value, /TEMP to get the temperature, and /BPM to get the average heart rate.\", \"Markdown\");\n\n```arduino\nbot.sendMessage(chat_id, \"Use /GSR Value to get the GSR value, /TEMP to get the temperature, and /BPM to get the average heart rate.\", \"Markdown\");\n```\n\n}\n\n```arduino\n}\n```\n\n}\n\n```arduino\n}\n```\n\n}\n\n```arduino\n}\n```\n\n// Function to connect to WiFi network\n\n```arduino\n// Function to connect to WiFi network\n```\n\nvoid connectToWiFi() {\n\n```arduino\nvoid connectToWiFi() {\n```\n\nSerial.print(\"Connecting to WiFi network \");\n\n```arduino\nSerial.print(\"Connecting to WiFi network \");\n```\n\nSerial.println(WIFI_SSID);\n\n```arduino\nSerial.println(WIFI_SSID);\n```\n\nWiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n```arduino\nWiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n```\n\n// Wait for connection\n\n```arduino\n// Wait for connection\n```\n\nwhile (WiFi.status() != WL_CONNECTED) {\n\n```arduino\nwhile (WiFi.status() != WL_CONNECTED) {\n```\n\ndelay(1000);\n\n```arduino\ndelay(1000);\n```\n\nSerial.println(\"Connecting...\");\n\n```arduino\nSerial.println(\"Connecting...\");\n```\n\n}\n\n```arduino\n}\n```\n\nSerial.print(\"WiFi connected. IP Address: \");\n\n```arduino\nSerial.print(\"WiFi connected. IP Address: \");\n```\n\nSerial.println(WiFi.localIP());\n\n```arduino\nSerial.println(WiFi.localIP());\n```\n\n}\n\n```arduino\n}\n```\n\n// Initialization function\n\n```arduino\n// Initialization function\n```\n\nvoid setup() {\n\n```arduino\nvoid setup() {\n```\n\nSerial.begin(115200);            // Start serial communication\n\n```arduino\nSerial.begin(115200);            // Start serial communication\n```\n\npinMode(A0, INPUT);              // Set GSR pin as input\n\n```arduino\npinMode(A0, INPUT);              // Set GSR pin as input\n```\n\nrandomSeed(analogRead(A1));      // Use an unconnected pin (A1) for better random seed initialization\n\n```arduino\nrandomSeed(analogRead(A1));      // Use an unconnected pin (A1) for better random seed initialization\n```\n\nconnectToWiFi();                // Connect to WiFi\n\n```arduino\nconnectToWiFi();                // Connect to WiFi\n```\n\n// Initialize BME280 sensor\n\n```arduino\n// Initialize BME280 sensor\n```\n\nif (!bme.begin(0x76)) {\n\n```arduino\nif (!bme.begin(0x76)) {\n```\n\nSerial.println(\"Could not find a valid BME280 sensor, check wiring!\");\n\n```arduino\nSerial.println(\"Could not find a valid BME280 sensor, check wiring!\");\n```\n\nwhile (1);  // Stop execution if sensor is not found\n\n```arduino\nwhile (1);  // Stop execution if sensor is not found\n```\n\n}\n\n```arduino\n}\n```\n\n// Initialize MAX30105 sensor\n\n```arduino\n// Initialize MAX30105 sensor\n```\n\nif (!particleSensor.begin(Wire, I2C_SPEED_FAST)) { // Use default I2C port, 400kHz speed\n\n```arduino\nif (!particleSensor.begin(Wire, I2C_SPEED_FAST)) { // Use default I2C port, 400kHz speed\n```\n\nSerial.println(\"MAX30105 was not found. Please check wiring/power.\");\n\n```arduino\nSerial.println(\"MAX30105 was not found. Please check wiring/power.\");\n```\n\nwhile (1);  // Stop execution if sensor is not found\n\n```arduino\nwhile (1);  // Stop execution if sensor is not found\n```\n\n}\n\n```arduino\n}\n```\n\nSerial.println(\"Place your index finger on the sensor with steady pressure.\");\n\n```arduino\nSerial.println(\"Place your index finger on the sensor with steady pressure.\");\n```\n\nparticleSensor.setup();         // Configure sensor with default settings\n\n```arduino\nparticleSensor.setup();         // Configure sensor with default settings\n```\n\nparticleSensor.setPulseAmplitudeRed(0x0A);  // Turn Red LED to low to indicate sensor is running\n\n```arduino\nparticleSensor.setPulseAmplitudeRed(0x0A);  // Turn Red LED to low to indicate sensor is running\n```\n\nparticleSensor.setPulseAmplitudeGreen(0);    // Turn off Green LED\n\n```arduino\nparticleSensor.setPulseAmplitudeGreen(0);    // Turn off Green LED\n```\n\nbot.sendMessage(chat_id, \"BOT Started\", \"Markdown\"); // Notify that the bot has started\n\n```arduino\nbot.sendMessage(chat_id, \"BOT Started\", \"Markdown\"); // Notify that the bot has started\n```\n\n// Initialize the OLED display\n\n```arduino\n// Initialize the OLED display\n```\n\nif(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {  // Check the display initialization\n\n```arduino\nif(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {  // Check the display initialization\n```\n\nSerial.println(F(\"SSD1306 allocation failed\"));\n\n```arduino\nSerial.println(F(\"SSD1306 allocation failed\"));\n```\n\nwhile (1);\n\n```arduino\nwhile (1);\n```\n\n}\n\n```arduino\n}\n```\n\ndisplay.clearDisplay();  // Clear the display\n\n```arduino\ndisplay.clearDisplay();  // Clear the display\n```\n\ndisplay.setTextColor(SSD1306_WHITE);  // Set text color to white\n\n```arduino\ndisplay.setTextColor(SSD1306_WHITE);  // Set text color to white\n```\n\ndisplay.setTextSize(2); // Set larger text size\n\n```arduino\ndisplay.setTextSize(2); // Set larger text size\n```\n\ndisplay.display();  // Display initial settings\n\n```arduino\ndisplay.display();  // Display initial settings\n```\n\ndelay(2000);  // Wait for 2 seconds to let the user see \"Initializing\" message\n\n```arduino\ndelay(2000);  // Wait for 2 seconds to let the user see \"Initializing\" message\n```\n\n}\n\n```arduino\n}\n```\n\n// Main loop\n\n```arduino\n// Main loop\n```\n\nvoid loop() {\n\n```arduino\nvoid loop() {\n```\n\nGSR = analogRead(A0);  // Read the GSR sensor value (0-1023 range)\n\n```arduino\nGSR = analogRead(A0);  // Read the GSR sensor value (0-1023 range)\n```\n\n// Map the GSR value from 700-300 to 0-100%\n\n```arduino\n// Map the GSR value from 700-300 to 0-100%\n```\n\nGSR_percentage = map(GSR, 300, 700, 0, 100);\n\n```arduino\nGSR_percentage = map(GSR, 300, 700, 0, 100);\n```\n\nif (GSR_percentage < 0) GSR_percentage = 0; // Ensure percentage does not go below 0\n\n```arduino\nif (GSR_percentage < 0) GSR_percentage = 0; // Ensure percentage does not go below 0\n```\n\nif (GSR_percentage > 100) GSR_percentage = 100; // Ensure percentage does not go above 100\n\n```arduino\nif (GSR_percentage > 100) GSR_percentage = 100; // Ensure percentage does not go above 100\n```\n\n// Check for new messages from Telegram\n\n```arduino\n// Check for new messages from Telegram\n```\n\nif (millis() - last_call > interval) {\n\n```arduino\nif (millis() - last_call > interval) {\n```\n\nint num_new_messages = bot.getUpdates(bot.last_message_received + 1);\n\n```arduino\nint num_new_messages = bot.getUpdates(bot.last_message_received + 1);\n```\n\nwhile (num_new_messages) {\n\n```arduino\nwhile (num_new_messages) {\n```\n\nhandleMessages(num_new_messages);  // Handle incoming messages\n\n```arduino\nhandleMessages(num_new_messages);  // Handle incoming messages\n```\n\nnum_new_messages = bot.getUpdates(bot.last_message_received + 1);\n\n```arduino\nnum_new_messages = bot.getUpdates(bot.last_message_received + 1);\n```\n\n}\n\n```arduino\n}\n```\n\nlast_call = millis(); // Update the last call time\n\n```arduino\nlast_call = millis(); // Update the last call time\n```\n\n}\n\n```arduino\n}\n```\n\n// Update the OLED display with sensor data\n\n```arduino\n// Update the OLED display with sensor data\n```\n\ndisplay.clearDisplay();\n\n```arduino\ndisplay.clearDisplay();\n```\n\n// Display GSR data\n\n```arduino\n// Display GSR data\n```\n\ndisplay.setCursor(0, 0);  // Set the cursor to top-left corner\n\n```arduino\ndisplay.setCursor(0, 0);  // Set the cursor to top-left corner\n```\n\ndisplay.print(\"GSR: \");\n\n```arduino\ndisplay.print(\"GSR: \");\n```\n\ndisplay.print(GSR_percentage);\n\n```arduino\ndisplay.print(GSR_percentage);\n```\n\ndisplay.print(\"%\");\n\n```arduino\ndisplay.print(\"%\");\n```\n\n// Display temperature data\n\n```arduino\n// Display temperature data\n```\n\nfloat temperature = bme.readTemperature();\n\n```arduino\nfloat temperature = bme.readTemperature();\n```\n\ndisplay.setCursor(0, 24);  // Set cursor for next line\n\n```arduino\ndisplay.setCursor(0, 24);  // Set cursor for next line\n```\n\ndisplay.print(\"Temp: \");\n\n```arduino\ndisplay.print(\"Temp: \");\n```\n\ndisplay.print(int(temperature));\n\n```arduino\ndisplay.print(int(temperature));\n```\n\ndisplay.print(\"C\");\n\n```arduino\ndisplay.print(\"C\");\n```\n\n// Check heart rate data\n\n```arduino\n// Check heart rate data\n```\n\nlong irValue = particleSensor.getIR();\n\n```arduino\nlong irValue = particleSensor.getIR();\n```\n\nif (irValue > 50000) {\n\n```arduino\nif (irValue > 50000) {\n```\n\nif (checkForBeat(irValue) == true) {\n\n```arduino\nif (checkForBeat(irValue) == true) {\n```\n\nlong delta = millis() - lastBeat;\n\n```arduino\nlong delta = millis() - lastBeat;\n```\n\nlastBeat = millis();\n\n```arduino\nlastBeat = millis();\n```\n\nbeatsPerMinute = 60 / (delta / 1000.0);\n\n```arduino\nbeatsPerMinute = 60 / (delta / 1000.0);\n```\n\nif (beatsPerMinute < 255 && beatsPerMinute > 20) {\n\n```arduino\nif (beatsPerMinute < 255 && beatsPerMinute > 20) {\n```\n\nrates[rateSpot++] = (byte)beatsPerMinute; // Store reading in the array\n\n```arduino\nrates[rateSpot++] = (byte)beatsPerMinute; // Store reading in the array\n```\n\nrateSpot %= RATE_SIZE; // Wrap variable\n\n```arduino\nrateSpot %= RATE_SIZE; // Wrap variable\n```\n\n// Take average of readings\n\n```arduino\n// Take average of readings\n```\n\nbeatAvg = 0;\n\n```arduino\nbeatAvg = 0;\n```\n\nfor (byte x = 0; x < RATE_SIZE; x++)\n\n```arduino\nfor (byte x = 0; x < RATE_SIZE; x++)\n```\n\nbeatAvg += rates[x];\n\n```arduino\nbeatAvg += rates[x];\n```\n\nbeatAvg /= RATE_SIZE;\n\n```arduino\nbeatAvg /= RATE_SIZE;\n```\n\n}\n\n```arduino\n}\n```\n\n// Display the heart rate (BPM) on OLED\n\n```arduino\n// Display the heart rate (BPM) on OLED\n```\n\ndisplay.setCursor(0, 48);  // Set cursor for heart rate\n\n```arduino\ndisplay.setCursor(0, 48);  // Set cursor for heart rate\n```\n\ndisplay.print(\"BPM: \");\n\n```arduino\ndisplay.print(\"BPM: \");\n```\n\ndisplay.print(beatAvg);\n\n```arduino\ndisplay.print(beatAvg);\n```\n\n}\n\n```arduino\n}\n```\n\n}\n\n```arduino\n}\n```\n\n// Check if all conditions are met: GSR > 400, Temp > 39°C, BPM > 90\n\n```arduino\n// Check if all conditions are met: GSR > 400, Temp > 39°C, BPM > 90\n```\n\nif (GSR_percentage > 40 && temperature > 39.0 && beatAvg > 90) {\n\n```arduino\nif (GSR_percentage > 40 && temperature > 39.0 && beatAvg > 90) {\n```\n\nbot.sendMessage(chat_id, \"Try to relax, you are stressed!\", \"Markdown\");\n\n```arduino\nbot.sendMessage(chat_id, \"Try to relax, you are stressed!\", \"Markdown\");\n```\n\n}\n\n```arduino\n}\n```\n\n// Show the display contents\n\n```arduino\n// Show the display contents\n```\n\ndisplay.display();\n\n```arduino\ndisplay.display();\n```\n\n// Print to serial for debugging\n\n```arduino\n// Print to serial for debugging\n```\n\nSerial.print(\"GSR: \");\n\n```arduino\nSerial.print(\"GSR: \");\n```\n\nSerial.print(GSR);\n\n```arduino\nSerial.print(GSR);\n```\n\nSerial.print(\" | Mapped GSR: \");\n\n```arduino\nSerial.print(\" | Mapped GSR: \");\n```\n\nSerial.print(GSR_percentage);\n\n```arduino\nSerial.print(GSR_percentage);\n```\n\nSerial.print(\" | Temp: \");\n\n```arduino\nSerial.print(\" | Temp: \");\n```\n\nSerial.print(temperature);\n\n```arduino\nSerial.print(temperature);\n```\n\nSerial.print(\" | BPM: \");\n\n```arduino\nSerial.print(\" | BPM: \");\n```\n\nSerial.println(beatAvg);\n\n```arduino\nSerial.println(beatAvg);\n```\n\n}\n\n```arduino\n}\n```\n\nThe code for this project is written in C++ using the Arduino IDE. It has been thoroughly tested for each individual component, and I have uploaded the complete code, along with detailed testing and explanations, to GitHub for easy access. The code is well-structured and includes comprehensive comments throughout, making it easy to understand for anyone, even those who are new to the project. Each section of the code is clearly documented to explain its purpose and functionality, ensuring that others can easily follow along and replicate the setup if needed.\n\n# Conclusion and Future Improvements\n\nThis project has demonstrated how sensors can be used to monitor stress indicators and transmit real-time data for visualization and analytics. The device could be expanded in the future to include additional parameters, such as blood pressure or oxygen levels, for more comprehensive health monitoring. Improvements to the data transmission system could also be made, such as adding Bluetooth functionality or improving Wi-Fi stability in areas with poor connectivity.\n\nFurther, the integration of machine learning models on the Telegram platform could provide predictive analytics, helping users manage their stress more effectively. Data collected over time can be analyzed to detect trends, providing insights into factors that trigger stress and enabling better stress management strategies.\n\nClick on the GitHub Image to view or download code\n\n# Start a Discussion on:\n\n# Add New Comment\n\nLog in or register to post comments"}
{"title":"IoT Based Smart Bin","content":"Our IoT-Based Smart Bin project features a custom-built IoT system and Firebase database, using the Arduino Uno R4 WiFi. Dual ultrasonic sensors handle motion and fill-level monitoring, with an automated lid synced to a Firebase dashboard built on Vite+React for real-time updates. This solution uniquely integrates our own IoT network for efficient waste management. We’re moving forward with multi-node testing to enhance scalability and user experience. If you want to use the normal arduino uno R3 in place of Arduino UNO R4 you can check out how to build a simple smart dustbin using Arduino, it almost has the same functionality but without IoT.\n\n# Components Required\n\nArduino UNO R4 WiFi - 1\n\nMG90S Servo Motor - 1\n\nHC-SR04 Ultrasonic Sensor - 2\n\nConnecting Jumper Wires - Required Quantity\n\nPower Bank\n\nNavigate to This YouTube Video for Full Demonstration of the Project\n\n# Circuit Explanation\n\nIn this IoT-based smart bin project, an Arduino Uno R4 WiFi acts as the central control unit, interfacing with two ultrasonic sensors and a servo motor. The power bank provides 5V via the USB-C port, supplying sufficient power for all components.\n\nFig 1. Automated trash bin setup using an ESP32, ultrasonic sensors, and a servo motor\n\nOne ultrasonic sensor is positioned to detect hand proximity, triggering the servo motor to open the bin lid when an object (like a hand) is nearby. This sensor sends a signal to the Arduino, which then activates the servo motor. The servo, mounted on the bin’s edge, functions as a lever, lifting the lid when the bin needs to open.\n\nThe second ultrasonic sensor monitors the bin’s fill level by measuring the distance from the sensor to the top of the garbage. When the detected distance indicates that the bin is full, a notification can be sent to a connected device (if implemented), or a status LED can be turned on.\n\nAll components are powered directly by the Arduino’s 5V supply, with wiring and connections visualized in the Fritzing diagram for easy assembly.\n\n# Code Explanation\n\nSetup\n\nFig 2. User interface of IoT-based Smart Bin displaying bin status, fill level, lid position, and sensor connectivity.\n\n# Libraries and Constants\n\nLibraries: Includes Servo, Firebase, and ArduinoJson libraries.\n\nLibraries: Includes Servo, Firebase, and ArduinoJson libraries.\n\nConstants: Define key pins (e.g., servoPin), WiFi credentials, and Firebase URL for configuration.\n\nConstants: Define key pins (e.g., servoPin), WiFi credentials, and Firebase URL for configuration.\n\n```arduino\nservoPin\n```\n\n# Variable Initialization\n\nKey variables are initialized to manage sensor readings, component statuses, and control flags. Examples include:\n\nlidDistance - Stores the measured distance from the lid sensor.\n\nlidDistance - Stores the measured distance from the lid sensor.\n\n```arduino\nlidDistance\n```\n\nisServoMoving - Flag indicating if the servo is currently moving.\n\nisServoMoving - Flag indicating if the servo is currently moving.\n\n```arduino\nisServoMoving\n```\n\nisMeasurementPaused - Pauses measurements during lid operation.\n\nisMeasurementPaused - Pauses measurements during lid operation.\n\n```arduino\nisMeasurementPaused\n```\n\n#include <Servo.h>\n\n```arduino\n#include <Servo.h>\n```\n\n#include <Firebase.h>\n\n```arduino\n#include <Firebase.h>\n```\n\n#include <ArduinoJson.h>\n\n```arduino\n#include <ArduinoJson.h>\n```\n\n#include \"secrets.h\"\n\n```arduino\n#include \"secrets.h\"\n```\n\n// Servo instance\n\n```arduino\n// Servo instance\n```\n\nServo myservo;\n\n```arduino\nServo myservo;\n```\n\n// Pin definitions\n\n```arduino\n// Pin definitions\n```\n\nconst int binLidTriggerPin = 7;\n\n```arduino\nconst int binLidTriggerPin = 7;\n```\n\nconst int binLidEchoPin = 6;\n\n```arduino\nconst int binLidEchoPin = 6;\n```\n\nconst int binStoreTriggerPin = 5;\n\n```arduino\nconst int binStoreTriggerPin = 5;\n```\n\nconst int binStoreEchoPin = 4;\n\n```arduino\nconst int binStoreEchoPin = 4;\n```\n\nconst int servoPin = 3;\n\n```arduino\nconst int servoPin = 3;\n```\n\n// Firebase instance\n\n```arduino\n// Firebase instance\n```\n\nFirebase fb(REFERENCE_URL);\n\n```arduino\nFirebase fb(REFERENCE_URL);\n```\n\n// Variables for distance measurement\n\n```arduino\n// Variables for distance measurement\n```\n\nfloat lidDistance;\n\n```arduino\nfloat lidDistance;\n```\n\nfloat storeDistance;\n\n```arduino\nfloat storeDistance;\n```\n\nfloat duration;\n\n```arduino\nfloat duration;\n```\n\nbool isServoMoving = false;\n\n```arduino\nbool isServoMoving = false;\n```\n\nunsigned long servoStartTime = 0;\n\n```arduino\nunsigned long servoStartTime = 0;\n```\n\nunsigned long measurementPauseTime = 0;\n\n```arduino\nunsigned long measurementPauseTime = 0;\n```\n\nbool isMeasurementPaused = false;\n\n```arduino\nbool isMeasurementPaused = false;\n```\n\n// Variables for pin status\n\n```arduino\n// Variables for pin status\n```\n\nbool lidSensorWorking = false;\n\n```arduino\nbool lidSensorWorking = false;\n```\n\nbool storeSensorWorking = false;\n\n```arduino\nbool storeSensorWorking = false;\n```\n\nbool servoWorking = false;\n\n```arduino\nbool servoWorking = false;\n```\n\nint binFillPercentage = 0;\n\n```arduino\nint binFillPercentage = 0;\n```\n\nbool binStatus = true;\n\n```arduino\nbool binStatus = true;\n```\n\nint binHeight = 30;\n\n```arduino\nint binHeight = 30;\n```\n\n# WiFi Connection\n\nConnects to WiFi, turning on the built-in LED if the connection is successful. This enables Firebase updates.\n\nComponent Configuration\n\nSets up ultrasonic sensor pins.\n\nSets up ultrasonic sensor pins.\n\nPositions servo motor at the initial angle (0 degrees).\n\nPositions servo motor at the initial angle (0 degrees).\n\nLoads bin configuration data from Firebase.\n\nLoads bin configuration data from Firebase.\n\nvoid setup() {\n\n```arduino\nvoid setup() {\n```\n\nSerial.begin(9600);\n\n```arduino\nSerial.begin(9600);\n```\n\ndelay(1000);\n\n```arduino\ndelay(1000);\n```\n\n// Initialize WiFi for non-Uno WiFi R4 boards\n\n```arduino\n// Initialize WiFi for non-Uno WiFi R4 boards\n```\n\n#if !defined(ARDUINO_UNOWIFIR4)\n\n```arduino\n#if !defined(ARDUINO_UNOWIFIR4)\n```\n\nWiFi.mode(WIFI_STA);\n\n```arduino\nWiFi.mode(WIFI_STA);\n```\n\n#else\n\n```arduino\n#else\n```\n\n// Configure LED for Uno WiFi R4\n\n```arduino\n// Configure LED for Uno WiFi R4\n```\n\npinMode(LED_BUILTIN, OUTPUT);\n\n```arduino\npinMode(LED_BUILTIN, OUTPUT);\n```\n\ndigitalWrite(LED_BUILTIN, LOW);\n\n```arduino\ndigitalWrite(LED_BUILTIN, LOW);\n```\n\n#endif\n\n```arduino\n#endif\n```\n\nWiFi.disconnect();\n\n```arduino\nWiFi.disconnect();\n```\n\ndelay(1000);\n\n```arduino\ndelay(1000);\n```\n\n// Connect to WiFi\n\n```arduino\n// Connect to WiFi\n```\n\nSerial.println();\n\n```arduino\nSerial.println();\n```\n\nSerial.println();\n\n```arduino\nSerial.println();\n```\n\nSerial.print(\"Connecting to: \");\n\n```arduino\nSerial.print(\"Connecting to: \");\n```\n\nSerial.println(WIFI_SSID);\n\n```arduino\nSerial.println(WIFI_SSID);\n```\n\nWiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n```arduino\nWiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n```\n\nwhile (WiFi.status() != WL_CONNECTED) {\n\n```arduino\nwhile (WiFi.status() != WL_CONNECTED) {\n```\n\nSerial.print(\"-\");\n\n```arduino\nSerial.print(\"-\");\n```\n\ndelay(500);\n\n```arduino\ndelay(500);\n```\n\n}\n\n```arduino\n}\n```\n\nSerial.println();\n\n```arduino\nSerial.println();\n```\n\nSerial.println(\"WiFi Connected\");\n\n```arduino\nSerial.println(\"WiFi Connected\");\n```\n\n// Turn on LED if Uno WiFi R4 is used\n\n```arduino\n// Turn on LED if Uno WiFi R4 is used\n```\n\n#if defined(ARDUINO_UNOWIFIR4)\n\n```arduino\n#if defined(ARDUINO_UNOWIFIR4)\n```\n\ndigitalWrite(LED_BUILTIN, HIGH);\n\n```arduino\ndigitalWrite(LED_BUILTIN, HIGH);\n```\n\n#endif\n\n```arduino\n#endif\n```\n\n// Pin setup for ultrasonic sensors\n\n```arduino\n// Pin setup for ultrasonic sensors\n```\n\npinMode(binLidTriggerPin, OUTPUT);\n\n```arduino\npinMode(binLidTriggerPin, OUTPUT);\n```\n\npinMode(binLidEchoPin, INPUT);\n\n```arduino\npinMode(binLidEchoPin, INPUT);\n```\n\npinMode(binStoreTriggerPin, OUTPUT);\n\n```arduino\npinMode(binStoreTriggerPin, OUTPUT);\n```\n\npinMode(binStoreEchoPin, INPUT);\n\n```arduino\npinMode(binStoreEchoPin, INPUT);\n```\n\ndigitalWrite(binLidTriggerPin, LOW);\n\n```arduino\ndigitalWrite(binLidTriggerPin, LOW);\n```\n\ndigitalWrite(binStoreTriggerPin, LOW);\n\n```arduino\ndigitalWrite(binStoreTriggerPin, LOW);\n```\n\n// Verify connections for ultrasonic sensors and servo\n\n```arduino\n// Verify connections for ultrasonic sensors and servo\n```\n\nlidSensorWorking = verifyUltrasonicSensor(binLidTriggerPin, binLidEchoPin);\n\n```arduino\nlidSensorWorking = verifyUltrasonicSensor(binLidTriggerPin, binLidEchoPin);\n```\n\nstoreSensorWorking = verifyUltrasonicSensor(binStoreTriggerPin, binStoreEchoPin);\n\n```arduino\nstoreSensorWorking = verifyUltrasonicSensor(binStoreTriggerPin, binStoreEchoPin);\n```\n\nmyservo.attach(servoPin);\n\n```arduino\nmyservo.attach(servoPin);\n```\n\nservoWorking = verifyServo();\n\n```arduino\nservoWorking = verifyServo();\n```\n\n// Initialize servo position\n\n```arduino\n// Initialize servo position\n```\n\nmyservo.write(0);\n\n```arduino\nmyservo.write(0);\n```\n\n// Initial Firebase update to get bin configuration\n\n```arduino\n// Initial Firebase update to get bin configuration\n```\n\ngetBinConfiguration();\n\n```arduino\ngetBinConfiguration();\n```\n\n}\n\n```arduino\n}\n```\n\n# Loop\n\nThe loop() function runs continuously to monitor bin operation.\n\n```arduino\nloop()\n```\n\nConfiguration Check\n\nFetches bin configuration from Firebase if a status change is detected.\n\nComponent Check\n\nVerifies if all components (lid sensor, store sensor, servo motor) are functioning. Pauses briefly (5 seconds) before rechecking if any component fails.\n\nLid Distance and Fill Level Measurement\n\nLid Distance: Measures distance to detect nearby objects for lid operation.\n\nLid Distance: Measures distance to detect nearby objects for lid operation.\n\nFill Level: Calculates the bin fill percentage and sends updates to Firebase if needed.\n\nFill Level: Calculates the bin fill percentage and sends updates to Firebase if needed.\n\nvoid loop() {\n\n```arduino\nvoid loop() {\n```\n\nif (!binStatus) {\n\n```arduino\nif (!binStatus) {\n```\n\nif (millis() % 10000 == 0) {  // Check status every 10 seconds\n\n```arduino\nif (millis() % 10000 == 0) {  // Check status every 10 seconds\n```\n\ngetBinConfiguration();\n\n```arduino\ngetBinConfiguration();\n```\n\n}\n\n```arduino\n}\n```\n\nreturn;\n\n```arduino\nreturn;\n```\n\n}\n\n```arduino\n}\n```\n\nif (!checkComponents()) return;\n\n```arduino\nif (!checkComponents()) return;\n```\n\nif (isMeasurementPaused) {\n\n```arduino\nif (isMeasurementPaused) {\n```\n\nif (millis() - measurementPauseTime >= 8000) {\n\n```arduino\nif (millis() - measurementPauseTime >= 8000) {\n```\n\nisMeasurementPaused = false;\n\n```arduino\nisMeasurementPaused = false;\n```\n\n}\n\n```arduino\n}\n```\n\nreturn;\n\n```arduino\nreturn;\n```\n\n}\n\n```arduino\n}\n```\n\nmeasureLidDistance();\n\n```arduino\nmeasureLidDistance();\n```\n\nif (lidSensorWorking && servoWorking && lidDistance < 5 && !isServoMoving) {\n\n```arduino\nif (lidSensorWorking && servoWorking && lidDistance < 5 && !isServoMoving) {\n```\n\noperateLid();\n\n```arduino\noperateLid();\n```\n\n}\n\n```arduino\n}\n```\n\nmeasureStoreLevel();\n\n```arduino\nmeasureStoreLevel();\n```\n\ndelay(100);\n\n```arduino\ndelay(100);\n```\n\n}\n\n```arduino\n}\n```\n\n# Key Functions\n\nComponent Verification (checkComponents())\n\n```arduino\ncheckComponents()\n```\n\nEnsures that the lid sensor, store sensor, and servo motor are working. If critical components are not functional, the function waits for 5 seconds before retrying.\n\nDistance Measurement (measureDistance())\n\n```arduino\nmeasureDistance()\n```\n\nMeasures distance by sending a pulse from the ultrasonic sensor and calculating the time for the echo to return. Returns -1 for reading errors.\n\nLid Operation (operateLid())\n\n```arduino\noperateLid()\n```\n\nControls the servo to open and close the lid:\n\nOpens lid by rotating servo to 180 degrees.\n\nOpens lid by rotating servo to 180 degrees.\n\nWaits for 4 seconds (time for disposal).\n\nWaits for 4 seconds (time for disposal).\n\nCloses lid by rotating servo back to 0 degrees.\n\nCloses lid by rotating servo back to 0 degrees.\n\nPauses measurements and updates Firebase with the current bin status.\n\nPauses measurements and updates Firebase with the current bin status.\n\nStore Level Measurement (measureStoreLevel())\n\n```arduino\nmeasureStoreLevel()\n```\n\nMeasures the fill level of the bin and calculates the fill percentage. Sends an alert to Firebase if the bin is nearly full (95% or higher).\n\nUtility Functions\n\nAdditional utility functions:\n\nverifyUltrasonicSensor(): Verifies if the ultrasonic sensor is functioning correctly by sending a test pulse.\n\nverifyUltrasonicSensor(): Verifies if the ultrasonic sensor is functioning correctly by sending a test pulse.\n\n```arduino\nverifyUltrasonicSensor()\n```\n\nverifyServo(): Ensures the servo motor is attached and responsive.\n\nverifyServo(): Ensures the servo motor is attached and responsive.\n\n```arduino\nverifyServo()\n```\n\ncalculateFillPercentage(): Converts the distance reading to a fill percentage based on bin dimensions.\n\ncalculateFillPercentage(): Converts the distance reading to a fill percentage based on bin dimensions.\n\n```arduino\ncalculateFillPercentage()\n```\n\n// Function to check component functionality\n\n```arduino\n// Function to check component functionality\n```\n\nbool checkComponents() {\n\n```arduino\nbool checkComponents() {\n```\n\nif (!lidSensorWorking && !storeSensorWorking && !servoWorking) {\n\n```arduino\nif (!lidSensorWorking && !storeSensorWorking && !servoWorking) {\n```\n\nSerial.println(\"Critical failure: No components working.\");\n\n```arduino\nSerial.println(\"Critical failure: No components working.\");\n```\n\ndelay(5000);\n\n```arduino\ndelay(5000);\n```\n\nreturn false;\n\n```arduino\nreturn false;\n```\n\n}\n\n```arduino\n}\n```\n\nreturn true;\n\n```arduino\nreturn true;\n```\n\n}\n\n```arduino\n}\n```\n\n// Function to handle lid distance measurement\n\n```arduino\n// Function to handle lid distance measurement\n```\n\nvoid measureLidDistance() {\n\n```arduino\nvoid measureLidDistance() {\n```\n\nif (lidSensorWorking) {\n\n```arduino\nif (lidSensorWorking) {\n```\n\nlidDistance = measureDistance(binLidTriggerPin, binLidEchoPin);\n\n```arduino\nlidDistance = measureDistance(binLidTriggerPin, binLidEchoPin);\n```\n\nif (lidDistance >= 0) {\n\n```arduino\nif (lidDistance >= 0) {\n```\n\nSerial.print(\"Lid Distance: \");\n\n```arduino\nSerial.print(\"Lid Distance: \");\n```\n\nSerial.print(lidDistance);\n\n```arduino\nSerial.print(lidDistance);\n```\n\nSerial.println(\" cm\");\n\n```arduino\nSerial.println(\" cm\");\n```\n\n}\n\n```arduino\n}\n```\n\nelse {\n\n```arduino\nelse {\n```\n\nSerial.println(\"Lid Sensor: Reading Error\");\n\n```arduino\nSerial.println(\"Lid Sensor: Reading Error\");\n```\n\n}\n\n```arduino\n}\n```\n\n}\n\n```arduino\n}\n```\n\n}\n\n```arduino\n}\n```\n\n// Function to perform lid opening operation\n\n```arduino\n// Function to perform lid opening operation\n```\n\nvoid operateLid() {\n\n```arduino\nvoid operateLid() {\n```\n\nisServoMoving = true;\n\n```arduino\nisServoMoving = true;\n```\n\nisMeasurementPaused = true;\n\n```arduino\nisMeasurementPaused = true;\n```\n\nmeasurementPauseTime = millis();\n\n```arduino\nmeasurementPauseTime = millis();\n```\n\nmyservo.write(180); // Open lid\n\n```arduino\nmyservo.write(180); // Open lid\n```\n\ndelay(4000);        // Wait for garbage to be thrown in\n\n```arduino\ndelay(4000);        // Wait for garbage to be thrown in\n```\n\nupdateFirebase();   // Update Firebase to show lid open\n\n```arduino\nupdateFirebase();   // Update Firebase to show lid open\n```\n\nSerial.println(\"Lid is Opened\");\n\n```arduino\nSerial.println(\"Lid is Opened\");\n```\n\nmyservo.write(0); // Close lid\n\n```arduino\nmyservo.write(0); // Close lid\n```\n\ndelay(1000);      // Short delay to ensure lid closes\n\n```arduino\ndelay(1000);      // Short delay to ensure lid closes\n```\n\nSerial.println(\"Lid is Closed\");\n\n```arduino\nSerial.println(\"Lid is Closed\");\n```\n\nisServoMoving = false;\n\n```arduino\nisServoMoving = false;\n```\n\nmeasureStoreLevel(); // Check bin store level\n\n```arduino\nmeasureStoreLevel(); // Check bin store level\n```\n\nupdateFirebase();    // Update Firebase with new data\n\n```arduino\nupdateFirebase();    // Update Firebase with new data\n```\n\n}\n\n```arduino\n}\n```\n\n// Measure bin store level and update bin fill percentage\n\n```arduino\n// Measure bin store level and update bin fill percentage\n```\n\nvoid measureStoreLevel() {\n\n```arduino\nvoid measureStoreLevel() {\n```\n\nif (storeSensorWorking && !isServoMoving) {\n\n```arduino\nif (storeSensorWorking && !isServoMoving) {\n```\n\nstoreDistance = measureDistance(binStoreTriggerPin, binStoreEchoPin);\n\n```arduino\nstoreDistance = measureDistance(binStoreTriggerPin, binStoreEchoPin);\n```\n\nif (storeDistance >= 0) {\n\n```arduino\nif (storeDistance >= 0) {\n```\n\nint newFillPercentage = calculateFillPercentage(storeDistance);\n\n```arduino\nint newFillPercentage = calculateFillPercentage(storeDistance);\n```\n\nif (newFillPercentage != binFillPercentage) {\n\n```arduino\nif (newFillPercentage != binFillPercentage) {\n```\n\nbinFillPercentage = newFillPercentage;\n\n```arduino\nbinFillPercentage = newFillPercentage;\n```\n\nSerial.print(\"Bin Fill: \");\n\n```arduino\nSerial.print(\"Bin Fill: \");\n```\n\nSerial.print(binFillPercentage);\n\n```arduino\nSerial.print(binFillPercentage);\n```\n\nSerial.println(\"%\");\n\n```arduino\nSerial.println(\"%\");\n```\n\nif (binFillPercentage >= 95) {\n\n```arduino\nif (binFillPercentage >= 95) {\n```\n\nSerial.println(\" **_ BIN FULL - ALERT! _**\");\n\n```arduino\nSerial.println(\" **_ BIN FULL - ALERT! _**\");\n```\n\n}\n\n```arduino\n}\n```\n\n}\n\n```arduino\n}\n```\n\n}\n\n```arduino\n}\n```\n\nelse {\n\n```arduino\nelse {\n```\n\nSerial.println(\"Bin Store Sensor: Reading Error\");\n\n```arduino\nSerial.println(\"Bin Store Sensor: Reading Error\");\n```\n\n}\n\n```arduino\n}\n```\n\n}\n\n```arduino\n}\n```\n\n}\n\n```arduino\n}\n```\n\n// Utility functions\n\n```arduino\n// Utility functions\n```\n\nbool verifyUltrasonicSensor(int trigPin, int echoPin) {\n\n```arduino\nbool verifyUltrasonicSensor(int trigPin, int echoPin) {\n```\n\nfor (int i = 0; i < 3; i++) {\n\n```arduino\nfor (int i = 0; i < 3; i++) {\n```\n\ndigitalWrite(trigPin, LOW);\n\n```arduino\ndigitalWrite(trigPin, LOW);\n```\n\ndelayMicroseconds(2);\n\n```arduino\ndelayMicroseconds(2);\n```\n\ndigitalWrite(trigPin, HIGH);\n\n```arduino\ndigitalWrite(trigPin, HIGH);\n```\n\ndelayMicroseconds(10);\n\n```arduino\ndelayMicroseconds(10);\n```\n\ndigitalWrite(trigPin, LOW);\n\n```arduino\ndigitalWrite(trigPin, LOW);\n```\n\nlong duration = pulseIn(echoPin, HIGH, 35000);\n\n```arduino\nlong duration = pulseIn(echoPin, HIGH, 35000);\n```\n\nif (duration > 0) {\n\n```arduino\nif (duration > 0) {\n```\n\nreturn true;\n\n```arduino\nreturn true;\n```\n\n}\n\n```arduino\n}\n```\n\ndelay(50);\n\n```arduino\ndelay(50);\n```\n\n}\n\n```arduino\n}\n```\n\nreturn false;\n\n```arduino\nreturn false;\n```\n\n}\n\n```arduino\n}\n```\n\nbool verifyServo() {\n\n```arduino\nbool verifyServo() {\n```\n\nreturn myservo.attached();\n\n```arduino\nreturn myservo.attached();\n```\n\n}\n\n```arduino\n}\n```\n\nfloat measureDistance(int trigPin, int echoPin) {\n\n```arduino\nfloat measureDistance(int trigPin, int echoPin) {\n```\n\ndigitalWrite(trigPin, LOW);\n\n```arduino\ndigitalWrite(trigPin, LOW);\n```\n\ndelayMicroseconds(2);\n\n```arduino\ndelayMicroseconds(2);\n```\n\ndigitalWrite(trigPin, HIGH);\n\n```arduino\ndigitalWrite(trigPin, HIGH);\n```\n\ndelayMicroseconds(10);\n\n```arduino\ndelayMicroseconds(10);\n```\n\ndigitalWrite(trigPin, LOW);\n\n```arduino\ndigitalWrite(trigPin, LOW);\n```\n\nduration = pulseIn(echoPin, HIGH);\n\n```arduino\nduration = pulseIn(echoPin, HIGH);\n```\n\nreturn (duration == 0) ? -1 : (duration * 0.034) / 2;\n\n```arduino\nreturn (duration == 0) ? -1 : (duration * 0.034) / 2;\n```\n\n}\n\n```arduino\n}\n```\n\nint calculateFillPercentage(float distance) {\n\n```arduino\nint calculateFillPercentage(float distance) {\n```\n\nif (distance >= binHeight)\n\n```arduino\nif (distance >= binHeight)\n```\n\nreturn 0;\n\n```arduino\nreturn 0;\n```\n\nif (distance <= 5)\n\n```arduino\nif (distance <= 5)\n```\n\nreturn 100;\n\n```arduino\nreturn 100;\n```\n\nreturn (int)(100 - ((distance - 5) * 100) / (binHeight - 5));\n\n```arduino\nreturn (int)(100 - ((distance - 5) * 100) / (binHeight - 5));\n```\n\n}\n\n```arduino\n}\n```\n\nClick on the GitHub Image to View or download code\n\n# Start a Discussion on:\n\n# Add New Comment\n\nLog in or register to post comments"}
{"title":"IntelliCart","content":"IntelliCart is a smart shopping cart system designed to transform the shopping experience by automating the checkout process and minimizing queue times. Using an RFID card, customers can start a shopping session with just a tap. As they add items to the cart, IntelliCart utilizes an integrated camera to detect and recognize products visually, which are then displayed on the mobile app in real time. This app also provides a live view of the cart contents, allowing customers to keep track of selected items, view product details, and manage their shopping list seamlessly. At checkout, the cart automatically calculates the total, making the payment process smooth and efficient.\n\n# Appendix: Component Requirements\n\nMicrocontrollers: Maixduino (K210), ESP32\n\nMicrocontrollers: Maixduino (K210), ESP32\n\nModules: RC522 RFID, SD Card, OLED display\n\nModules: RC522 RFID, SD Card, OLED display\n\nCommunication Protocols: UART (Maixduino → ESP32), SPI/I2C (ESP32 → RFID)\n\nCommunication Protocols: UART (Maixduino → ESP32), SPI/I2C (ESP32 → RFID)\n\nStorage: SD Card (CSV data file for product prices)\n\nStorage: SD Card (CSV data file for product prices)\n\nNavigate to This YouTube Video for Full Demonstration of the Project\n\n# System Design and Architecture\n\nSystem Flow\n\nSession Start:\n\nSession Start:\n\nThe customer scans the RFID card to begin the shopping session.\n\nThe cart is linked to the customer's profile.\n\nProduct Detection:\n\nProduct Detection:\n\nThe Maixduino (K210) module identifies items added to the cart through image processing.\n\nIt sends the detected product's name to the ESP32 via UART.\n\nProduct Details Display:\n\nProduct Details Display:\n\nESP32 retrieves the product details (name and price) from an SD card.\n\nIt displays the information on an OLED screen and updates the cloud via Wi-Fi.\n\nReal-Time Cart Monitoring:\n\nReal-Time Cart Monitoring:\n\nThe customer can view cart details, including products and prices, on their smartphone via a local HTML server hosted by ESP32.\n\nSession End and Checkout:\n\nSession End and Checkout:\n\nCustomer scans their RFID card again to finish shopping.\n\nESP32 calculates the total cost, displays it on the OLED, and sends it to the HTML server for viewing on the mobile app.\n\nPayment:\n\nPayment:\n\nPayment is completed at the checkout desk.\n\n# Hardware Integration\n\nModules and Communication Protocols\n\nMaixduino (K210) and ESP32 Communication:\n\nMaixduino (K210) and ESP32 Communication:\n\nEstablishes UART communication for data transfer.\n\nMaixduino detects and identifies products through image processing, then sends the product name to ESP32.\n\nData Format: Product name is sent in plain text (e.g., \"item_name\").\n\nRFID for Customer Identification:\n\nRFID for Customer Identification:\n\nRFID module (RC522) connects to ESP32 via SPI or I2C.\n\nCustomer scans their RFID to start/stop a shopping session.\n\nProcess:\n\nFirst scan: starts a session and links the cart to the customer.\n\nSecond scan: ends the session and triggers total calculation.\n\nSD Card for Product Data Storage:\n\nSD Card for Product Data Storage:\n\nStores a CSV file with product names and prices for retrieval by ESP32.\n\nCSV Format Example:\nApple,1.50\nBread,2.00\nMilk,1.20\n\nOLED Display:\n\nOLED Display:\n\nDisplays product details and total cost.\n\nExample Display:\nProduct: Bread\nPrice: ₹20.00\n\nHTML Server on ESP32:\n\nHTML Server on ESP32:\n\nHosts a local HTML server accessible on smartphones via the network (e.g., http://192.168.x.x).\n\nDisplays:\n\nCurrent list of products and prices.\n\nTotal amount due at checkout.\n\n# Software Development\n\nESP32 Code\n\nRFID Scanning (Customer Identification):\n\nRFID Scanning (Customer Identification):\n\nOn scanning RFID, initiates or ends a session and stores customer information.\n\nUART Communication (Maixduino → ESP32):\n\nUART Communication (Maixduino → ESP32):\n\nReceives product name from Maixduino via UART.\n\nSearches SD card for product price and displays it on the OLED.\n\nSD Card Lookup:\n\nSD Card Lookup:\n\nReads product data from CSV file.\n\nRetrieves the price for each item detected by Maixduino.\n\nCloud and Local Server Integration:\n\nCloud and Local Server Integration:\n\nSynchronizes cart data with the cloud and local HTML server.\n\nCustomers can view their shopping cart in real time.\n\nCheckout and Total Calculation:\n\nCheckout and Total Calculation:\n\nCalculates total amount when the customer scans their RFID again to end the session.\n\nDisplays total on OLED and sends it to the local HTML server.\n\nMaixduino Code\n\nProduct Detection:\n\nProduct Detection:\n\nIdentifies products through image processing.\n\nSends product name to ESP32 via UART in the format \"product_namen\".\n\nHTML Interface\n\nHosted by ESP32, the local HTML page displays:\n\nHosted by ESP32, the local HTML page displays:\n\nDynamic list of scanned products with prices.\n\nTotal amount due at checkout.\n\n# IntelliCart Hardware Design and Final Product Showcase\n\nSchematic Design Overview\n\nSchematic Design Overview\n\nThis section includes detailed schematic diagrams of IntelliCart’s hardware components, illustrating the connections and integrations between Maixduino, ESP32, RFID reader, SD card, OLED display, and any additional modules.\n\nFinal Product Photos\n\nFinal Product Photos\n\nHere, photos of the completed IntelliCart prototype are displayed, showcasing its design, assembly, and functional layout. These images will highlight the physical build quality and real-world usability of IntelliCart.\n\n# Testing & Validation\n\nInitial Testing\n\nRFID: Verify correct detection of customer ID and session initiation/termination.\n\nRFID: Verify correct detection of customer ID and session initiation/termination.\n\nUART Communication: Ensure successful product name transfer from Maixduino to ESP32.\n\nUART Communication: Ensure successful product name transfer from Maixduino to ESP32.\n\nSD Card Reading: Check accurate product-price retrieval from the SD card.\n\nSD Card Reading: Check accurate product-price retrieval from the SD card.\n\nOLED Display: Test display functionality for product and price details and checkout total.\n\nOLED Display: Test display functionality for product and price details and checkout total.\n\nUser Experience Testing\n\nMobile App/HTML Page: Ensure customers can view their cart details in real time.\n\nMobile App/HTML Page: Ensure customers can view their cart details in real time.\n\nSimulated Shopping Session: Test the workflow end-to-end, including: \nRFID scanning.\nProduct identification and price lookup.\nReal-time cart updates.\nCheckout and total calculation.\n\nSimulated Shopping Session: Test the workflow end-to-end, including: \nRFID scanning.\nProduct identification and price lookup.\nReal-time cart updates.\nCheckout and total calculation.\n\nProject Workflow Summary\n\nCustomer RFID Scan:\n\nCustomer RFID Scan:\n\nBegins shopping session; cart links to customer profile.\n\nProduct Detection:\n\nProduct Detection:\n\nMaixduino identifies products and sends names to ESP32.\n\nData Processing on ESP32:\n\nData Processing on ESP32:\n\nRetrieves prices from SD card.\n\nDisplays product info on OLED and updates the HTML server.\n\nReal-Time Cart Updates:\n\nReal-Time Cart Updates:\n\nCart updates in real-time on the mobile HTML page.\n\nCheckout:\n\nCheckout:\n\nCustomers re-scan RFID to complete shopping.\n\nESP32 calculates the total and updates the OLED and HTML pages.\n\n# Future Enhancements and Scalability\n\nIn future iterations, IntelliCart could incorporate advanced features to improve functionality, user engagement, and store integration. These updates are intended to make IntelliCart even more interactive, efficient, and competitive for modern retail environments.\n\nEnhanced Customer Interaction\n\nReal-Time Notifications: In later versions, we can introduce real-time notifications sent to the customer’s smartphone. These notifications would provide instant updates on products added, prices, and any available promotions.\n\nReal-Time Notifications: In later versions, we can introduce real-time notifications sent to the customer’s smartphone. These notifications would provide instant updates on products added, prices, and any available promotions.\n\nPersonalized Recommendations: By integrating customer profile data, IntelliCart could offer tailored recommendations, like showing seasonal deals or popular items based on the customer’s purchase history. This personalization would enhance the shopping experience and increase sales opportunities.\n\nPersonalized Recommendations: By integrating customer profile data, IntelliCart could offer tailored recommendations, like showing seasonal deals or popular items based on the customer’s purchase history. This personalization would enhance the shopping experience and increase sales opportunities.\n\nInteractive OLED Display with Additional Details: Future updates to the OLED display could include additional product details, such as product images, nutrition facts, and suggested pairings. This would create a more interactive shopping experience directly on the cart.\n\nInteractive OLED Display with Additional Details: Future updates to the OLED display could include additional product details, such as product images, nutrition facts, and suggested pairings. This would create a more interactive shopping experience directly on the cart.\n\nAdvanced Hardware Integration\n\nUpgraded Image Processing on Maixduino: To improve product recognition, we could use a more advanced model on Maixduino. This would enhance detection accuracy, especially in stores with diverse or similar-looking products. With a refined model, IntelliCart could handle complex product ranges with greater precision.\n\nUpgraded Image Processing on Maixduino: To improve product recognition, we could use a more advanced model on Maixduino. This would enhance detection accuracy, especially in stores with diverse or similar-looking products. With a refined model, IntelliCart could handle complex product ranges with greater precision.\n\nEnhanced Mobile and Web Integration\n\nQR Code Display for Easy Mobile Access: Displaying a QR code on the OLED screen for easy access to the HTML server is another valuable addition. By simply scanning the code, customers could instantly connect to the cart view on their smartphone, enhancing convenience and connectivity.\n\nQR Code Display for Easy Mobile Access: Displaying a QR code on the OLED screen for easy access to the HTML server is another valuable addition. By simply scanning the code, customers could instantly connect to the cart view on their smartphone, enhancing convenience and connectivity.\n\nDedicated Mobile App: In the future, a dedicated mobile app could replace or complement the HTML interface. An app would allow for a smoother interface, saved shopping lists, product wish lists and real-time push notifications. It could also provide loyalty points, promotions, and discounts tailored to the customer’s preferences.\n\nDedicated Mobile App: In the future, a dedicated mobile app could replace or complement the HTML interface. An app would allow for a smoother interface, saved shopping lists, product wish lists and real-time push notifications. It could also provide loyalty points, promotions, and discounts tailored to the customer’s preferences.\n\nSecurity and Anti-Theft Measures\n\nVerification at Exit: Future versions could integrate a checkout confirmation QR code. Once the customer completes their checkout on IntelliCart, the OLED could display this code. Store staff would then scan it to verify the purchase, enhancing security and reducing the risk of accidental or intentional theft.\n\nVerification at Exit: Future versions could integrate a checkout confirmation QR code. Once the customer completes their checkout on IntelliCart, the OLED could display this code. Store staff would then scan it to verify the purchase, enhancing security and reducing the risk of accidental or intentional theft.\n\nTamper Detection and Alerts: Another possible addition would be tamper detection mechanisms. If any discrepancies are detected (such as unmatched items between detected products and actual items), the system could alert store personnel immediately.\n\nTamper Detection and Alerts: Another possible addition would be tamper detection mechanisms. If any discrepancies are detected (such as unmatched items between detected products and actual items), the system could alert store personnel immediately.\n\nClick on the GitHub Image to view or download code\n\n# Start a Discussion on:\n\n# Add New Comment\n\nLog in or register to post comments"}
{"title":"PRAVESH - Smart Entry-Exit System","content":"PRAVESH is an RFID-enabled Smart Entry-Exit System designed to replace manual logs with a seamless digital solution. Using RFID cards, students can quickly and accurately log their entry and exit, reducing delays and improving accountability. Built on the Arduino UNO R4 Wi-Fi Board, PRAVESH integrates with campus infrastructure, providing real-time tracking, automated email notifications, and secure database storage. If you are looking to build something simple using RFID, you can also check out how to make an RFID Door Lock System using Arduino.\n\n# Impact Statement\n\nPRAVESH is an innovative RFID-enabled Smart Entry-Exit System developed to streamline entry and exit processes, aimed at replacing the current manual logbook method, which is time-consuming and prone to errors. By using RFID cards, students experience quick, hassle-free access without the need for manual entries, reducing delays and promoting accountability. The administration benefits significantly, with PRAVESH enabling paperless operations, efficient record management and real-time reporting Built with the Arduino UNO R4 Wi-Fi microcontroller, which provides internet connectivity, and a custom frontend interface that gets updated in real time with the database, PRAVESH logs each student’s entry and exit with details such as time, date, and personal information. The system also triggers an automated form email for visit purposes. We take pride in PRAVESH’s potential to modernize campus operations, improve security, and greatly enhance convenience for students.\n\n# Components Required\n\nArduino Uno R4 WiFi Board\n\nRC522 RFID Card Reader Module 13.56MHz\n\nRFID 13.56MHz Card and 13.56MHz RFID IC Key Tag\n\nRGB Led\n\n5V Passive Buzzer\n\nLCD1602 Parallel LCD Display with IIC/I2C interface\n\nIIC/I2C Serial Interface Adapter Module\n\n10K Ohm Resistor\n\nJumper Wires\n\nBread Board\n\nType-C USB Cable\n\nKey Features\n\nStreamlined Access: Fast, error-free RFID-based entry/exit system.\n\nStreamlined Access: Fast, error-free RFID-based entry/exit system.\n\nEnhanced Accountability: Automated logging provides accurate, real-time data.\n\nEnhanced Accountability: Automated logging provides accurate, real-time data.\n\nEfficient and Modernized: Integrates with campus systems for seamless operation.\n\nEfficient and Modernized: Integrates with campus systems for seamless operation.\n\nEco-Friendly: Automated emails reduce paperwork, offering a sustainable solution.\n\nEco-Friendly: Automated emails reduce paperwork, offering a sustainable solution.\n\nNavigate to this YouTube Video for Full Demonstration of the Project\n\n# Circuit Diagram Explanation\n\nNext, let's look at the connections used in this project. The circuit diagram is straightforward.\n\nNext, let's look at the connections used in this project. The circuit diagram is straightforward.\n\nFor Power Input,\nI am currently using my laptop which is connected using a usb cable. We can also use a 2S Li-ion battery pack, which provides an average voltage of 7.4V. This is connected to the Vin pin and ground of the Arduino UNO R4 WiFi Board.\n\nRFID Scanner Module Connections\n\nSDA -> Arduino pin 10\n\nSDA -> Arduino pin 10\n\nSCK -> Arduino pin 13\n\nSCK -> Arduino pin 13\n\nMOSI -> Arduino pin 11\n\nMOSI -> Arduino pin 11\n\nMISO -> Arduino pin 12\n\nMISO -> Arduino pin 12\n\nReset -> Arduino pin 9\n\nReset -> Arduino pin 9\n\nPower -> 3.3V on Arduino\n\nPower -> 3.3V on Arduino\n\nGround -> ground of  Arduino\n\nGround -> ground of  Arduino\n\nBuzzer:\n\nShared ground with the RGB LED.\n\nShared ground with the RGB LED.\n\nBuzzer pin -> Arduino pin 5\n\nBuzzer pin -> Arduino pin 5\n\nRGB LED:\n\nRed -> Arduino pin 3\n\nRed -> Arduino pin 3\n\nBlue -> Arduino pin 2\n\nBlue -> Arduino pin 2\n\nGreen -> Arduino pin 1\n\nGreen -> Arduino pin 1\n\nGround with resistor in between.\n\nGround with resistor in between.\n\nLCD Display (I2C Interface)\n\nSDA -> Arduino pin A4\n\nSDA -> Arduino pin A4\n\nSCL -> Arduino pin A5\n\nSCL -> Arduino pin A5\n\nVCC -> 5V output from Arduino\n\nVCC -> 5V output from Arduino\n\nGround -> Common ground with Arduino\n\nGround -> Common ground with Arduino\n\n# Arduino Code Explanation\n\nFor Better Explanation let's split the code into three parts: setup, loop, and supporting functions.\n\nSetup and Initialization:\n\nThis segment initializes the RFID reader, LEDs, buzzer, LCD, and connects to WiFi. It also displays the initial connection status on the LCD.\n\n#include <WiFiS3.h>\n#include <ArduinoHttpClient.h>\n#include <SPI.h>\n#include <MFRC522.h>\n#include <Wire.h>\n#include <LiquidCrystal_I2C.h>// Define constants\n#define RED_LED_PIN 1\n#define GREEN_LED_PIN 2\n#define BLUE_LED_PIN 3\n#define BUZZER_PIN 5 // Define the buzzer pinString URL = \"http://192.168.104.160/rfidattendance/test_data.php\";\nconst char* ssid = \"kk\"; // Your WiFi network name\nconst char* password = \"12345678\"; // Your WiFi password#define RST_PIN 9\n#define SS_PIN 10\n\n```arduino\n#include <WiFiS3.h>\n```\n\n```arduino\n#include <ArduinoHttpClient.h>\n```\n\n```arduino\n#include <SPI.h>\n```\n\n```arduino\n#include <MFRC522.h>\n```\n\n```arduino\n#include <Wire.h>\n```\n\n```arduino\n#include <LiquidCrystal_I2C.h>// Define constants\n```\n\n```arduino\n#define RED_LED_PIN 1\n```\n\n```arduino\n#define GREEN_LED_PIN 2\n```\n\n```arduino\n#define BLUE_LED_PIN 3\n```\n\n```arduino\n#define BUZZER_PIN 5 // Define the buzzer pinString URL = \"http://192.168.104.160/rfidattendance/test_data.php\";\n```\n\n```arduino\nconst char* ssid = \"kk\"; // Your WiFi network name\n```\n\n```arduino\nconst char* password = \"12345678\"; // Your WiFi password#define RST_PIN 9\n```\n\n```arduino\n#define SS_PIN 10\n```\n\nMFRC522 rfid(SS_PIN, RST_PIN); // Create MFRC522 instance\nWiFiClient wifiClient; // Create WiFiClient instance\nHttpClient client = HttpClient(wifiClient, \"192.168.104.160\", 80); // Use IP and port for the server\n\n```arduino\nMFRC522 rfid(SS_PIN, RST_PIN); // Create MFRC522 instance\n```\n\n```arduino\nWiFiClient wifiClient; // Create WiFiClient instance\n```\n\n```arduino\nHttpClient client = HttpClient(wifiClient, \"192.168.104.160\", 80); // Use IP and port for the server\n```\n\n// Initialize LCD with I2C address (0x27 is common, but check your LCD's documentation)\nLiquidCrystal_I2C lcd(0x27, 16, 2); // 16 columns, 2 rows\n\n```arduino\n// Initialize LCD with I2C address (0x27 is common, but check your LCD's documentation)\n```\n\n```arduino\nLiquidCrystal_I2C lcd(0x27, 16, 2); // 16 columns, 2 rows\n```\n\nvoid setup() {\nSerial.begin(115200);\nSPI.begin();\nrfid.PCD_Init(); // Initialize MFRC522\nSerial.println(\"RFID Reader initialized.\");\n\n```arduino\nvoid setup() {\n```\n\n```arduino\nSerial.begin(115200);\n```\n\n```arduino\nSPI.begin();\n```\n\n```arduino\nrfid.PCD_Init(); // Initialize MFRC522\n```\n\n```arduino\nSerial.println(\"RFID Reader initialized.\");\n```\n\n// Initialize LED pins\npinMode(RED_LED_PIN, OUTPUT);\npinMode(GREEN_LED_PIN, OUTPUT);\npinMode(BLUE_LED_PIN, OUTPUT);\npinMode(BUZZER_PIN, OUTPUT); // Initialize buzzer pin\n\n```arduino\n// Initialize LED pins\n```\n\n```arduino\npinMode(RED_LED_PIN, OUTPUT);\n```\n\n```arduino\npinMode(GREEN_LED_PIN, OUTPUT);\n```\n\n```arduino\npinMode(BLUE_LED_PIN, OUTPUT);\n```\n\n```arduino\npinMode(BUZZER_PIN, OUTPUT); // Initialize buzzer pin\n```\n\n// Initialize LEDs and buzzer to off\ndigitalWrite(RED_LED_PIN, HIGH);\ndigitalWrite(GREEN_LED_PIN, LOW);\ndigitalWrite(BLUE_LED_PIN, LOW);\ndigitalWrite(BUZZER_PIN, LOW);\n\n```arduino\n// Initialize LEDs and buzzer to off\n```\n\n```arduino\ndigitalWrite(RED_LED_PIN, HIGH);\n```\n\n```arduino\ndigitalWrite(GREEN_LED_PIN, LOW);\n```\n\n```arduino\ndigitalWrite(BLUE_LED_PIN, LOW);\n```\n\n```arduino\ndigitalWrite(BUZZER_PIN, LOW);\n```\n\n// Initialize LCD\nlcd.init();\nlcd.backlight(); // Turn on LCD backlight\nlcd.clear();\n\n```arduino\n// Initialize LCD\n```\n\n```arduino\nlcd.init();\n```\n\n```arduino\nlcd.backlight(); // Turn on LCD backlight\n```\n\n```arduino\nlcd.clear();\n```\n\n// Display initial message\nlcd.setCursor(0, 0);\nlcd.print(\"WiFi Connecting..\");\n\n```arduino\n// Display initial message\n```\n\n```arduino\nlcd.setCursor(0, 0);\n```\n\n```arduino\nlcd.print(\"WiFi Connecting..\");\n```\n\n// Connect to WiFi\nWiFi.begin(ssid, password);\nwhile (WiFi.status() != WL_CONNECTED) {\ndelay(1000);\n}\n\n```arduino\n// Connect to WiFi\n```\n\n```arduino\nWiFi.begin(ssid, password);\n```\n\n```arduino\nwhile (WiFi.status() != WL_CONNECTED) {\n```\n\n```arduino\ndelay(1000);\n```\n\n```arduino\n}\n```\n\nSerial.println(\"nConnected to WiFi!\");\nSerial.print(\"IP Address: \");\nSerial.println(WiFi.localIP());\nlcd.clear();\nlcd.setCursor(0, 0);\nlcd.print(\"WiFi Connected\");\ndelay(2000); // Wait before starting the loop\n}\n\n```arduino\nSerial.println(\"nConnected to WiFi!\");\n```\n\n```arduino\nSerial.print(\"IP Address: \");\n```\n\n```arduino\nSerial.println(WiFi.localIP());\n```\n\n```arduino\nlcd.clear();\n```\n\n```arduino\nlcd.setCursor(0, 0);\n```\n\n```arduino\nlcd.print(\"WiFi Connected\");\n```\n\n```arduino\ndelay(2000); // Wait before starting the loop\n```\n\n```arduino\n}\n```\n\nWi-Fi and RFID Status Check:\n\nThis part checks Wi-Fi connectivity and prompts the user to scan their RFID card. The LCD displays appropriate messages, and LEDs indicate WiFi status.\n\nvoid loop() {\nif (WiFi.status() != WL_CONNECTED) {\n// If not connected to Wi-Fi, display \"WiFi not connected\"\nlcd.clear();\nlcd.setCursor(0, 0);\nlcd.print(\"WiFi not connected\");\ndigitalWrite(RED_LED_PIN, HIGH); // Red LED on\ndigitalWrite(GREEN_LED_PIN, LOW);\ndigitalWrite(BLUE_LED_PIN, LOW);\nreturn;\n} else {\n// If connected to Wi-Fi, display \"Scan your card\"\nlcd.clear();\nlcd.setCursor(0, 0);\nlcd.print(\"Scan your card\");\ndigitalWrite(RED_LED_PIN, LOW);\ndigitalWrite(GREEN_LED_PIN, HIGH); // Green LED on\ndigitalWrite(BLUE_LED_PIN, LOW);\n}\n\n```arduino\nvoid loop() {\n```\n\n```arduino\nif (WiFi.status() != WL_CONNECTED) {\n```\n\n```arduino\n// If not connected to Wi-Fi, display \"WiFi not connected\"\n```\n\n```arduino\nlcd.clear();\n```\n\n```arduino\nlcd.setCursor(0, 0);\n```\n\n```arduino\nlcd.print(\"WiFi not connected\");\n```\n\n```arduino\ndigitalWrite(RED_LED_PIN, HIGH); // Red LED on\n```\n\n```arduino\ndigitalWrite(GREEN_LED_PIN, LOW);\n```\n\n```arduino\ndigitalWrite(BLUE_LED_PIN, LOW);\n```\n\n```arduino\nreturn;\n```\n\n```arduino\n} else {\n```\n\n```arduino\n// If connected to Wi-Fi, display \"Scan your card\"\n```\n\n```arduino\nlcd.clear();\n```\n\n```arduino\nlcd.setCursor(0, 0);\n```\n\n```arduino\nlcd.print(\"Scan your card\");\n```\n\n```arduino\ndigitalWrite(RED_LED_PIN, LOW);\n```\n\n```arduino\ndigitalWrite(GREEN_LED_PIN, HIGH); // Green LED on\n```\n\n```arduino\ndigitalWrite(BLUE_LED_PIN, LOW);\n```\n\n```arduino\n}\n```\n\nRFID Scanning and UID Transmission:\n\nThis segment reads the RFID UID, displays a \"Wait\" message on the LCD, and sends the UID to the server. It handles server response and updates the LCD and LEDs accordingly.\n\n// Look for new RFID tags\nif (!rfid.PICC_IsNewCardPresent() || !rfid.PICC_ReadCardSerial()) {\nreturn;\n}// Read UID\nString uid = \"\";\nfor (byte i = 0; i < rfid.uid.size; i++) {\nif (rfid.uid.uidByte[i] < 0x10) {\nuid += \"0\"; // Add leading zero if needed\n}\nuid += String(rfid.uid.uidByte[i], HEX);\n}// Print the UID\nSerial.print(\"UID tag: \");\nSerial.println(uid);\n\n```arduino\n// Look for new RFID tags\n```\n\n```arduino\nif (!rfid.PICC_IsNewCardPresent() || !rfid.PICC_ReadCardSerial()) {\n```\n\n```arduino\nreturn;\n```\n\n```arduino\n}// Read UID\n```\n\n```arduino\nString uid = \"\";\n```\n\n```arduino\nfor (byte i = 0; i < rfid.uid.size; i++) {\n```\n\n```arduino\nif (rfid.uid.uidByte[i] < 0x10) {\n```\n\n```arduino\nuid += \"0\"; // Add leading zero if needed\n```\n\n```arduino\n}\n```\n\n```arduino\nuid += String(rfid.uid.uidByte[i], HEX);\n```\n\n```arduino\n}// Print the UID\n```\n\n```arduino\nSerial.print(\"UID tag: \");\n```\n\n```arduino\nSerial.println(uid);\n```\n\n// Display \"Wait\" on LCD and turn on blue LED and buzzer when tag is read\nlcd.clear();\nlcd.setCursor(0, 0);\nlcd.print(\"Wait\");\ndigitalWrite(BLUE_LED_PIN, HIGH); // Blue LED on\ndigitalWrite(BUZZER_PIN, HIGH); // Buzzer on\n\n```arduino\n// Display \"Wait\" on LCD and turn on blue LED and buzzer when tag is read\n```\n\n```arduino\nlcd.clear();\n```\n\n```arduino\nlcd.setCursor(0, 0);\n```\n\n```arduino\nlcd.print(\"Wait\");\n```\n\n```arduino\ndigitalWrite(BLUE_LED_PIN, HIGH); // Blue LED on\n```\n\n```arduino\ndigitalWrite(BUZZER_PIN, HIGH); // Buzzer on\n```\n\n// Send UID to server\nString postData = \"uid=\" + uid;\nclient.beginRequest();\nclient.post(\"/rfidattendance/test_data.php\");\nclient.sendHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\nclient.sendHeader(\"Content-Length\", postData.length());\nclient.beginBody();\nclient.print(postData);\nclient.endRequest();\n\n```arduino\n// Send UID to server\n```\n\n```arduino\nString postData = \"uid=\" + uid;\n```\n\n```arduino\nclient.beginRequest();\n```\n\n```arduino\nclient.post(\"/rfidattendance/test_data.php\");\n```\n\n```arduino\nclient.sendHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n```\n\n```arduino\nclient.sendHeader(\"Content-Length\", postData.length());\n```\n\n```arduino\nclient.beginBody();\n```\n\n```arduino\nclient.print(postData);\n```\n\n```arduino\nclient.endRequest();\n```\n\nint statusCode = client.responseStatusCode();\nString response = client.responseBody();\n\n```arduino\nint statusCode = client.responseStatusCode();\n```\n\n```arduino\nString response = client.responseBody();\n```\n\nSerial.print(\"Status code: \");\nSerial.println(statusCode);\nSerial.print(\"Response: \");\nSerial.println(response);\nSerial.println(\"------------------------------------------\");\n\n```arduino\nSerial.print(\"Status code: \");\n```\n\n```arduino\nSerial.println(statusCode);\n```\n\n```arduino\nSerial.print(\"Response: \");\n```\n\n```arduino\nSerial.println(response);\n```\n\n```arduino\nSerial.println(\"------------------------------------------\");\n```\n\n// After sending UID, turn off blue LED, buzzer, and display \"Thank you\"\ndigitalWrite(BLUE_LED_PIN, LOW);\ndigitalWrite(BUZZER_PIN, LOW);\ndigitalWrite(GREEN_LED_PIN, HIGH); // Green LED back on\nlcd.clear();\nlcd.setCursor(0, 0);\nlcd.print(\"Thank you\");\ndelay(2000); // Show \"Thank you\" for 2 seconds\n\n```arduino\n// After sending UID, turn off blue LED, buzzer, and display \"Thank you\"\n```\n\n```arduino\ndigitalWrite(BLUE_LED_PIN, LOW);\n```\n\n```arduino\ndigitalWrite(BUZZER_PIN, LOW);\n```\n\n```arduino\ndigitalWrite(GREEN_LED_PIN, HIGH); // Green LED back on\n```\n\n```arduino\nlcd.clear();\n```\n\n```arduino\nlcd.setCursor(0, 0);\n```\n\n```arduino\nlcd.print(\"Thank you\");\n```\n\n```arduino\ndelay(2000); // Show \"Thank you\" for 2 seconds\n```\n\n// Display \"Scan your card\" again\nlcd.clear();\nlcd.setCursor(0, 0);\nlcd.print(\"Scan your card\");\n\n```arduino\n// Display \"Scan your card\" again\n```\n\n```arduino\nlcd.clear();\n```\n\n```arduino\nlcd.setCursor(0, 0);\n```\n\n```arduino\nlcd.print(\"Scan your card\");\n```\n\n// Halt PICC\nrfid.PICC_HaltA();\n// Stop encryption on PCD\nrfid.PCD_StopCrypto1();\n\n```arduino\n// Halt PICC\n```\n\n```arduino\nrfid.PICC_HaltA();\n```\n\n```arduino\n// Stop encryption on PCD\n```\n\n```arduino\nrfid.PCD_StopCrypto1();\n```\n\ndelay(5000); // Short delay to prevent rapid switching\n}\n\n```arduino\ndelay(5000); // Short delay to prevent rapid switching\n```\n\n```arduino\n}\n```\n\n# Working Demonstration\n\nBelow, you can see the working images of the project\n\nNot Connected to Wi-Fi (LED is Red), the screen shows “WiFi Connecting”.\n\nNot Connected to Wi-Fi (LED is Red), the screen shows “WiFi Connecting”.\n\nConnect to Wi-Fi, screen displays \"Wi-Fi Connected\".\n\nConnect to Wi-Fi, screen displays \"Wi-Fi Connected\".\n\nConnected to Wi-Fi (LED Turning Green signifying the system is ready to be used), also screen displays “Scan your card”.\n\nConnected to Wi-Fi (LED Turning Green signifying the system is ready to be used), also screen displays “Scan your card”.\n\nRFID Scanned and sending UID to the server (Screen Showing “Wait”, signifying wait time before tapping the next rfid card). On successful scanning the screen shows \"Thank You\" for confirmation.\n\nRFID Scanned and sending UID to the server (Screen Showing “Wait”, signifying wait time before tapping the next rfid card). On successful scanning the screen shows \"Thank You\" for confirmation.\n\nRFID Scanned Successfully, display shows \"Scan Your Card\" signifying the system is ready to be used again.\n\nRFID Scanned Successfully, display shows \"Scan Your Card\" signifying the system is ready to be used again.\n\n# Working of the RFID Wi-Fi Access Control System\n\nThis project functions as an RFID-based access control system that uses an Arduino Uno R4 Wi-Fi to connect to a server, send card UID, and provide real-time feedback using LEDs, display and a buzzer. The system operates as follows:\n\nSetup and Initialization:\n\nUpon powering on, the Arduino Uno R4 Wi-Fi connects to the configured Wi-Fi network. If connected successfully, the green LED turns on and the display shows “Scan your card” to indicate network readiness. Meanwhile, the RFID reader (MFRC522) and other output components are also initialized.\n\nWi-Fi Status Check:\n\nIn each loop iteration, the Arduino Uno R4 Wi-Fi checks its Wi-Fi connection status. If disconnected, the red LED lights up to signal this, also the screen shows “WiFi connecting..”. Once Wi-Fi reconnects, the red LED turns off and the green LED turns back on, the screen now shows “WiFi connected”.\n\nRFID Tag Detection:\n\nThe RFID reader continuously scans for new RFID tags. When a tag is detected, the reader retrieves the UID, a unique identifier for each tag. This UID is converted to a string for easy transmission.\n\nVisual and Audio Feedback:\n\nUpon detecting an RFID tag, the system lights up the LED and activates the buzzer, also the screen changes to “wait” indicating wait time between two rfid scans. This provides an immediate indication to the user that their tag has been scanned.\n\nData Transmission to Server:\n\nThe UID is sent to the server using an HTTP POST request. The server URL is predefined, and the UID data is posted to the endpoint /rfidattendancet/test_data.php. The server response status and body are printed to the Serial Monitor for debugging and confirmation.\n\nCompletion and Reset:\n\nAfter the UID is successfully sent, the system changes the “wait” display to “scan your card”, readying the system for the next scan. The RFID reader halts communication with the card to conserve power until the next tag is detected.\n\nEmail functionality:\n\nDuring the Data Transmission to Server step , the UID is also matched to the email of respective person and an form is sent to the registered email id of the person with the reason for visit and return time estimate thing , after the user fills that and submits the form , it automatically updates at the database .\n\nThe form which will open from the link in the mail sent is:\n\nDelay and Repeat:\n\nA short delay prevents the system from reading the same card multiple times too quickly. The system then loops back to check for Wi-Fi status and new RFID tags, maintaining continuous operation.\n\n# Custom Frontend Development\n\nWe have crafted a sleek and intuitive frontend using HTML and CSS, ensuring a visually appealing website that not only meets the aesthetic needs but also serves the functional requirements for managing the system. The frontend is designed to provide ease of access and streamline the administration process.\n\nTo store and manage data, we integrated a MySQL database that holds user and log information securely. The backend communication with the MySQL database is handled efficiently using PHP, ensuring smooth handling of POST requests from the Arduino UNO R4 Wi-Fi board and seamless data retrieval.\n\nThe frontend consists of the following key pages:\n\nLogin Page\n\nThis page serves as the authentication gateway, ensuring that only authorized personnel can access sensitive data. Users can log in using their admin email ID and password, providing a secure and controlled access point to the system.\n\nUsers Page\n\nThis page displays a list of all users currently registered in the system. The user details shown include:\n\nUser ID\n\nUser ID\n\nUID\n\nUID\n\nName\n\nName\n\nEmail ID\n\nEmail ID\n\nThe Users Page allows administrators to quickly view the status of all registered users.\n\nManage Users Page\n\nThis page enables administrators to perform key user management tasks:\n\nAdding New Users: Easily register new users with necessary details.\n\nUpdating Existing User Details: Modify user information, including:\n\nID\n\nID\n\nName\n\nName\n\nGender\n\nGender\n\nS. No.\n\nS. No.\n\nEmail ID\n\nEmail ID\n\nRemoving Users: Administrators can remove users from the system as needed.\n\nUsers Log Page\n\nThis page presents a comprehensive log of student entry and exit details. The information displayed includes:\n\nUser ID\n\nUser ID\n\nCard UID\n\nCard UID\n\nName\n\nName\n\nGender\n\nGender\n\nDate and Time of Entry/Exit\n\nDate and Time of Entry/Exit\n\nReason for Visit\n\nReason for Visit\n\nEstimated Time of Return\n\nEstimated Time of Return\n\nThe Users Log Page offers administrators an easy-to-navigate interface to monitor all student movements in real-time.\n\nExport to Excel Page\n\nThe Export to Excel page provides the ability to download Users Log Page data in an Excel (.xlsx) format. Administrators can filter logs based on date and time, allowing for custom export of specific periods for further analysis or record-keeping.\n\nWith this frontend setup, we have ensured a well-structured, user-friendly, and secure interface for managing and accessing data, making the administration process smoother and more efficient.\n\nClick on the GitHub Image to view or download code\n\n# Start a Discussion on:\n\n# Add New Comment\n\nLog in or register to post comments"}
{"title":"IIot Test Bed Using Maixduino","content":"The main idea of this project is to develop a test bed for Industrial Internet of Things to monitor parameters like temperature, humidity, light level, DC motor RPM and its power consumption. Sipeed Maixduino board act as the processing unit to measure, process and display the parameters in the LCD. Further the data is transferred to a host PC to feed the data to Adafruit IO platform.\n\n# Components Used:\n\n1.    Sipeed Maixduino Kit for RISC-V AI + IoT\n2.    DHT 11 temperature and humidity sensor\n3.    BH1750 Light sensor\n4.    1000 RPM DC motor\n5.    L298N dual H-Bridge motor driver\n6.    Opto-interrupter sensor or IR LED sensor module\n7.    INA219 current sensor module\n8.    30 slot rotary encoder disc mechanism and arrangement to hold the motor.\n9.    12 V 5 A DC power adopter for DC motor\n\n# To see the full demonstration video, click on the YouTube Video below.\n\n<\n\n# Project Description:\n\nThis prototype could be used as a IIoT test bed for data collection, processing and to upload data to cloud platform. DC motor RPM and its power consumption measurement is vital in predicting faults and analyzing the motor life in industrial applications. In this prototype 30 slot rotating disc mechanism and holder for DC motor is developed using 3D printing. Used any cubic Kobra2 neo printer and PETG material for making the mechanism. The mechanism holds the motor as well as the opto interrupter as shown in Fig 1 below.\n\nFig 1: 3D printed 30 slot encoder disc and motor holding mechanism.\n\nWhenever the DC motor is enabled with defined duty cycle, 30 slot encoder disc mechanism mounter with the DC motor starts rotating, further the opto-interrupter starts to detect the number of ticks per slot detected and increments the counter value up to 30 counts in this setup since the encoder disc has 30 slots.  One complete rotation takes 30 count value. Based on the slot counted for defined interval motor speed is computed. Along with this current and power consumption of the motor also measured using the INA 219 current sensor module. DHT11 sensor is used to measure the Ambient temperature and relative humidity of the test environment. Light sensor BH1750 is used to measure the light intensity. Opto interrupter sensor is used to detect the disc rotation to compute the motor speed. Below Fig2 shows the working setup of the developed system.\n\n# Circuit Description:\n\nBH1750 and INA219 sensor modules are I2C compatible and their SDA and SCL lines are connected to the Maixduino SDA and SCL pins respectively for data communication. DHT11 sensor supports onewire interface and it’s connected to PIN3 of Maixduino. Opto interrupter sensor output is connected to the PIN2 of Maixduino. L298N H-Bridge motor driver is used to control the speed of 1000 RPM DC motor. ENA pin of motor driver is connected to PIN6, Motor input IN1 and IN2 are connected to PIN8 and PIN9 of Maixduino. DC motor connected with OUT1 terminals of motor driver module. To measure the current and power consumption of DC motor, motor drive module is power with a 12V 5A DC power adopter through the INA219 module. Circuit diagram of the developed system is shown in Fig 3. Maixduino detects and computes the motor speed, current and power consumed, temperature and relative humidity and light level. Further the computed data are transferred to the host PC via serial communication and onboard LCD display of Maixduino.\n\nFig 3: circuit diagram of the developed system\n\n# Software description:\n\nArduino IDE is used for the code development. The code utilizes wire.h, for I2C communication and BH1750.h for reading data from BH1750 sensor, INA219.h for reading data from current sensor module. DHT11.h is used for reading temperature and humidity data. Sipeed_ST7789.h is used for the display utilization.\n\nBelow are the few functions created:\n\n1.    title() – This function, initializes the display and print project title on the display \n2.    motorinit() – This function, initializes the motor settings (ENA to control speed, IN1 & IN2 for direction and motor control.\n3.    motoroff() – This function turns off the motor\n4.    motoronforward() – This function, moves the motor in forward direction\n5.    motoronbackward() – This function, moves the motor in backward direction\n6.    RPM_speed(int a) – This function, get the duty cycle value for the motor speed\n7.    readlight() – This function, reads the light value and update the value display and send it to serial port\n8.    readrpm() – This function computes the RPM and update the value in display and send it to serial port\n9.    readINA() – This function reads the current and power consumption data and update the value in display and send it to serial port\n10.    temphumi() – This function reads the temperature and humidity values and update the values in display and send it to serial port\n\n```arduino\ntitle()\n```\n\n```arduino\nmotorinit()\n```\n\n```arduino\nmotoroff()\n```\n\n```arduino\nmotoronforward()\n```\n\n```arduino\nmotoronbackward()\n```\n\n```arduino\nRPM_speed(int a)\n```\n\n```arduino\nreadlight()\n```\n\n```arduino\nreadrpm()\n```\n\n```arduino\nreadINA()\n```\n\n```arduino\ntemphumi()\n```\n\nThe code initializes required settings in the void setup() and void loop() has the function calls to read the sensor data and update the display and transfer the data over serial communication to host PC.\n\nResults:\n\nBelow Fig 4 & Fig 5 shows the display of measurement parameters during Motor OFF and Motor ON state.  Fig 6 shows the measurement data collected on the serial port of the host PC.\n\nFig 4: Measurement data on display during Motor OFF\n\nFig 5: Measurement data on display during Motor ON\n\nFig 6A: Measurement data collected on the serial port of the host PC\n\nFig 6B: measurement of data with python script to read the serial data on the host PC\n\n# Future enhancement:\n\nAt its present status, the developed system is not having IIoT enablement. In future, host PC can forward data or from the Maixduino through Wi-Fi communication can send data to Adafruit IO or similar cloud platforms to have the IoT connectivity, through the IoT platform further motor speed could be controlled and monitored for motor fault analysis and prediction of motor life which enables the complete IIoT system. Initially it was planned to measure the motor speed through the on-board camera on Maixduino, in future it will also been carried out to enable machine vision capability. In connection to this work, dashboard is created with Adafruit IO for the IIoT enablement as shown in Fig 7.\n\nFig 7: Adafruit IO dashboard view for the developed system\n\nTo view the code and schematics of the project, please click on the GitHub icon below.\n\n# Complete Project Code\n\n```arduino\n/*\nThis code is tested working with Sipeed Maixduino\nit measures following parameters:\n1. light intensity (BH1750 sensor),\n2. temperature & Humidity (DHT11 sensor), \n3. current and power consumption of DC motor (INA219 module)\n4. DC Motor Rotation per minute (Opto interruptor sensor reads DC motor rotation through the 30 slot mechanism. DC motor connected with L293N module)  \nall the measured parameters values are updated in the Sipeed ST7789 display and transferred via serial port at 115200 baud rate.\nModified and updated by K. Vairamani on 08/11/2024\n*/\n#include <Sipeed_ST7789.h>\n#include<BH1750.h>\n#include<Wire.h>\n#include \"INA219.h\"\n#include <DHT11.h>\nDHT11 dht11(3);\nINA219 INA(0x41);\nBH1750 lightMeter;\nunsigned long start_time = 0;\nunsigned long end_time = 0;\nint steps=0;\nfloat steps_old=0;\nfloat temp=0;\nfloat RPS=0;\nfloat RPM = 0;\nint counter = 2; //opto interruptor pin \nunsigned long millisBefore;\nvolatile int slotcount;\nint temperature = 0;\nint humidity = 0;\nSPIClass spi_(SPI0); // MUST be SPI0 for Maix series on board LCD\nSipeed_ST7789 lcd(320, 240, spi_);\n//L298N pin connections\nint PWM_EN = 6; //Connected to enable pin for L298N module\nint M1 = 8; // Connected to IN1 of L298N module\nint M2 = 9; // Connected to IN2 of L298N module\n//funtion protypes\nvoid title();\nvoid motorinit();\nvoid motoroff();\nvoid motoronforward();\nvoid motoronbackward();\nvoid RPM_speed(int a);\nvoid readlight();\nvoid readrpm();\nvoid readINA();\nvoid temphumi();\nvoid setup()\n{\n   Wire.begin();\n   Serial.begin(115200);\n   motorinit();\n   motoroff(); \n   pinMode(counter, INPUT_PULLUP);\n   lightMeter.begin();\n   if (!INA.begin() )\n   {\n       Serial.println(\"Could not connect to INA219. Fix and Reboot\");\n   }\n   INA.setMaxCurrentShunt(5, 0.002);\n   delay(1000);\n   lcd.begin(15000000, COLOR_BLUE);    \n   lcd.setRotation(0);\n\n}\nvoid loop() {\n title();\n readlight();  \n temphumi();\n RPM_speed(255); //Duty Cycle 100%\n motoronforward();\n readINA();\n readrpm();\n//  motoroff();\n delay(1000);\n}\n \nvoid motorinit()\n{\n // Set all the motor control pins to outputs\n    pinMode(PWM_EN, OUTPUT);\n    pinMode(M1, OUTPUT);\n    pinMode(M2, OUTPUT);\n}\nvoid motoroff()\n{    \n    // Turn off motors\n    digitalWrite(M1, LOW);\n    digitalWrite(M2, LOW);\n}\nvoid motoronforward()\n{\n // Turn ON motors Forward rotation\n    digitalWrite(M1, HIGH);\n    digitalWrite(M2, LOW);\n}\nvoid motoronbackward()\n{\n // Turn ON motors backward rotation\n    digitalWrite(M1, LOW);\n    digitalWrite(M2, HIGH);\n}\nvoid RPM_speed(int a)\n{\n analogWrite(PWM_EN, a);\n}\nvoid readrpm()\n{\n //lcd.print(\"RPM m/s: \");\n start_time=millis();\n end_time=start_time+1000;\n while(millis()<end_time)\n {\n   if(digitalRead(counter))\n   {\n     steps=steps+1; \n     while(digitalRead(counter));\n  }\n }\n temp=steps-steps_old;\n steps_old=steps;\n RPS=(temp/30); //change yoursRevolution encoder slot here Example: 30\n RPM=(RPS*60);\n Serial.print(\"RPM:\");\n Serial.println(RPM);\n lcd.setCursor(1,190);\n lcd.print(\"Motor RPM:\");\n lcd.setCursor(180,190);\n lcd.println(RPM);\n}\nvoid readlight()\n{\n float lux = lightMeter.readLightLevel();\n Serial.print(\"Light lx:\");\n Serial.print(lux,2);\n Serial.print(',');\n lcd.setCursor(1,70);\n lcd.print(\"Light lx: \");\n lcd.setCursor(180,70);\n lcd.println(lux);\n \n}\nvoid title()\n{\n   lcd.fillScreen(COLOR_BLUE);\n   lcd.setTextSize(2);\n   lcd.setTextColor(COLOR_WHITE);\n   lcd.setCursor(60,10);\n   lcd.println(\"Sipeed MAIXDUINO\");\n   lcd.setCursor(60,40);\n   lcd.println(\"IIoT test bed\");\n}\nvoid readINA()\n{\n lcd.setCursor(1,130);\n lcd.print(\"Shunt mV: \");\n lcd.setCursor(180,130);\n lcd.print(INA.getShuntVoltage_mV(), 2);\n lcd.setCursor(1,150);\n lcd.print(\"Current mA\");\n lcd.setCursor(180,150);\n lcd.print(INA.getCurrent_mA(), 2);\n lcd.setCursor(1,170);\n lcd.print(\"Power mW:\");\n lcd.setCursor(180,170);\n lcd.print(INA.getPower_mW(), 2);\n Serial.print(\"Current mA:\");\n Serial.print(INA.getCurrent_mA(), 2);\n Serial.print(\",\");\n Serial.print(\"Power mW:\");\n Serial.print(INA.getPower_mW(), 2);\n Serial.print(\",\");\n}\nvoid temphumi()\n{\n     // Attempt to read the temperature and humidity values from the DHT11 sensor.\n   int result = dht11.readTemperatureHumidity(temperature, humidity);\n   // Check the results of the readings.\n   // If the reading is successful, print the temperature and humidity values.\n   // If there are errors, print the appropriate error messages.\n   if (result == 0) {\n       Serial.print(\"Temperature °C: \");\n       Serial.print(temperature);\n       Serial.print(',');\n       Serial.print(\"Humidity %:\");\n       Serial.print(humidity);\n       Serial.print(',');\n       lcd.setCursor(1,90);\n       lcd.print(\"Temperature C: \");\n       lcd.setCursor(180,90);\n       lcd.println(temperature);\n       lcd.setCursor(1,110);\n       lcd.print(\"Humidity %: \");\n       lcd.setCursor(180,110);\n       lcd.println(humidity);\n   } else {\n       // Print error message based on the error code.\n       Serial.println(DHT11::getErrorString(result));\n   }\n}\n```\n\n```arduino\n/*\nThis code is tested working with Sipeed Maixduino\nit measures following parameters:\n1. light intensity (BH1750 sensor),\n2. temperature & Humidity (DHT11 sensor), \n3. current and power consumption of DC motor (INA219 module)\n4. DC Motor Rotation per minute (Opto interruptor sensor reads DC motor rotation through the 30 slot mechanism. DC motor connected with L293N module)  \nall the measured parameters values are updated in the Sipeed ST7789 display and transferred via serial port at 115200 baud rate.\nModified and updated by K. Vairamani on 08/11/2024\n*/\n#include <Sipeed_ST7789.h>\n#include<BH1750.h>\n#include<Wire.h>\n#include \"INA219.h\"\n#include <DHT11.h>\nDHT11 dht11(3);\nINA219 INA(0x41);\nBH1750 lightMeter;\nunsigned long start_time = 0;\nunsigned long end_time = 0;\nint steps=0;\nfloat steps_old=0;\nfloat temp=0;\nfloat RPS=0;\nfloat RPM = 0;\nint counter = 2; //opto interruptor pin \nunsigned long millisBefore;\nvolatile int slotcount;\nint temperature = 0;\nint humidity = 0;\nSPIClass spi_(SPI0); // MUST be SPI0 for Maix series on board LCD\nSipeed_ST7789 lcd(320, 240, spi_);\n//L298N pin connections\nint PWM_EN = 6; //Connected to enable pin for L298N module\nint M1 = 8; // Connected to IN1 of L298N module\nint M2 = 9; // Connected to IN2 of L298N module\n//funtion protypes\nvoid title();\nvoid motorinit();\nvoid motoroff();\nvoid motoronforward();\nvoid motoronbackward();\nvoid RPM_speed(int a);\nvoid readlight();\nvoid readrpm();\nvoid readINA();\nvoid temphumi();\nvoid setup()\n{\n   Wire.begin();\n   Serial.begin(115200);\n   motorinit();\n   motoroff(); \n   pinMode(counter, INPUT_PULLUP);\n   lightMeter.begin();\n   if (!INA.begin() )\n   {\n       Serial.println(\"Could not connect to INA219. Fix and Reboot\");\n   }\n   INA.setMaxCurrentShunt(5, 0.002);\n   delay(1000);\n   lcd.begin(15000000, COLOR_BLUE);    \n   lcd.setRotation(0);\n\n}\nvoid loop() {\n title();\n readlight();  \n temphumi();\n RPM_speed(255); //Duty Cycle 100%\n motoronforward();\n readINA();\n readrpm();\n//  motoroff();\n delay(1000);\n}\n \nvoid motorinit()\n{\n // Set all the motor control pins to outputs\n    pinMode(PWM_EN, OUTPUT);\n    pinMode(M1, OUTPUT);\n    pinMode(M2, OUTPUT);\n}\nvoid motoroff()\n{    \n    // Turn off motors\n    digitalWrite(M1, LOW);\n    digitalWrite(M2, LOW);\n}\nvoid motoronforward()\n{\n // Turn ON motors Forward rotation\n    digitalWrite(M1, HIGH);\n    digitalWrite(M2, LOW);\n}\nvoid motoronbackward()\n{\n // Turn ON motors backward rotation\n    digitalWrite(M1, LOW);\n    digitalWrite(M2, HIGH);\n}\nvoid RPM_speed(int a)\n{\n analogWrite(PWM_EN, a);\n}\nvoid readrpm()\n{\n //lcd.print(\"RPM m/s: \");\n start_time=millis();\n end_time=start_time+1000;\n while(millis()<end_time)\n {\n   if(digitalRead(counter))\n   {\n     steps=steps+1; \n     while(digitalRead(counter));\n  }\n }\n temp=steps-steps_old;\n steps_old=steps;\n RPS=(temp/30); //change yoursRevolution encoder slot here Example: 30\n RPM=(RPS*60);\n Serial.print(\"RPM:\");\n Serial.println(RPM);\n lcd.setCursor(1,190);\n lcd.print(\"Motor RPM:\");\n lcd.setCursor(180,190);\n lcd.println(RPM);\n}\nvoid readlight()\n{\n float lux = lightMeter.readLightLevel();\n Serial.print(\"Light lx:\");\n Serial.print(lux,2);\n Serial.print(',');\n lcd.setCursor(1,70);\n lcd.print(\"Light lx: \");\n lcd.setCursor(180,70);\n lcd.println(lux);\n \n}\nvoid title()\n{\n   lcd.fillScreen(COLOR_BLUE);\n   lcd.setTextSize(2);\n   lcd.setTextColor(COLOR_WHITE);\n   lcd.setCursor(60,10);\n   lcd.println(\"Sipeed MAIXDUINO\");\n   lcd.setCursor(60,40);\n   lcd.println(\"IIoT test bed\");\n}\nvoid readINA()\n{\n lcd.setCursor(1,130);\n lcd.print(\"Shunt mV: \");\n lcd.setCursor(180,130);\n lcd.print(INA.getShuntVoltage_mV(), 2);\n lcd.setCursor(1,150);\n lcd.print(\"Current mA\");\n lcd.setCursor(180,150);\n lcd.print(INA.getCurrent_mA(), 2);\n lcd.setCursor(1,170);\n lcd.print(\"Power mW:\");\n lcd.setCursor(180,170);\n lcd.print(INA.getPower_mW(), 2);\n Serial.print(\"Current mA:\");\n Serial.print(INA.getCurrent_mA(), 2);\n Serial.print(\",\");\n Serial.print(\"Power mW:\");\n Serial.print(INA.getPower_mW(), 2);\n Serial.print(\",\");\n}\nvoid temphumi()\n{\n     // Attempt to read the temperature and humidity values from the DHT11 sensor.\n   int result = dht11.readTemperatureHumidity(temperature, humidity);\n   // Check the results of the readings.\n   // If the reading is successful, print the temperature and humidity values.\n   // If there are errors, print the appropriate error messages.\n   if (result == 0) {\n       Serial.print(\"Temperature °C: \");\n       Serial.print(temperature);\n       Serial.print(',');\n       Serial.print(\"Humidity %:\");\n       Serial.print(humidity);\n       Serial.print(',');\n       lcd.setCursor(1,90);\n       lcd.print(\"Temperature C: \");\n       lcd.setCursor(180,90);\n       lcd.println(temperature);\n       lcd.setCursor(1,110);\n       lcd.print(\"Humidity %: \");\n       lcd.setCursor(180,110);\n       lcd.println(humidity);\n   } else {\n       // Print error message based on the error code.\n       Serial.println(DHT11::getErrorString(result));\n   }\n}\n```\n\n# Start a Discussion on:\n\n# Add New Comment\n\nLog in or register to post comments"}
